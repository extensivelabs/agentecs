{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AgentECS","text":"<p>Entity Component System for AI Agent Orchestration</p> <p>AgentECS applies the ECS architectural pattern to AI agents, enabling flexible, scalable, and emergent agent workflows.</p> <ul> <li> <p> Getting Started</p> <p>Install AgentECS and run your first system</p> </li> <li> <p> Core Concepts</p> <p>Understand entities, components, and systems</p> </li> <li> <p> Cookbook</p> <p>Practical examples and patterns</p> </li> <li> <p> API Reference</p> <p>Complete API documentation</p> </li> </ul>"},{"location":"#why-another-agent-framework","title":"Why Another Agent Framework?","text":"<p>Existing frameworks assume we know what agentic workflows should look like:</p> <ul> <li>Monolithic agents with hand-off protocols</li> <li>Graph-based workflows with explicit orchestration</li> </ul> <p>We're early in AI agents. The design space is vast and largely unexplored.</p> <p>AgentECS takes a different approach. Decouple agents into primitives:</p> <ul> <li>Entities = Identities (agents, tasks, resources)</li> <li>Components = Data (state, capabilities, context)</li> <li>Systems = Behavior (operates on component patterns)</li> </ul> <p>Then let workflows emerge from their interactions.</p> <ul> <li> <p> Emergent Workflows</p> <p>No explicit graphs needed. Behavior emerges from system interactions.</p> </li> <li> <p> Resource Sharing</p> <p>Agents can share or compete for resources: LLMs, context, tasks.</p> </li> <li> <p> Dynamic Agents</p> <p>Agents can merge, split, spawn, or be destroyed at runtime.</p> </li> <li> <p> Dynamic Environments</p> <p>The environment can change based on collective agent state.</p> </li> <li> <p> Flexible Granularity</p> <p>Systems operate on any level: single agents, groups, or entire swarms.</p> </li> <li> <p> Automatic Parallelism</p> <p>Declared access patterns enable safe parallel execution at scale.</p> </li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dataclasses import dataclass\nfrom agentecs import World, component, system, ScopedAccess\n\n@component\n@dataclass\nclass Agent:\n    name: str\n\n@component\n@dataclass\nclass Task:\n    description: str\n    done: bool = False\n\n@system(reads=(Agent, Task), writes=(Task,))\ndef work(world: ScopedAccess) -&gt; None:\n    for entity, agent, task in world(Agent, Task):\n        if not task.done:\n            print(f\"{agent.name}: {task.description}\")\n            world[entity, Task] = Task(task.description, done=True)\n\n# Create world and register system\nworld = World()\nworld.register_system(work)\n\n# Spawn agents with tasks\nworld.spawn(Agent(\"Alice\"), Task(\"Write report\"))\nworld.spawn(Agent(\"Bob\"), Task(\"Review code\"))\n\n# Run one tick - both agents work in parallel\nworld.tick()\n</code></pre> <p>Output: <pre><code>Alice: Write report\nBob: Review code\n</code></pre></p>"},{"location":"#core-principles","title":"Core Principles","text":""},{"location":"#entities-are-just-ids","title":"Entities Are Just IDs","text":"<p>Entities have no behavior. They're identities that hold components together:</p> <pre><code># An agent is just an entity with certain components\nagent = world.spawn(\n    Agent(name=\"Alice\"),\n    Context(messages=[]),\n    Task(description=\"Analyze data\"),\n)\n</code></pre>"},{"location":"#systems-operate-on-patterns","title":"Systems Operate on Patterns","text":"<p>Systems query for component combinations, not specific entities:</p> <pre><code>@system(reads=(Agent, Task), writes=(Task,))\ndef work(world: ScopedAccess) -&gt; None:\n    # Finds ALL entities with both Agent AND Task\n    for entity, agent, task in world(Agent, Task):\n        ...\n</code></pre>"},{"location":"#changes-apply-at-tick-boundaries","title":"Changes Apply at Tick Boundaries","text":"<p>Systems write to a buffer. Changes merge and apply when the tick completes:</p> <pre><code>world[entity, Task] = Task(...)  # Buffered, not immediate\nworld.tick()                      # All changes apply atomically\n</code></pre> <p>This enables snapshot isolation: systems see consistent state, even when running in parallel.</p>"},{"location":"#access-patterns-enable-parallelism","title":"Access Patterns Enable Parallelism","text":"<p>Declare what components a system reads and writes. Non-conflicting systems run in parallel:</p> <pre><code># These CAN run in parallel (disjoint writes)\n@system(reads=(Position,), writes=(Position,))\n@system(reads=(Health,), writes=(Health,))\n\n# These CANNOT (both write Position)\n@system(reads=(Position,), writes=(Position,))\n@system(reads=(Velocity,), writes=(Position,))\n</code></pre>"},{"location":"#what-can-you-build","title":"What Can You Build?","text":"<p>AgentECS enables workflows that are awkward or impossible in traditional frameworks:</p> <ul> <li>Agent swarms that scale to thousands of concurrent agents</li> <li>Competitive agents fighting for shared context or resources</li> <li>Social dynamics where agents merge based on similarity</li> <li>Hierarchical agents that split tasks and spawn sub-agents</li> <li>Adaptive environments that respond to collective agent behavior</li> <li>Monte Carlo search with parallel simulation branches</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Get AgentECS running</li> <li>Core Concepts - Understand the fundamentals</li> <li>Cookbook - Learn common patterns</li> <li>Architecture - Deep dive into internals</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for AgentECS.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>AgentECS follows a layered architecture separating stateless functionalities (core/) from stateful services (world/, storage/, scheduling/). The API is organized to reflect this structure:</p>"},{"location":"api/#core-api","title":"Core API","text":"<p>Pure, stateless building blocks for entities, components, systems, and queries. These are the fundamental abstractions that make up the ECS framework.</p> <p>Key modules: - Component: Define components with operation protocols (Mergeable, Splittable, etc.) - Identity: Entity IDs with generational indices and shard support - Query: Query builder for filtering entities by component types - System: Define systems with access patterns for parallelization</p> <p>\u2192 View Core API</p>"},{"location":"api/#world-api","title":"World API","text":"<p>Central coordination service managing entity lifecycle, component storage, and system execution. The World acts as the orchestrator between your systems and the storage backend.</p> <p>Key classes: - World: Main entry point for entity management and system execution - ScopedAccess: Access control for systems with snapshot isolation - EntityHandle: Convenient wrapper for single-entity operations</p> <p>\u2192 View World API</p>"},{"location":"api/#storage-api","title":"Storage API","text":"<p>Storage backend interface and implementations. AgentECS uses a pluggable storage protocol, currently implemented with LocalStorage for single-process use.</p> <p>Key modules: - Storage Protocol: Interface for storage backends - LocalStorage: In-memory implementation with O(n) queries</p> <p>\u2192 View Storage API</p>"},{"location":"api/#scheduling-api","title":"Scheduling API","text":"<p>Parallel execution engine with configurable merge strategies. The scheduler runs systems in parallel with snapshot isolation and merges results using configurable strategies.</p> <p>Key classes: - SimpleScheduler: Parallel execution with configurable merge strategies - SequentialScheduler: Alias for SimpleScheduler with max_concurrent=1</p> <p>\u2192 View Scheduling API</p>"},{"location":"api/#adapters-api","title":"Adapters API","text":"<p>Optional adapters for external integrations including vector stores and LLM access. Adapters implement runtime-checkable protocols and support multiple providers.</p> <p>Key modules: - Vector Store: ChromaDB adapter with typed data models - LLM Client: Instructor adapter for OpenAI, Anthropic, Gemini, LiteLLM - Config: Pydantic Settings for configuration</p> <p>\u2192 View Adapters API</p>"},{"location":"api/#quick-links","title":"Quick Links","text":"<p>Getting Started: - Core Concepts - Understand entities, components, and systems - First Steps - Your first AgentECS program</p> <p>Guides: - Design Philosophy - Why ECS for AI agents - Architecture - Detailed architecture overview</p>"},{"location":"api/adapters/","title":"Adapters API","text":"<p>Optional adapters for external integrations.</p>"},{"location":"api/adapters/#overview","title":"Overview","text":"<p>AgentECS provides protocol-based adapters for common external services: - Vector Stores: Semantic search and RAG (ChromaDB) - LLM Clients: Structured output with multiple providers (Instructor) - Configuration: Type-safe settings with environment variables</p> <p>Design Principles: - Optional dependencies: Don't require installation unless used - Protocol-based: Easy to implement custom adapters - Multi-provider: Support multiple backends per protocol - Type-safe: Generics ensure type safety throughout</p>"},{"location":"api/adapters/#vector-store-adapter","title":"Vector Store Adapter","text":"<p>Semantic search and retrieval-augmented generation.</p>"},{"location":"api/adapters/#vectorstore-protocol","title":"VectorStore Protocol","text":""},{"location":"api/adapters/#agentecs.adapters.VectorStore","title":"<code>VectorStore</code>","text":"<p>               Bases: <code>Protocol[T]</code></p> <p>Protocol for vector database operations with typed data models.</p> <p>Generic type T represents the data model (Pydantic model or dataclass) that will be stored alongside vectors.</p> Usage <p>@dataclass class Document:     title: str     content: str</p> <p>store: VectorStore[Document] = ChromaAdapter.from_memory(\"docs\", Document) store.add(\"doc1\", embedding=[...], text=\"...\", data=Document(...)) results = store.search(query_embedding=[...], mode=SearchMode.HYBRID)</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>@runtime_checkable\nclass VectorStore(Protocol[T]):\n    \"\"\"Protocol for vector database operations with typed data models.\n\n    Generic type T represents the data model (Pydantic model or dataclass)\n    that will be stored alongside vectors.\n\n    Usage:\n        @dataclass\n        class Document:\n            title: str\n            content: str\n\n        store: VectorStore[Document] = ChromaAdapter.from_memory(\"docs\", Document)\n        store.add(\"doc1\", embedding=[...], text=\"...\", data=Document(...))\n        results = store.search(query_embedding=[...], mode=SearchMode.HYBRID)\n    \"\"\"\n\n    def add(\n        self,\n        id: str,\n        embedding: list[float],\n        text: str,\n        data: T,\n    ) -&gt; str:\n        \"\"\"Add a single item to the store.\n\n        Args:\n            id: Unique identifier for the item.\n            embedding: Vector embedding.\n            text: Text content for keyword search.\n            data: Typed data model to store.\n\n        Returns:\n            The ID of the added item.\n        \"\"\"\n        ...\n\n    def add_batch(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n        \"\"\"Add multiple items to the store.\n\n        Args:\n            items: List of items to add.\n\n        Returns:\n            List of IDs for added items.\n        \"\"\"\n        ...\n\n    def get(self, id: str) -&gt; T | None:\n        \"\"\"Get an item by ID.\n\n        Args:\n            id: Item identifier.\n\n        Returns:\n            The data model if found, None otherwise.\n        \"\"\"\n        ...\n\n    def get_batch(self, ids: list[str]) -&gt; list[T | None]:\n        \"\"\"Get multiple items by ID.\n\n        Args:\n            ids: List of item identifiers.\n\n        Returns:\n            List of data models (None for missing items).\n        \"\"\"\n        ...\n\n    def update(\n        self,\n        id: str,\n        embedding: list[float] | None = None,\n        text: str | None = None,\n        data: T | None = None,\n    ) -&gt; bool:\n        \"\"\"Update an existing item.\n\n        Args:\n            id: Item identifier.\n            embedding: New embedding (optional).\n            text: New text (optional).\n            data: New data model (optional).\n\n        Returns:\n            True if item existed and was updated.\n        \"\"\"\n        ...\n\n    def delete(self, id: str) -&gt; bool:\n        \"\"\"Delete an item.\n\n        Args:\n            id: Item identifier.\n\n        Returns:\n            True if item existed and was deleted.\n        \"\"\"\n        ...\n\n    def delete_batch(self, ids: list[str]) -&gt; int:\n        \"\"\"Delete multiple items.\n\n        Args:\n            ids: List of item identifiers.\n\n        Returns:\n            Number of items deleted.\n        \"\"\"\n        ...\n\n    def search(\n        self,\n        query_embedding: list[float] | None = None,\n        query_text: str | None = None,\n        mode: SearchMode = SearchMode.VECTOR,\n        filters: Filter | FilterGroup | None = None,\n        limit: int = 10,\n    ) -&gt; list[SearchResult[T]]:\n        \"\"\"Search the store.\n\n        Args:\n            query_embedding: Query vector for vector/hybrid search.\n            query_text: Query text for keyword/hybrid search.\n            mode: Search mode (vector, keyword, or hybrid).\n            filters: Optional metadata filters.\n            limit: Maximum number of results.\n\n        Returns:\n            List of search results with scores.\n        \"\"\"\n        ...\n\n    def count(self) -&gt; int:\n        \"\"\"Get total number of items in the store.\n\n        Returns:\n            Item count.\n        \"\"\"\n        ...\n\n    # Async variants\n\n    async def add_async(\n        self,\n        id: str,\n        embedding: list[float],\n        text: str,\n        data: T,\n    ) -&gt; str:\n        \"\"\"Add a single item to the store (async).\n\n        Args:\n            id: Unique identifier for the item.\n            embedding: Vector embedding.\n            text: Text content for keyword search.\n            data: Typed data model to store.\n\n        Returns:\n            The ID of the added item.\n        \"\"\"\n        ...\n\n    async def add_batch_async(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n        \"\"\"Add multiple items to the store (async).\n\n        Args:\n            items: List of items to add.\n\n        Returns:\n            List of IDs for added items.\n        \"\"\"\n        ...\n\n    async def get_async(self, id: str) -&gt; T | None:\n        \"\"\"Get an item by ID (async).\n\n        Args:\n            id: Item identifier.\n\n        Returns:\n            The data model if found, None otherwise.\n        \"\"\"\n        ...\n\n    async def search_async(\n        self,\n        query_embedding: list[float] | None = None,\n        query_text: str | None = None,\n        mode: SearchMode = SearchMode.VECTOR,\n        filters: Filter | FilterGroup | None = None,\n        limit: int = 10,\n    ) -&gt; list[SearchResult[T]]:\n        \"\"\"Search the store (async).\n\n        Args:\n            query_embedding: Query vector for vector/hybrid search.\n            query_text: Query text for keyword/hybrid search.\n            mode: Search mode (vector, keyword, or hybrid).\n            filters: Optional metadata filters.\n            limit: Maximum number of results.\n\n        Returns:\n            List of search results with scores.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.add","title":"<code>add(id, embedding, text, data)</code>","text":"<p>Add a single item to the store.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the item.</p> required <code>embedding</code> <code>list[float]</code> <p>Vector embedding.</p> required <code>text</code> <code>str</code> <p>Text content for keyword search.</p> required <code>data</code> <code>T</code> <p>Typed data model to store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the added item.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def add(\n    self,\n    id: str,\n    embedding: list[float],\n    text: str,\n    data: T,\n) -&gt; str:\n    \"\"\"Add a single item to the store.\n\n    Args:\n        id: Unique identifier for the item.\n        embedding: Vector embedding.\n        text: Text content for keyword search.\n        data: Typed data model to store.\n\n    Returns:\n        The ID of the added item.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.add_batch","title":"<code>add_batch(items)</code>","text":"<p>Add multiple items to the store.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[VectorStoreItem[T]]</code> <p>List of items to add.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of IDs for added items.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def add_batch(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n    \"\"\"Add multiple items to the store.\n\n    Args:\n        items: List of items to add.\n\n    Returns:\n        List of IDs for added items.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.get","title":"<code>get(id)</code>","text":"<p>Get an item by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Item identifier.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The data model if found, None otherwise.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def get(self, id: str) -&gt; T | None:\n    \"\"\"Get an item by ID.\n\n    Args:\n        id: Item identifier.\n\n    Returns:\n        The data model if found, None otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.get_batch","title":"<code>get_batch(ids)</code>","text":"<p>Get multiple items by ID.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of item identifiers.</p> required <p>Returns:</p> Type Description <code>list[T | None]</code> <p>List of data models (None for missing items).</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def get_batch(self, ids: list[str]) -&gt; list[T | None]:\n    \"\"\"Get multiple items by ID.\n\n    Args:\n        ids: List of item identifiers.\n\n    Returns:\n        List of data models (None for missing items).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.update","title":"<code>update(id, embedding=None, text=None, data=None)</code>","text":"<p>Update an existing item.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Item identifier.</p> required <code>embedding</code> <code>list[float] | None</code> <p>New embedding (optional).</p> <code>None</code> <code>text</code> <code>str | None</code> <p>New text (optional).</p> <code>None</code> <code>data</code> <code>T | None</code> <p>New data model (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if item existed and was updated.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def update(\n    self,\n    id: str,\n    embedding: list[float] | None = None,\n    text: str | None = None,\n    data: T | None = None,\n) -&gt; bool:\n    \"\"\"Update an existing item.\n\n    Args:\n        id: Item identifier.\n        embedding: New embedding (optional).\n        text: New text (optional).\n        data: New data model (optional).\n\n    Returns:\n        True if item existed and was updated.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.delete","title":"<code>delete(id)</code>","text":"<p>Delete an item.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Item identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if item existed and was deleted.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def delete(self, id: str) -&gt; bool:\n    \"\"\"Delete an item.\n\n    Args:\n        id: Item identifier.\n\n    Returns:\n        True if item existed and was deleted.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.delete_batch","title":"<code>delete_batch(ids)</code>","text":"<p>Delete multiple items.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of item identifiers.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of items deleted.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def delete_batch(self, ids: list[str]) -&gt; int:\n    \"\"\"Delete multiple items.\n\n    Args:\n        ids: List of item identifiers.\n\n    Returns:\n        Number of items deleted.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.search","title":"<code>search(query_embedding=None, query_text=None, mode=SearchMode.VECTOR, filters=None, limit=10)</code>","text":"<p>Search the store.</p> <p>Parameters:</p> Name Type Description Default <code>query_embedding</code> <code>list[float] | None</code> <p>Query vector for vector/hybrid search.</p> <code>None</code> <code>query_text</code> <code>str | None</code> <p>Query text for keyword/hybrid search.</p> <code>None</code> <code>mode</code> <code>SearchMode</code> <p>Search mode (vector, keyword, or hybrid).</p> <code>VECTOR</code> <code>filters</code> <code>Filter | FilterGroup | None</code> <p>Optional metadata filters.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[SearchResult[T]]</code> <p>List of search results with scores.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def search(\n    self,\n    query_embedding: list[float] | None = None,\n    query_text: str | None = None,\n    mode: SearchMode = SearchMode.VECTOR,\n    filters: Filter | FilterGroup | None = None,\n    limit: int = 10,\n) -&gt; list[SearchResult[T]]:\n    \"\"\"Search the store.\n\n    Args:\n        query_embedding: Query vector for vector/hybrid search.\n        query_text: Query text for keyword/hybrid search.\n        mode: Search mode (vector, keyword, or hybrid).\n        filters: Optional metadata filters.\n        limit: Maximum number of results.\n\n    Returns:\n        List of search results with scores.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStore.count","title":"<code>count()</code>","text":"<p>Get total number of items in the store.</p> <p>Returns:</p> Type Description <code>int</code> <p>Item count.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Get total number of items in the store.\n\n    Returns:\n        Item count.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#chromadb-adapter","title":"ChromaDB Adapter","text":""},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter","title":"<code>ChromaAdapter</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>ChromaDB implementation of VectorStore protocol.</p> <p>Stores typed data models (Pydantic or dataclass) with vector embeddings and supports hybrid search.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>Collection</code> <p>The underlying ChromaDB collection.</p> <code>data_type</code> <code>type[T]</code> <p>The type of data model being stored.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>class ChromaAdapter(Generic[T]):\n    \"\"\"ChromaDB implementation of VectorStore protocol.\n\n    Stores typed data models (Pydantic or dataclass) with vector embeddings\n    and supports hybrid search.\n\n    Attributes:\n        collection: The underlying ChromaDB collection.\n        data_type: The type of data model being stored.\n    \"\"\"\n\n    def __init__(self, collection: Collection, data_type: type[T]) -&gt; None:\n        \"\"\"Initialize adapter with a ChromaDB collection.\n\n        Use factory methods instead of direct construction.\n\n        Args:\n            collection: ChromaDB collection instance.\n            data_type: Type of data model to store.\n        \"\"\"\n        self._collection = collection\n        self._data_type = data_type\n\n    @classmethod\n    def from_client(\n        cls,\n        client: chromadb.ClientAPI,  # type: ignore[name-defined]\n        collection_name: str,\n        data_type: type[T],\n    ) -&gt; ChromaAdapter[T]:\n        \"\"\"Create adapter from existing ChromaDB client.\n\n        Args:\n            client: ChromaDB client instance.\n            collection_name: Name of collection to use/create.\n            data_type: Type of data model to store.\n\n        Returns:\n            Configured ChromaAdapter instance.\n        \"\"\"\n        collection = client.get_or_create_collection(name=collection_name)\n        return cls(collection, data_type)\n\n    @classmethod\n    def from_path(\n        cls,\n        path: str,\n        collection_name: str,\n        data_type: type[T],\n    ) -&gt; ChromaAdapter[T]:\n        \"\"\"Create adapter with persistent storage.\n\n        Args:\n            path: Directory path for persistent storage.\n            collection_name: Name of collection to use/create.\n            data_type: Type of data model to store.\n\n        Returns:\n            Configured ChromaAdapter instance.\n        \"\"\"\n        try:\n            import chromadb\n        except ImportError as e:\n            raise ImportError(\n                \"chromadb is required for ChromaAdapter. Install with: pip install agentecs[chroma]\"\n            ) from e\n\n        client = chromadb.PersistentClient(path=path)\n        return cls.from_client(client, collection_name, data_type)\n\n    @classmethod\n    def from_memory(\n        cls,\n        collection_name: str,\n        data_type: type[T],\n    ) -&gt; ChromaAdapter[T]:\n        \"\"\"Create adapter with ephemeral (in-memory) storage.\n\n        Args:\n            collection_name: Name of collection to use/create.\n            data_type: Type of data model to store.\n\n        Returns:\n            Configured ChromaAdapter instance.\n        \"\"\"\n        try:\n            import chromadb\n        except ImportError as e:\n            raise ImportError(\n                \"chromadb is required for ChromaAdapter. Install with: pip install agentecs[chroma]\"\n            ) from e\n\n        client = chromadb.EphemeralClient()\n        return cls.from_client(client, collection_name, data_type)\n\n    @property\n    def collection(self) -&gt; Collection:\n        \"\"\"Get the underlying ChromaDB collection.\"\"\"\n        return self._collection\n\n    @property\n    def data_type(self) -&gt; type[T]:\n        \"\"\"Get the data type being stored.\"\"\"\n        return self._data_type\n\n    def add(\n        self,\n        id: str,\n        embedding: list[float],\n        text: str,\n        data: T,\n    ) -&gt; str:\n        \"\"\"Add a single item to the store.\n\n        Args:\n            id: Unique identifier for the item.\n            embedding: Vector embedding.\n            text: Text content for keyword search.\n            data: Typed data model to store.\n\n        Returns:\n            The ID of the added item.\n        \"\"\"\n        metadata = _serialize_to_metadata(data, self._data_type)\n        self._collection.add(\n            ids=[id],\n            embeddings=[embedding],  # type: ignore[arg-type]\n            documents=[text],\n            metadatas=[metadata],\n        )\n        return id\n\n    def add_batch(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n        \"\"\"Add multiple items to the store.\n\n        Args:\n            items: List of items to add.\n\n        Returns:\n            List of IDs for added items.\n        \"\"\"\n        if not items:\n            return []\n\n        ids = [item.id for item in items]\n        embeddings = [item.embedding for item in items]\n        documents = [item.text for item in items]\n        metadatas = [_serialize_to_metadata(item.data, self._data_type) for item in items]\n\n        self._collection.add(\n            ids=ids,\n            embeddings=embeddings,  # type: ignore[arg-type]\n            documents=documents,\n            metadatas=metadatas,  # type: ignore[arg-type]\n        )\n        return ids\n\n    def get(self, id: str) -&gt; T | None:\n        \"\"\"Get an item by ID.\n\n        Args:\n            id: Item identifier.\n\n        Returns:\n            The data model if found, None otherwise.\n        \"\"\"\n        result = self._collection.get(ids=[id], include=[\"metadatas\"])\n        if not result[\"ids\"]:\n            return None\n\n        metadata = result[\"metadatas\"][0]  # type: ignore[index]\n        return _deserialize_from_metadata(metadata, self._data_type)  # type: ignore[arg-type]\n\n    def get_batch(self, ids: list[str]) -&gt; list[T | None]:\n        \"\"\"Get multiple items by ID.\n\n        Args:\n            ids: List of item identifiers.\n\n        Returns:\n            List of data models (None for missing items).\n        \"\"\"\n        if not ids:\n            return []\n\n        result = self._collection.get(ids=ids, include=[\"metadatas\"])\n\n        # Build lookup from returned results\n        found: dict[str, dict[str, Any]] = {}\n        for i, id_ in enumerate(result[\"ids\"]):\n            found[id_] = result[\"metadatas\"][i]  # type: ignore[index,assignment]\n\n        # Return in original order\n        return [\n            _deserialize_from_metadata(found[id_], self._data_type) if id_ in found else None\n            for id_ in ids\n        ]\n\n    def update(\n        self,\n        id: str,\n        embedding: list[float] | None = None,\n        text: str | None = None,\n        data: T | None = None,\n    ) -&gt; bool:\n        \"\"\"Update an existing item.\n\n        Args:\n            id: Item identifier.\n            embedding: New embedding (optional).\n            text: New text (optional).\n            data: New data model (optional).\n\n        Returns:\n            True if item existed and was updated.\n        \"\"\"\n        # Check if exists\n        existing = self._collection.get(ids=[id])\n        if not existing[\"ids\"]:\n            return False\n\n        update_kwargs: dict[str, Any] = {\"ids\": [id]}\n\n        if embedding is not None:\n            update_kwargs[\"embeddings\"] = [embedding]\n        if text is not None:\n            update_kwargs[\"documents\"] = [text]\n        if data is not None:\n            update_kwargs[\"metadatas\"] = [_serialize_to_metadata(data, self._data_type)]\n\n        self._collection.update(**update_kwargs)\n        return True\n\n    def delete(self, id: str) -&gt; bool:\n        \"\"\"Delete an item.\n\n        Args:\n            id: Item identifier.\n\n        Returns:\n            True if item existed and was deleted.\n        \"\"\"\n        # Check if exists first\n        existing = self._collection.get(ids=[id])\n        if not existing[\"ids\"]:\n            return False\n\n        self._collection.delete(ids=[id])\n        return True\n\n    def delete_batch(self, ids: list[str]) -&gt; int:\n        \"\"\"Delete multiple items.\n\n        Args:\n            ids: List of item identifiers.\n\n        Returns:\n            Number of items deleted.\n        \"\"\"\n        if not ids:\n            return 0\n\n        # Check which exist\n        existing = self._collection.get(ids=ids)\n        existing_ids = set(existing[\"ids\"])\n\n        if not existing_ids:\n            return 0\n\n        self._collection.delete(ids=list(existing_ids))\n        return len(existing_ids)\n\n    def search(\n        self,\n        query_embedding: list[float] | None = None,\n        query_text: str | None = None,\n        mode: SearchMode = SearchMode.VECTOR,\n        filters: Filter | FilterGroup | None = None,\n        limit: int = 10,\n    ) -&gt; list[SearchResult[T]]:\n        \"\"\"Search the store.\n\n        Args:\n            query_embedding: Query vector for vector/hybrid search.\n            query_text: Query text for keyword/hybrid search.\n            mode: Search mode (vector, keyword, or hybrid).\n            filters: Optional metadata filters.\n            limit: Maximum number of results.\n\n        Returns:\n            List of search results with scores.\n        \"\"\"\n        where = _build_chroma_where(filters)\n\n        if mode == SearchMode.KEYWORD:\n            if query_text is None:\n                raise ValueError(\"query_text required for keyword search\")\n            # ChromaDB doesn't have pure keyword search, use where_document\n            result = self._collection.query(\n                query_texts=[query_text],\n                n_results=limit,\n                where=where,\n                include=[\"metadatas\", \"distances\", \"documents\"],\n            )\n        elif mode == SearchMode.VECTOR:\n            if query_embedding is None:\n                raise ValueError(\"query_embedding required for vector search\")\n            result = self._collection.query(\n                query_embeddings=[query_embedding],  # type: ignore[arg-type]\n                n_results=limit,\n                where=where,\n                include=[\"metadatas\", \"distances\", \"documents\"],\n            )\n        else:  # HYBRID\n            if query_embedding is None:\n                raise ValueError(\"query_embedding required for hybrid search\")\n            # ChromaDB hybrid: use embedding + optional text filter\n            result = self._collection.query(\n                query_embeddings=[query_embedding],  # type: ignore[arg-type]\n                query_texts=[query_text] if query_text else None,\n                n_results=limit,\n                where=where,\n                include=[\"metadatas\", \"distances\", \"documents\"],\n            )\n\n        # Convert results\n        results: list[SearchResult[T]] = []\n        if result[\"ids\"] and result[\"ids\"][0]:\n            ids = result[\"ids\"][0]\n            metadatas = result[\"metadatas\"][0] if result[\"metadatas\"] else [{}] * len(ids)\n            distances = result[\"distances\"][0] if result[\"distances\"] else [0.0] * len(ids)\n\n            for i, id_ in enumerate(ids):\n                data = _deserialize_from_metadata(metadatas[i], self._data_type)  # type: ignore[arg-type]\n                distance = distances[i]\n                # Convert distance to score (cosine: score = 1 - distance/2 for [-1,1] range)\n                # ChromaDB uses squared L2 by default, but we assume cosine was set\n                score = max(0.0, 1.0 - distance)\n\n                results.append(\n                    SearchResult(\n                        id=id_,\n                        data=data,\n                        score=score,\n                        distance=distance,\n                    )\n                )\n\n        return results\n\n    def count(self) -&gt; int:\n        \"\"\"Get total number of items in the store.\n\n        Returns:\n            Item count.\n        \"\"\"\n        return int(self._collection.count())\n\n    # Async variants - ChromaDB is sync, so we wrap in executor\n\n    async def add_async(\n        self,\n        id: str,\n        embedding: list[float],\n        text: str,\n        data: T,\n    ) -&gt; str:\n        \"\"\"Add a single item to the store (async).\n\n        Note: ChromaDB is synchronous, this runs in thread executor.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.get_event_loop().run_in_executor(\n            None, lambda: self.add(id, embedding, text, data)\n        )\n\n    async def add_batch_async(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n        \"\"\"Add multiple items to the store (async).\n\n        Note: ChromaDB is synchronous, this runs in thread executor.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.get_event_loop().run_in_executor(None, lambda: self.add_batch(items))\n\n    async def get_async(self, id: str) -&gt; T | None:\n        \"\"\"Get an item by ID (async).\n\n        Note: ChromaDB is synchronous, this runs in thread executor.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.get_event_loop().run_in_executor(None, lambda: self.get(id))\n\n    async def search_async(\n        self,\n        query_embedding: list[float] | None = None,\n        query_text: str | None = None,\n        mode: SearchMode = SearchMode.VECTOR,\n        filters: Filter | FilterGroup | None = None,\n        limit: int = 10,\n    ) -&gt; list[SearchResult[T]]:\n        \"\"\"Search the store (async).\n\n        Note: ChromaDB is synchronous, this runs in thread executor.\n        \"\"\"\n        import asyncio\n\n        return await asyncio.get_event_loop().run_in_executor(\n            None, lambda: self.search(query_embedding, query_text, mode, filters, limit)\n        )\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter.from_memory","title":"<code>from_memory(collection_name, data_type)</code>  <code>classmethod</code>","text":"<p>Create adapter with ephemeral (in-memory) storage.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Name of collection to use/create.</p> required <code>data_type</code> <code>type[T]</code> <p>Type of data model to store.</p> required <p>Returns:</p> Type Description <code>ChromaAdapter[T]</code> <p>Configured ChromaAdapter instance.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>@classmethod\ndef from_memory(\n    cls,\n    collection_name: str,\n    data_type: type[T],\n) -&gt; ChromaAdapter[T]:\n    \"\"\"Create adapter with ephemeral (in-memory) storage.\n\n    Args:\n        collection_name: Name of collection to use/create.\n        data_type: Type of data model to store.\n\n    Returns:\n        Configured ChromaAdapter instance.\n    \"\"\"\n    try:\n        import chromadb\n    except ImportError as e:\n        raise ImportError(\n            \"chromadb is required for ChromaAdapter. Install with: pip install agentecs[chroma]\"\n        ) from e\n\n    client = chromadb.EphemeralClient()\n    return cls.from_client(client, collection_name, data_type)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter.add","title":"<code>add(id, embedding, text, data)</code>","text":"<p>Add a single item to the store.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the item.</p> required <code>embedding</code> <code>list[float]</code> <p>Vector embedding.</p> required <code>text</code> <code>str</code> <p>Text content for keyword search.</p> required <code>data</code> <code>T</code> <p>Typed data model to store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The ID of the added item.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>def add(\n    self,\n    id: str,\n    embedding: list[float],\n    text: str,\n    data: T,\n) -&gt; str:\n    \"\"\"Add a single item to the store.\n\n    Args:\n        id: Unique identifier for the item.\n        embedding: Vector embedding.\n        text: Text content for keyword search.\n        data: Typed data model to store.\n\n    Returns:\n        The ID of the added item.\n    \"\"\"\n    metadata = _serialize_to_metadata(data, self._data_type)\n    self._collection.add(\n        ids=[id],\n        embeddings=[embedding],  # type: ignore[arg-type]\n        documents=[text],\n        metadatas=[metadata],\n    )\n    return id\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter.add_batch","title":"<code>add_batch(items)</code>","text":"<p>Add multiple items to the store.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[VectorStoreItem[T]]</code> <p>List of items to add.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of IDs for added items.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>def add_batch(self, items: list[VectorStoreItem[T]]) -&gt; list[str]:\n    \"\"\"Add multiple items to the store.\n\n    Args:\n        items: List of items to add.\n\n    Returns:\n        List of IDs for added items.\n    \"\"\"\n    if not items:\n        return []\n\n    ids = [item.id for item in items]\n    embeddings = [item.embedding for item in items]\n    documents = [item.text for item in items]\n    metadatas = [_serialize_to_metadata(item.data, self._data_type) for item in items]\n\n    self._collection.add(\n        ids=ids,\n        embeddings=embeddings,  # type: ignore[arg-type]\n        documents=documents,\n        metadatas=metadatas,  # type: ignore[arg-type]\n    )\n    return ids\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter.get","title":"<code>get(id)</code>","text":"<p>Get an item by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Item identifier.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>The data model if found, None otherwise.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>def get(self, id: str) -&gt; T | None:\n    \"\"\"Get an item by ID.\n\n    Args:\n        id: Item identifier.\n\n    Returns:\n        The data model if found, None otherwise.\n    \"\"\"\n    result = self._collection.get(ids=[id], include=[\"metadatas\"])\n    if not result[\"ids\"]:\n        return None\n\n    metadata = result[\"metadatas\"][0]  # type: ignore[index]\n    return _deserialize_from_metadata(metadata, self._data_type)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.chroma.ChromaAdapter.search","title":"<code>search(query_embedding=None, query_text=None, mode=SearchMode.VECTOR, filters=None, limit=10)</code>","text":"<p>Search the store.</p> <p>Parameters:</p> Name Type Description Default <code>query_embedding</code> <code>list[float] | None</code> <p>Query vector for vector/hybrid search.</p> <code>None</code> <code>query_text</code> <code>str | None</code> <p>Query text for keyword/hybrid search.</p> <code>None</code> <code>mode</code> <code>SearchMode</code> <p>Search mode (vector, keyword, or hybrid).</p> <code>VECTOR</code> <code>filters</code> <code>Filter | FilterGroup | None</code> <p>Optional metadata filters.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[SearchResult[T]]</code> <p>List of search results with scores.</p> Source code in <code>src/agentecs/adapters/chroma.py</code> <pre><code>def search(\n    self,\n    query_embedding: list[float] | None = None,\n    query_text: str | None = None,\n    mode: SearchMode = SearchMode.VECTOR,\n    filters: Filter | FilterGroup | None = None,\n    limit: int = 10,\n) -&gt; list[SearchResult[T]]:\n    \"\"\"Search the store.\n\n    Args:\n        query_embedding: Query vector for vector/hybrid search.\n        query_text: Query text for keyword/hybrid search.\n        mode: Search mode (vector, keyword, or hybrid).\n        filters: Optional metadata filters.\n        limit: Maximum number of results.\n\n    Returns:\n        List of search results with scores.\n    \"\"\"\n    where = _build_chroma_where(filters)\n\n    if mode == SearchMode.KEYWORD:\n        if query_text is None:\n            raise ValueError(\"query_text required for keyword search\")\n        # ChromaDB doesn't have pure keyword search, use where_document\n        result = self._collection.query(\n            query_texts=[query_text],\n            n_results=limit,\n            where=where,\n            include=[\"metadatas\", \"distances\", \"documents\"],\n        )\n    elif mode == SearchMode.VECTOR:\n        if query_embedding is None:\n            raise ValueError(\"query_embedding required for vector search\")\n        result = self._collection.query(\n            query_embeddings=[query_embedding],  # type: ignore[arg-type]\n            n_results=limit,\n            where=where,\n            include=[\"metadatas\", \"distances\", \"documents\"],\n        )\n    else:  # HYBRID\n        if query_embedding is None:\n            raise ValueError(\"query_embedding required for hybrid search\")\n        # ChromaDB hybrid: use embedding + optional text filter\n        result = self._collection.query(\n            query_embeddings=[query_embedding],  # type: ignore[arg-type]\n            query_texts=[query_text] if query_text else None,\n            n_results=limit,\n            where=where,\n            include=[\"metadatas\", \"distances\", \"documents\"],\n        )\n\n    # Convert results\n    results: list[SearchResult[T]] = []\n    if result[\"ids\"] and result[\"ids\"][0]:\n        ids = result[\"ids\"][0]\n        metadatas = result[\"metadatas\"][0] if result[\"metadatas\"] else [{}] * len(ids)\n        distances = result[\"distances\"][0] if result[\"distances\"] else [0.0] * len(ids)\n\n        for i, id_ in enumerate(ids):\n            data = _deserialize_from_metadata(metadatas[i], self._data_type)  # type: ignore[arg-type]\n            distance = distances[i]\n            # Convert distance to score (cosine: score = 1 - distance/2 for [-1,1] range)\n            # ChromaDB uses squared L2 by default, but we assume cosine was set\n            score = max(0.0, 1.0 - distance)\n\n            results.append(\n                SearchResult(\n                    id=id_,\n                    data=data,\n                    score=score,\n                    distance=distance,\n                )\n            )\n\n    return results\n</code></pre>"},{"location":"api/adapters/#models","title":"Models","text":""},{"location":"api/adapters/#agentecs.adapters.SearchMode","title":"<code>SearchMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Search mode for vector store queries.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>class SearchMode(Enum):\n    \"\"\"Search mode for vector store queries.\"\"\"\n\n    VECTOR = \"vector\"\n    KEYWORD = \"keyword\"\n    HYBRID = \"hybrid\"\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.SearchResult","title":"<code>SearchResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Result from a vector store search.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Document identifier.</p> <code>data</code> <code>T</code> <p>The typed data model.</p> <code>score</code> <code>float</code> <p>Similarity/relevance score (higher is better, normalized 0-1 for cosine).</p> <code>distance</code> <code>float | None</code> <p>Raw distance value (lower is better).</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@dataclass(slots=True)\nclass SearchResult(Generic[T]):\n    \"\"\"Result from a vector store search.\n\n    Attributes:\n        id: Document identifier.\n        data: The typed data model.\n        score: Similarity/relevance score (higher is better, normalized 0-1 for cosine).\n        distance: Raw distance value (lower is better).\n    \"\"\"\n\n    id: str\n    data: T\n    score: float\n    distance: float | None = None\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.VectorStoreItem","title":"<code>VectorStoreItem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Item to add to vector store.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the item.</p> <code>embedding</code> <code>list[float]</code> <p>Vector embedding.</p> <code>text</code> <code>str</code> <p>Text content for keyword search.</p> <code>data</code> <code>T</code> <p>The typed data model to store.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@dataclass(slots=True)\nclass VectorStoreItem(Generic[T]):\n    \"\"\"Item to add to vector store.\n\n    Attributes:\n        id: Unique identifier for the item.\n        embedding: Vector embedding.\n        text: Text content for keyword search.\n        data: The typed data model to store.\n    \"\"\"\n\n    id: str\n    embedding: list[float]\n    text: str\n    data: T\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.Filter","title":"<code>Filter</code>  <code>dataclass</code>","text":"<p>Single filter condition.</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>str</code> <p>Field name to filter on (supports nested: \"metadata.category\").</p> <code>operator</code> <code>FilterOperator</code> <p>Comparison operator.</p> <code>value</code> <code>Any</code> <p>Value to compare against.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@dataclass(slots=True)\nclass Filter:\n    \"\"\"Single filter condition.\n\n    Attributes:\n        field: Field name to filter on (supports nested: \"metadata.category\").\n        operator: Comparison operator.\n        value: Value to compare against.\n    \"\"\"\n\n    field: str\n    operator: FilterOperator\n    value: Any\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.FilterGroup","title":"<code>FilterGroup</code>  <code>dataclass</code>","text":"<p>Group of filters combined with AND/OR.</p> <p>Attributes:</p> Name Type Description <code>filters</code> <code>list[Filter | FilterGroup]</code> <p>List of Filter or nested FilterGroup.</p> <code>operator</code> <code>str</code> <p>How to combine filters (\"and\" or \"or\").</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@dataclass(slots=True)\nclass FilterGroup:\n    \"\"\"Group of filters combined with AND/OR.\n\n    Attributes:\n        filters: List of Filter or nested FilterGroup.\n        operator: How to combine filters (\"and\" or \"or\").\n    \"\"\"\n\n    filters: list[Filter | FilterGroup] = field(default_factory=list)\n    operator: str = \"and\"  # \"and\" or \"or\"\n</code></pre>"},{"location":"api/adapters/#llm-client-adapter","title":"LLM Client Adapter","text":"<p>Structured LLM output with multiple providers.</p>"},{"location":"api/adapters/#llmclient-protocol","title":"LLMClient Protocol","text":""},{"location":"api/adapters/#agentecs.adapters.LLMClient","title":"<code>LLMClient</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for LLM operations with structured output.</p> <p>Uses Pydantic models for type-safe responses.</p> Usage <p>class Analysis(BaseModel):     sentiment: str     confidence: float</p> <p>client: LLMClient = InstructorAdapter.from_openai_client(openai_client) result: Analysis = client.call(messages, response_model=Analysis)</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>@runtime_checkable\nclass LLMClient(Protocol):\n    \"\"\"Protocol for LLM operations with structured output.\n\n    Uses Pydantic models for type-safe responses.\n\n    Usage:\n        class Analysis(BaseModel):\n            sentiment: str\n            confidence: float\n\n        client: LLMClient = InstructorAdapter.from_openai_client(openai_client)\n        result: Analysis = client.call(messages, response_model=Analysis)\n    \"\"\"\n\n    def call(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Call LLM with structured output.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional provider-specific parameters.\n\n        Returns:\n            Validated response as the specified model type.\n        \"\"\"\n        ...\n\n    async def call_async(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Call LLM with structured output (async).\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional provider-specific parameters.\n\n        Returns:\n            Validated response as the specified model type.\n        \"\"\"\n        ...\n\n    def stream(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[T]:\n        \"\"\"Stream LLM response with partial structured output.\n\n        Yields partial objects as they are received, with fields\n        populated incrementally.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional provider-specific parameters.\n\n        Yields:\n            Partial response objects with incrementally populated fields.\n        \"\"\"\n        ...\n\n    def stream_async(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncIterator[T]:\n        \"\"\"Stream LLM response with partial structured output (async).\n\n        Yields partial objects as they are received, with fields\n        populated incrementally.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional provider-specific parameters.\n\n        Yields:\n            Partial response objects with incrementally populated fields.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.LLMClient.call","title":"<code>call(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>","text":"<p>Call LLM with structured output.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Validated response as the specified model type.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def call(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; T:\n    \"\"\"Call LLM with structured output.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional provider-specific parameters.\n\n    Returns:\n        Validated response as the specified model type.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.LLMClient.call_async","title":"<code>call_async(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Call LLM with structured output (async).</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Validated response as the specified model type.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>async def call_async(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; T:\n    \"\"\"Call LLM with structured output (async).\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional provider-specific parameters.\n\n    Returns:\n        Validated response as the specified model type.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.LLMClient.stream","title":"<code>stream(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>","text":"<p>Stream LLM response with partial structured output.</p> <p>Yields partial objects as they are received, with fields populated incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters.</p> <code>{}</code> <p>Yields:</p> Type Description <code>T</code> <p>Partial response objects with incrementally populated fields.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def stream(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[T]:\n    \"\"\"Stream LLM response with partial structured output.\n\n    Yields partial objects as they are received, with fields\n    populated incrementally.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional provider-specific parameters.\n\n    Yields:\n        Partial response objects with incrementally populated fields.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.LLMClient.stream_async","title":"<code>stream_async(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>","text":"<p>Stream LLM response with partial structured output (async).</p> <p>Yields partial objects as they are received, with fields populated incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional provider-specific parameters.</p> <code>{}</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Partial response objects with incrementally populated fields.</p> Source code in <code>src/agentecs/adapters/protocol.py</code> <pre><code>def stream_async(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; AsyncIterator[T]:\n    \"\"\"Stream LLM response with partial structured output (async).\n\n    Yields partial objects as they are received, with fields\n    populated incrementally.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional provider-specific parameters.\n\n    Yields:\n        Partial response objects with incrementally populated fields.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/adapters/#instructor-adapter","title":"Instructor Adapter","text":""},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter","title":"<code>InstructorAdapter</code>","text":"<p>Instructor-based implementation of LLMClient protocol.</p> <p>Uses instructor library for structured LLM output with Pydantic models.</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>The instructor-patched client.</p> <code>settings</code> <code>LLMSettings</code> <p>LLM configuration settings.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>class InstructorAdapter:\n    \"\"\"Instructor-based implementation of LLMClient protocol.\n\n    Uses instructor library for structured LLM output with Pydantic models.\n\n    Attributes:\n        client: The instructor-patched client.\n        settings: LLM configuration settings.\n    \"\"\"\n\n    def __init__(\n        self,\n        client: instructor.Instructor,\n        settings: LLMSettings | None = None,\n        async_client: instructor.AsyncInstructor | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize adapter with instructor client.\n\n        Use factory methods instead of direct construction.\n\n        Args:\n            client: Instructor-patched client for sync operations.\n            settings: Optional LLM settings (uses defaults if None).\n            async_client: Optional instructor-patched async client.\n        \"\"\"\n        self._client = client\n        self._async_client = async_client\n        self._settings = settings or LLMSettings()\n\n    @classmethod\n    def from_instructor_client(\n        cls,\n        client: instructor.Instructor,\n        settings: LLMSettings | None = None,\n        async_client: instructor.AsyncInstructor | None = None,\n    ) -&gt; InstructorAdapter:\n        \"\"\"Create adapter from existing instructor client.\n\n        Args:\n            client: Instructor-patched client.\n            settings: Optional LLM settings.\n            async_client: Optional async instructor client.\n\n        Returns:\n            Configured InstructorAdapter instance.\n        \"\"\"\n        return cls(client, settings, async_client)\n\n    @classmethod\n    def from_openai_client(\n        cls,\n        client: OpenAI,\n        settings: LLMSettings | None = None,\n        async_client: AsyncOpenAI | None = None,\n        mode: instructor.Mode | None = None,\n    ) -&gt; InstructorAdapter:\n        \"\"\"Create adapter from OpenAI client.\n\n        Wraps the OpenAI client with instructor for structured output.\n\n        Args:\n            client: OpenAI client instance.\n            settings: Optional LLM settings.\n            async_client: Optional async OpenAI client.\n            mode: Instructor mode (default: TOOLS).\n\n        Returns:\n            Configured InstructorAdapter instance.\n        \"\"\"\n        try:\n            import instructor\n        except ImportError as e:\n            raise ImportError(\n                \"instructor is required for InstructorAdapter. \"\n                \"Install with: pip install agentecs[llm]\"\n            ) from e\n\n        mode = mode or instructor.Mode.TOOLS\n        patched_client = instructor.from_openai(client, mode=mode)\n\n        patched_async_client = None\n        if async_client is not None:\n            patched_async_client = instructor.from_openai(async_client, mode=mode)\n\n        return cls(patched_client, settings, patched_async_client)\n\n    @classmethod\n    def from_anthropic(\n        cls,\n        client: Any,\n        settings: LLMSettings | None = None,\n        async_client: Any | None = None,\n        mode: Any | None = None,\n    ) -&gt; InstructorAdapter:\n        \"\"\"Create adapter from Anthropic client.\n\n        Wraps the Anthropic client with instructor for structured output.\n\n        Args:\n            client: anthropic.Anthropic client instance.\n            settings: Optional LLM settings.\n            async_client: Optional anthropic.AsyncAnthropic client.\n            mode: instructor.Mode (default: ANTHROPIC_TOOLS).\n\n        Returns:\n            Configured InstructorAdapter instance.\n\n        Example:\n            ```python\n            import anthropic\n            from agentecs.adapters import InstructorAdapter\n\n            client = anthropic.Anthropic()\n            adapter = InstructorAdapter.from_anthropic(client)\n            ```\n        \"\"\"\n        try:\n            import instructor\n        except ImportError as e:\n            raise ImportError(\n                \"instructor is required for InstructorAdapter. \"\n                \"Install with: pip install agentecs[llm]\"\n            ) from e\n\n        mode = mode or instructor.Mode.ANTHROPIC_TOOLS\n        patched_client = instructor.from_anthropic(client, mode=mode)\n\n        patched_async_client = None\n        if async_client is not None:\n            patched_async_client = instructor.from_anthropic(async_client, mode=mode)\n\n        return cls(patched_client, settings, patched_async_client)  # type: ignore[arg-type]\n\n    @classmethod\n    def from_litellm(\n        cls,\n        settings: LLMSettings | None = None,\n        mode: Any | None = None,\n    ) -&gt; InstructorAdapter:\n        \"\"\"Create adapter using LiteLLM for multi-provider support.\n\n        LiteLLM provides a unified interface to 100+ LLM providers including\n        OpenAI, Anthropic, Cohere, Azure, AWS Bedrock, and more.\n\n        Args:\n            settings: Optional LLM settings. The model field should use\n                LiteLLM's provider/model format (e.g., \"anthropic/claude-3-opus\").\n            mode: Instructor mode (default: TOOLS).\n\n        Returns:\n            Configured InstructorAdapter instance.\n\n        Example:\n            ```python\n            from agentecs.adapters import InstructorAdapter\n            from agentecs.config import LLMSettings\n\n            # Use Claude via LiteLLM\n            adapter = InstructorAdapter.from_litellm(\n                settings=LLMSettings(model=\"anthropic/claude-3-5-sonnet-20241022\")\n            )\n\n            # Use GPT-4 via LiteLLM\n            adapter = InstructorAdapter.from_litellm(\n                settings=LLMSettings(model=\"openai/gpt-4o\")\n            )\n            ```\n        \"\"\"\n        try:\n            import instructor\n            import litellm  # type: ignore[import-not-found]\n        except ImportError as e:\n            raise ImportError(\n                \"instructor and litellm are required. \"\n                \"Install with: pip install agentecs[llm] litellm\"\n            ) from e\n\n        mode = mode or instructor.Mode.TOOLS\n        patched_client = instructor.from_litellm(litellm.completion, mode=mode)\n        patched_async_client = instructor.from_litellm(litellm.acompletion, mode=mode)\n\n        return cls(patched_client, settings, patched_async_client)\n\n    @classmethod\n    def from_gemini(\n        cls,\n        client: Any,\n        settings: LLMSettings | None = None,\n        mode: Any | None = None,\n    ) -&gt; InstructorAdapter:\n        \"\"\"Create adapter from Google Gemini client.\n\n        Wraps the Google GenerativeModel with instructor for structured output.\n\n        Args:\n            client: Google GenerativeModel instance.\n            settings: Optional LLM settings.\n            mode: Instructor mode (default: GEMINI_JSON).\n\n        Returns:\n            Configured InstructorAdapter instance.\n\n        Example:\n            ```python\n            import google.generativeai as genai\n            from agentecs.adapters import InstructorAdapter\n\n            genai.configure(api_key=\"your-api-key\")\n            model = genai.GenerativeModel(\"gemini-1.5-flash\")\n            adapter = InstructorAdapter.from_gemini(model)\n            ```\n        \"\"\"\n        try:\n            import instructor\n        except ImportError as e:\n            raise ImportError(\n                \"instructor is required for InstructorAdapter. \"\n                \"Install with: pip install agentecs[llm] google-generativeai\"\n            ) from e\n\n        mode = mode or instructor.Mode.GEMINI_JSON\n        patched_client = instructor.from_gemini(client, mode=mode)\n\n        # Gemini doesn't have a separate async client pattern\n        return cls(patched_client, settings, None)\n\n    @property\n    def settings(self) -&gt; LLMSettings:\n        \"\"\"Get the LLM settings.\"\"\"\n        return self._settings\n\n    def call(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Call LLM with structured output.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional parameters passed to the API.\n\n        Returns:\n            Validated response as the specified model type.\n        \"\"\"\n        openai_messages = _messages_to_openai(messages)\n\n        # Build kwargs with settings\n        call_kwargs: dict[str, Any] = {\n            \"model\": kwargs.pop(\"model\", self._settings.model),\n            \"messages\": openai_messages,\n            \"response_model\": response_model,\n            \"temperature\": temperature if temperature is not None else self._settings.temperature,\n            \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n        }\n\n        if max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = max_tokens\n        elif self._settings.max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n        # Merge any additional kwargs\n        call_kwargs.update(kwargs)\n\n        return cast(T, self._client.chat.completions.create(**call_kwargs))\n\n    async def call_async(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; T:\n        \"\"\"Call LLM with structured output (async).\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional parameters passed to the API.\n\n        Returns:\n            Validated response as the specified model type.\n\n        Raises:\n            RuntimeError: If no async client was provided.\n        \"\"\"\n        if self._async_client is None:\n            raise RuntimeError(\n                \"No async client configured. Provide async_client when creating the adapter.\"\n            )\n\n        openai_messages = _messages_to_openai(messages)\n\n        call_kwargs: dict[str, Any] = {\n            \"model\": kwargs.pop(\"model\", self._settings.model),\n            \"messages\": openai_messages,\n            \"response_model\": response_model,\n            \"temperature\": temperature if temperature is not None else self._settings.temperature,\n            \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n        }\n\n        if max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = max_tokens\n        elif self._settings.max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n        call_kwargs.update(kwargs)\n\n        return cast(T, await self._async_client.chat.completions.create(**call_kwargs))\n\n    def stream(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; Iterator[T]:\n        \"\"\"Stream LLM response with partial structured output.\n\n        Uses instructor's Partial for incremental field population.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional parameters passed to the API.\n\n        Yields:\n            Partial response objects with incrementally populated fields.\n        \"\"\"\n        try:\n            from instructor import Partial\n        except ImportError as e:\n            raise ImportError(\n                \"instructor is required for streaming. Install with: pip install agentecs[llm]\"\n            ) from e\n\n        openai_messages = _messages_to_openai(messages)\n\n        call_kwargs: dict[str, Any] = {\n            \"model\": kwargs.pop(\"model\", self._settings.model),\n            \"messages\": openai_messages,\n            \"response_model\": Partial[response_model],  # type: ignore[valid-type]\n            \"temperature\": temperature if temperature is not None else self._settings.temperature,\n            \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n            \"stream\": True,\n        }\n\n        if max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = max_tokens\n        elif self._settings.max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n        call_kwargs.update(kwargs)\n\n        # Instructor returns an iterator of partial objects when streaming\n        yield from self._client.chat.completions.create(**call_kwargs)\n\n    async def stream_async(\n        self,\n        messages: list[Message],\n        response_model: type[T],\n        temperature: float | None = None,\n        max_tokens: int | None = None,\n        **kwargs: Any,\n    ) -&gt; AsyncIterator[T]:\n        \"\"\"Stream LLM response with partial structured output (async).\n\n        Uses instructor's Partial for incremental field population.\n\n        Args:\n            messages: Conversation messages.\n            response_model: Pydantic model for response validation.\n            temperature: Override default temperature.\n            max_tokens: Override default max tokens.\n            **kwargs: Additional parameters passed to the API.\n\n        Yields:\n            Partial response objects with incrementally populated fields.\n\n        Raises:\n            RuntimeError: If no async client was provided.\n        \"\"\"\n        if self._async_client is None:\n            raise RuntimeError(\n                \"No async client configured. Provide async_client when creating the adapter.\"\n            )\n\n        try:\n            from instructor import Partial\n        except ImportError as e:\n            raise ImportError(\n                \"instructor is required for streaming. Install with: pip install agentecs[llm]\"\n            ) from e\n\n        openai_messages = _messages_to_openai(messages)\n\n        call_kwargs: dict[str, Any] = {\n            \"model\": kwargs.pop(\"model\", self._settings.model),\n            \"messages\": openai_messages,\n            \"response_model\": Partial[response_model],  # type: ignore[valid-type]\n            \"temperature\": temperature if temperature is not None else self._settings.temperature,\n            \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n            \"stream\": True,\n        }\n\n        if max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = max_tokens\n        elif self._settings.max_tokens is not None:\n            call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n        call_kwargs.update(kwargs)\n\n        async for partial_obj in await self._async_client.chat.completions.create(**call_kwargs):\n            yield partial_obj\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.from_openai_client","title":"<code>from_openai_client(client, settings=None, async_client=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create adapter from OpenAI client.</p> <p>Wraps the OpenAI client with instructor for structured output.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>OpenAI</code> <p>OpenAI client instance.</p> required <code>settings</code> <code>LLMSettings | None</code> <p>Optional LLM settings.</p> <code>None</code> <code>async_client</code> <code>AsyncOpenAI | None</code> <p>Optional async OpenAI client.</p> <code>None</code> <code>mode</code> <code>Mode | None</code> <p>Instructor mode (default: TOOLS).</p> <code>None</code> <p>Returns:</p> Type Description <code>InstructorAdapter</code> <p>Configured InstructorAdapter instance.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>@classmethod\ndef from_openai_client(\n    cls,\n    client: OpenAI,\n    settings: LLMSettings | None = None,\n    async_client: AsyncOpenAI | None = None,\n    mode: instructor.Mode | None = None,\n) -&gt; InstructorAdapter:\n    \"\"\"Create adapter from OpenAI client.\n\n    Wraps the OpenAI client with instructor for structured output.\n\n    Args:\n        client: OpenAI client instance.\n        settings: Optional LLM settings.\n        async_client: Optional async OpenAI client.\n        mode: Instructor mode (default: TOOLS).\n\n    Returns:\n        Configured InstructorAdapter instance.\n    \"\"\"\n    try:\n        import instructor\n    except ImportError as e:\n        raise ImportError(\n            \"instructor is required for InstructorAdapter. \"\n            \"Install with: pip install agentecs[llm]\"\n        ) from e\n\n    mode = mode or instructor.Mode.TOOLS\n    patched_client = instructor.from_openai(client, mode=mode)\n\n    patched_async_client = None\n    if async_client is not None:\n        patched_async_client = instructor.from_openai(async_client, mode=mode)\n\n    return cls(patched_client, settings, patched_async_client)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.from_anthropic","title":"<code>from_anthropic(client, settings=None, async_client=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create adapter from Anthropic client.</p> <p>Wraps the Anthropic client with instructor for structured output.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>anthropic.Anthropic client instance.</p> required <code>settings</code> <code>LLMSettings | None</code> <p>Optional LLM settings.</p> <code>None</code> <code>async_client</code> <code>Any | None</code> <p>Optional anthropic.AsyncAnthropic client.</p> <code>None</code> <code>mode</code> <code>Any | None</code> <p>instructor.Mode (default: ANTHROPIC_TOOLS).</p> <code>None</code> <p>Returns:</p> Type Description <code>InstructorAdapter</code> <p>Configured InstructorAdapter instance.</p> Example <pre><code>import anthropic\nfrom agentecs.adapters import InstructorAdapter\n\nclient = anthropic.Anthropic()\nadapter = InstructorAdapter.from_anthropic(client)\n</code></pre> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>@classmethod\ndef from_anthropic(\n    cls,\n    client: Any,\n    settings: LLMSettings | None = None,\n    async_client: Any | None = None,\n    mode: Any | None = None,\n) -&gt; InstructorAdapter:\n    \"\"\"Create adapter from Anthropic client.\n\n    Wraps the Anthropic client with instructor for structured output.\n\n    Args:\n        client: anthropic.Anthropic client instance.\n        settings: Optional LLM settings.\n        async_client: Optional anthropic.AsyncAnthropic client.\n        mode: instructor.Mode (default: ANTHROPIC_TOOLS).\n\n    Returns:\n        Configured InstructorAdapter instance.\n\n    Example:\n        ```python\n        import anthropic\n        from agentecs.adapters import InstructorAdapter\n\n        client = anthropic.Anthropic()\n        adapter = InstructorAdapter.from_anthropic(client)\n        ```\n    \"\"\"\n    try:\n        import instructor\n    except ImportError as e:\n        raise ImportError(\n            \"instructor is required for InstructorAdapter. \"\n            \"Install with: pip install agentecs[llm]\"\n        ) from e\n\n    mode = mode or instructor.Mode.ANTHROPIC_TOOLS\n    patched_client = instructor.from_anthropic(client, mode=mode)\n\n    patched_async_client = None\n    if async_client is not None:\n        patched_async_client = instructor.from_anthropic(async_client, mode=mode)\n\n    return cls(patched_client, settings, patched_async_client)  # type: ignore[arg-type]\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.from_litellm","title":"<code>from_litellm(settings=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create adapter using LiteLLM for multi-provider support.</p> <p>LiteLLM provides a unified interface to 100+ LLM providers including OpenAI, Anthropic, Cohere, Azure, AWS Bedrock, and more.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>LLMSettings | None</code> <p>Optional LLM settings. The model field should use LiteLLM's provider/model format (e.g., \"anthropic/claude-3-opus\").</p> <code>None</code> <code>mode</code> <code>Any | None</code> <p>Instructor mode (default: TOOLS).</p> <code>None</code> <p>Returns:</p> Type Description <code>InstructorAdapter</code> <p>Configured InstructorAdapter instance.</p> Example <pre><code>from agentecs.adapters import InstructorAdapter\nfrom agentecs.config import LLMSettings\n\n# Use Claude via LiteLLM\nadapter = InstructorAdapter.from_litellm(\n    settings=LLMSettings(model=\"anthropic/claude-3-5-sonnet-20241022\")\n)\n\n# Use GPT-4 via LiteLLM\nadapter = InstructorAdapter.from_litellm(\n    settings=LLMSettings(model=\"openai/gpt-4o\")\n)\n</code></pre> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>@classmethod\ndef from_litellm(\n    cls,\n    settings: LLMSettings | None = None,\n    mode: Any | None = None,\n) -&gt; InstructorAdapter:\n    \"\"\"Create adapter using LiteLLM for multi-provider support.\n\n    LiteLLM provides a unified interface to 100+ LLM providers including\n    OpenAI, Anthropic, Cohere, Azure, AWS Bedrock, and more.\n\n    Args:\n        settings: Optional LLM settings. The model field should use\n            LiteLLM's provider/model format (e.g., \"anthropic/claude-3-opus\").\n        mode: Instructor mode (default: TOOLS).\n\n    Returns:\n        Configured InstructorAdapter instance.\n\n    Example:\n        ```python\n        from agentecs.adapters import InstructorAdapter\n        from agentecs.config import LLMSettings\n\n        # Use Claude via LiteLLM\n        adapter = InstructorAdapter.from_litellm(\n            settings=LLMSettings(model=\"anthropic/claude-3-5-sonnet-20241022\")\n        )\n\n        # Use GPT-4 via LiteLLM\n        adapter = InstructorAdapter.from_litellm(\n            settings=LLMSettings(model=\"openai/gpt-4o\")\n        )\n        ```\n    \"\"\"\n    try:\n        import instructor\n        import litellm  # type: ignore[import-not-found]\n    except ImportError as e:\n        raise ImportError(\n            \"instructor and litellm are required. \"\n            \"Install with: pip install agentecs[llm] litellm\"\n        ) from e\n\n    mode = mode or instructor.Mode.TOOLS\n    patched_client = instructor.from_litellm(litellm.completion, mode=mode)\n    patched_async_client = instructor.from_litellm(litellm.acompletion, mode=mode)\n\n    return cls(patched_client, settings, patched_async_client)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.from_gemini","title":"<code>from_gemini(client, settings=None, mode=None)</code>  <code>classmethod</code>","text":"<p>Create adapter from Google Gemini client.</p> <p>Wraps the Google GenerativeModel with instructor for structured output.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>Google GenerativeModel instance.</p> required <code>settings</code> <code>LLMSettings | None</code> <p>Optional LLM settings.</p> <code>None</code> <code>mode</code> <code>Any | None</code> <p>Instructor mode (default: GEMINI_JSON).</p> <code>None</code> <p>Returns:</p> Type Description <code>InstructorAdapter</code> <p>Configured InstructorAdapter instance.</p> Example <pre><code>import google.generativeai as genai\nfrom agentecs.adapters import InstructorAdapter\n\ngenai.configure(api_key=\"your-api-key\")\nmodel = genai.GenerativeModel(\"gemini-1.5-flash\")\nadapter = InstructorAdapter.from_gemini(model)\n</code></pre> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>@classmethod\ndef from_gemini(\n    cls,\n    client: Any,\n    settings: LLMSettings | None = None,\n    mode: Any | None = None,\n) -&gt; InstructorAdapter:\n    \"\"\"Create adapter from Google Gemini client.\n\n    Wraps the Google GenerativeModel with instructor for structured output.\n\n    Args:\n        client: Google GenerativeModel instance.\n        settings: Optional LLM settings.\n        mode: Instructor mode (default: GEMINI_JSON).\n\n    Returns:\n        Configured InstructorAdapter instance.\n\n    Example:\n        ```python\n        import google.generativeai as genai\n        from agentecs.adapters import InstructorAdapter\n\n        genai.configure(api_key=\"your-api-key\")\n        model = genai.GenerativeModel(\"gemini-1.5-flash\")\n        adapter = InstructorAdapter.from_gemini(model)\n        ```\n    \"\"\"\n    try:\n        import instructor\n    except ImportError as e:\n        raise ImportError(\n            \"instructor is required for InstructorAdapter. \"\n            \"Install with: pip install agentecs[llm] google-generativeai\"\n        ) from e\n\n    mode = mode or instructor.Mode.GEMINI_JSON\n    patched_client = instructor.from_gemini(client, mode=mode)\n\n    # Gemini doesn't have a separate async client pattern\n    return cls(patched_client, settings, None)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.call","title":"<code>call(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>","text":"<p>Call LLM with structured output.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters passed to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Validated response as the specified model type.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>def call(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; T:\n    \"\"\"Call LLM with structured output.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional parameters passed to the API.\n\n    Returns:\n        Validated response as the specified model type.\n    \"\"\"\n    openai_messages = _messages_to_openai(messages)\n\n    # Build kwargs with settings\n    call_kwargs: dict[str, Any] = {\n        \"model\": kwargs.pop(\"model\", self._settings.model),\n        \"messages\": openai_messages,\n        \"response_model\": response_model,\n        \"temperature\": temperature if temperature is not None else self._settings.temperature,\n        \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n    }\n\n    if max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = max_tokens\n    elif self._settings.max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n    # Merge any additional kwargs\n    call_kwargs.update(kwargs)\n\n    return cast(T, self._client.chat.completions.create(**call_kwargs))\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.call_async","title":"<code>call_async(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Call LLM with structured output (async).</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters passed to the API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>Validated response as the specified model type.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no async client was provided.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>async def call_async(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; T:\n    \"\"\"Call LLM with structured output (async).\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional parameters passed to the API.\n\n    Returns:\n        Validated response as the specified model type.\n\n    Raises:\n        RuntimeError: If no async client was provided.\n    \"\"\"\n    if self._async_client is None:\n        raise RuntimeError(\n            \"No async client configured. Provide async_client when creating the adapter.\"\n        )\n\n    openai_messages = _messages_to_openai(messages)\n\n    call_kwargs: dict[str, Any] = {\n        \"model\": kwargs.pop(\"model\", self._settings.model),\n        \"messages\": openai_messages,\n        \"response_model\": response_model,\n        \"temperature\": temperature if temperature is not None else self._settings.temperature,\n        \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n    }\n\n    if max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = max_tokens\n    elif self._settings.max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n    call_kwargs.update(kwargs)\n\n    return cast(T, await self._async_client.chat.completions.create(**call_kwargs))\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.stream","title":"<code>stream(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>","text":"<p>Stream LLM response with partial structured output.</p> <p>Uses instructor's Partial for incremental field population.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters passed to the API.</p> <code>{}</code> <p>Yields:</p> Type Description <code>T</code> <p>Partial response objects with incrementally populated fields.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>def stream(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; Iterator[T]:\n    \"\"\"Stream LLM response with partial structured output.\n\n    Uses instructor's Partial for incremental field population.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional parameters passed to the API.\n\n    Yields:\n        Partial response objects with incrementally populated fields.\n    \"\"\"\n    try:\n        from instructor import Partial\n    except ImportError as e:\n        raise ImportError(\n            \"instructor is required for streaming. Install with: pip install agentecs[llm]\"\n        ) from e\n\n    openai_messages = _messages_to_openai(messages)\n\n    call_kwargs: dict[str, Any] = {\n        \"model\": kwargs.pop(\"model\", self._settings.model),\n        \"messages\": openai_messages,\n        \"response_model\": Partial[response_model],  # type: ignore[valid-type]\n        \"temperature\": temperature if temperature is not None else self._settings.temperature,\n        \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n        \"stream\": True,\n    }\n\n    if max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = max_tokens\n    elif self._settings.max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n    call_kwargs.update(kwargs)\n\n    # Instructor returns an iterator of partial objects when streaming\n    yield from self._client.chat.completions.create(**call_kwargs)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.instructor.InstructorAdapter.stream_async","title":"<code>stream_async(messages, response_model, temperature=None, max_tokens=None, **kwargs)</code>  <code>async</code>","text":"<p>Stream LLM response with partial structured output (async).</p> <p>Uses instructor's Partial for incremental field population.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[Message]</code> <p>Conversation messages.</p> required <code>response_model</code> <code>type[T]</code> <p>Pydantic model for response validation.</p> required <code>temperature</code> <code>float | None</code> <p>Override default temperature.</p> <code>None</code> <code>max_tokens</code> <code>int | None</code> <p>Override default max tokens.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters passed to the API.</p> <code>{}</code> <p>Yields:</p> Type Description <code>AsyncIterator[T]</code> <p>Partial response objects with incrementally populated fields.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no async client was provided.</p> Source code in <code>src/agentecs/adapters/instructor.py</code> <pre><code>async def stream_async(\n    self,\n    messages: list[Message],\n    response_model: type[T],\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; AsyncIterator[T]:\n    \"\"\"Stream LLM response with partial structured output (async).\n\n    Uses instructor's Partial for incremental field population.\n\n    Args:\n        messages: Conversation messages.\n        response_model: Pydantic model for response validation.\n        temperature: Override default temperature.\n        max_tokens: Override default max tokens.\n        **kwargs: Additional parameters passed to the API.\n\n    Yields:\n        Partial response objects with incrementally populated fields.\n\n    Raises:\n        RuntimeError: If no async client was provided.\n    \"\"\"\n    if self._async_client is None:\n        raise RuntimeError(\n            \"No async client configured. Provide async_client when creating the adapter.\"\n        )\n\n    try:\n        from instructor import Partial\n    except ImportError as e:\n        raise ImportError(\n            \"instructor is required for streaming. Install with: pip install agentecs[llm]\"\n        ) from e\n\n    openai_messages = _messages_to_openai(messages)\n\n    call_kwargs: dict[str, Any] = {\n        \"model\": kwargs.pop(\"model\", self._settings.model),\n        \"messages\": openai_messages,\n        \"response_model\": Partial[response_model],  # type: ignore[valid-type]\n        \"temperature\": temperature if temperature is not None else self._settings.temperature,\n        \"max_retries\": kwargs.pop(\"max_retries\", self._settings.max_retries),\n        \"stream\": True,\n    }\n\n    if max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = max_tokens\n    elif self._settings.max_tokens is not None:\n        call_kwargs[\"max_tokens\"] = self._settings.max_tokens\n\n    call_kwargs.update(kwargs)\n\n    async for partial_obj in await self._async_client.chat.completions.create(**call_kwargs):\n        yield partial_obj\n</code></pre>"},{"location":"api/adapters/#models_1","title":"Models","text":""},{"location":"api/adapters/#agentecs.adapters.Message","title":"<code>Message</code>  <code>dataclass</code>","text":"<p>A message in an LLM conversation.</p> <p>Attributes:</p> Name Type Description <code>role</code> <code>MessageRole</code> <p>Who sent the message.</p> <code>content</code> <code>str</code> <p>Message text content.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@dataclass(slots=True)\nclass Message:\n    \"\"\"A message in an LLM conversation.\n\n    Attributes:\n        role: Who sent the message.\n        content: Message text content.\n    \"\"\"\n\n    role: MessageRole\n    content: str\n\n    @classmethod\n    def system(cls, content: str) -&gt; Message:\n        \"\"\"Create a system message.\"\"\"\n        return cls(role=MessageRole.SYSTEM, content=content)\n\n    @classmethod\n    def user(cls, content: str) -&gt; Message:\n        \"\"\"Create a user message.\"\"\"\n        return cls(role=MessageRole.USER, content=content)\n\n    @classmethod\n    def assistant(cls, content: str) -&gt; Message:\n        \"\"\"Create an assistant message.\"\"\"\n        return cls(role=MessageRole.ASSISTANT, content=content)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.Message.system","title":"<code>system(content)</code>  <code>classmethod</code>","text":"<p>Create a system message.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@classmethod\ndef system(cls, content: str) -&gt; Message:\n    \"\"\"Create a system message.\"\"\"\n    return cls(role=MessageRole.SYSTEM, content=content)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.Message.user","title":"<code>user(content)</code>  <code>classmethod</code>","text":"<p>Create a user message.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@classmethod\ndef user(cls, content: str) -&gt; Message:\n    \"\"\"Create a user message.\"\"\"\n    return cls(role=MessageRole.USER, content=content)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.Message.assistant","title":"<code>assistant(content)</code>  <code>classmethod</code>","text":"<p>Create an assistant message.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>@classmethod\ndef assistant(cls, content: str) -&gt; Message:\n    \"\"\"Create an assistant message.\"\"\"\n    return cls(role=MessageRole.ASSISTANT, content=content)\n</code></pre>"},{"location":"api/adapters/#agentecs.adapters.MessageRole","title":"<code>MessageRole</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Role of a message in LLM conversation.</p> Source code in <code>src/agentecs/adapters/models.py</code> <pre><code>class MessageRole(Enum):\n    \"\"\"Role of a message in LLM conversation.\"\"\"\n\n    SYSTEM = \"developer\"\n    USER = \"user\"\n    ASSISTANT = \"assistant\"\n</code></pre>"},{"location":"api/adapters/#configuration","title":"Configuration","text":"<p>Type-safe configuration with Pydantic Settings.</p>"},{"location":"api/adapters/#agentecs.config.VectorStoreSettings","title":"<code>VectorStoreSettings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration for vector store adapters.</p> <p>Attributes:</p> Name Type Description <code>collection_name</code> <code>str</code> <p>Name of the collection/index.</p> <code>persist_directory</code> <code>str | None</code> <p>Path for persistent storage (None for ephemeral).</p> <code>distance_metric</code> <code>str</code> <p>Distance function for similarity (cosine, l2, ip).</p> Environment Variables <p>VECTORSTORE_COLLECTION_NAME VECTORSTORE_PERSIST_DIRECTORY VECTORSTORE_DISTANCE_METRIC</p> Source code in <code>src/agentecs/config/settings.py</code> <pre><code>class VectorStoreSettings(BaseSettings):\n    \"\"\"Configuration for vector store adapters.\n\n    Attributes:\n        collection_name: Name of the collection/index.\n        persist_directory: Path for persistent storage (None for ephemeral).\n        distance_metric: Distance function for similarity (cosine, l2, ip).\n\n    Environment Variables:\n        VECTORSTORE_COLLECTION_NAME\n        VECTORSTORE_PERSIST_DIRECTORY\n        VECTORSTORE_DISTANCE_METRIC\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"VECTORSTORE_\",\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        extra=\"ignore\",\n    )\n\n    collection_name: str = \"default\"\n    persist_directory: str | None = None\n    distance_metric: str = \"cosine\"\n</code></pre>"},{"location":"api/adapters/#agentecs.config.LLMSettings","title":"<code>LLMSettings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration for LLM adapters.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>str</code> <p>Model name/identifier.</p> <code>temperature</code> <code>float</code> <p>Sampling temperature (0.0-2.0).</p> <code>max_tokens</code> <code>int | None</code> <p>Maximum tokens in response.</p> <code>api_key</code> <code>str | None</code> <p>API key (prefer environment variable).</p> <code>base_url</code> <code>str | None</code> <p>Custom API base URL (for proxies/local models).</p> <code>timeout</code> <code>float</code> <p>Request timeout in seconds.</p> <code>max_retries</code> <code>int</code> <p>Number of retries on failure.</p> Environment Variables <p>LLM_MODEL LLM_TEMPERATURE LLM_MAX_TOKENS LLM_API_KEY (or OPENAI_API_KEY as fallback) LLM_BASE_URL LLM_TIMEOUT LLM_MAX_RETRIES</p> Source code in <code>src/agentecs/config/settings.py</code> <pre><code>class LLMSettings(BaseSettings):\n    \"\"\"Configuration for LLM adapters.\n\n    Attributes:\n        model: Model name/identifier.\n        temperature: Sampling temperature (0.0-2.0).\n        max_tokens: Maximum tokens in response.\n        api_key: API key (prefer environment variable).\n        base_url: Custom API base URL (for proxies/local models).\n        timeout: Request timeout in seconds.\n        max_retries: Number of retries on failure.\n\n    Environment Variables:\n        LLM_MODEL\n        LLM_TEMPERATURE\n        LLM_MAX_TOKENS\n        LLM_API_KEY (or OPENAI_API_KEY as fallback)\n        LLM_BASE_URL\n        LLM_TIMEOUT\n        LLM_MAX_RETRIES\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"LLM_\",\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        extra=\"ignore\",\n    )\n\n    model: str = \"gpt-4o-mini\"\n    temperature: float = 0.7\n    max_tokens: int | None = None\n    api_key: str | None = None\n    base_url: str | None = None\n    timeout: float = 60.0\n    max_retries: int = 3\n</code></pre>"},{"location":"api/adapters/#installation","title":"Installation","text":"<p>Install adapter dependencies:</p> <pre><code># Vector store adapter\npip install agentecs[vector]\n\n# LLM adapter\npip install agentecs[llm]\n\n# Configuration\npip install agentecs[config]\n\n# All adapters\npip install agentecs[all]\n</code></pre>"},{"location":"api/adapters/#usage-examples","title":"Usage Examples","text":""},{"location":"api/adapters/#vector-store","title":"Vector Store","text":"<pre><code>from pydantic import BaseModel\nfrom agentecs.adapters import ChromaAdapter, SearchMode\n\nclass Document(BaseModel):\n    title: str\n    content: str\n\n# Create adapter\nstore = ChromaAdapter.from_memory(\"docs\", Document)\n\n# Add documents\nstore.add(\"doc1\", embedding=[...], text=\"content\", data=Document(...))\n\n# Search\nresults = store.search(\n    query_embedding=[...],\n    mode=SearchMode.HYBRID,\n    limit=10\n)\n</code></pre>"},{"location":"api/adapters/#llm-client","title":"LLM Client","text":"<pre><code>from pydantic import BaseModel\nfrom agentecs.adapters import InstructorAdapter, Message\nfrom agentecs.config import LLMSettings\n\nclass Analysis(BaseModel):\n    sentiment: str\n    confidence: float\n\n# Create adapter\nadapter = InstructorAdapter.from_litellm(\n    settings=LLMSettings(model=\"anthropic/claude-3-5-sonnet-20241022\")\n)\n\n# Call with structured output\nmessages = [Message.user(\"Analyze: Great product!\")]\nresult = adapter.call(messages, response_model=Analysis)\n</code></pre>"},{"location":"api/core/","title":"Core API","text":"<p>Stateless, SOLID building blocks for the ECS framework.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The core API provides the fundamental abstractions for entities, components, systems, and queries. These are pure, stateless functionalities that can be composed to build complex agent behaviors.</p> <p>Key Principles: - Protocols over inheritance: Use runtime-checkable protocols for flexibility - Functional core: All operations are deterministic and stateless - Composability: Mix and match protocols to create rich component behaviors</p>"},{"location":"api/core/#component-module","title":"Component Module","text":"<p>Define components with optional operation protocols.</p>"},{"location":"api/core/#component-decorator","title":"Component Decorator","text":""},{"location":"api/core/#agentecs.core.component.component","title":"<code>component(cls)</code>","text":"<p>Register a dataclass or Pydantic model as a component type.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Dataclass or Pydantic model to register as component.</p> required <p>Returns:</p> Type Description <code>type</code> <p>The decorated class with component_meta attribute added.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If class is neither a dataclass nor Pydantic model.</p> Note <p>Apply @component AFTER @dataclass:</p> <p>@component ... @dataclass(slots=True) ... class MyComponent: ...     value: int</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def component(cls: type) -&gt; type:\n    \"\"\"Register a dataclass or Pydantic model as a component type.\n\n    Args:\n        cls: Dataclass or Pydantic model to register as component.\n\n    Returns:\n        The decorated class with __component_meta__ attribute added.\n\n    Raises:\n        TypeError: If class is neither a dataclass nor Pydantic model.\n\n    Note:\n        Apply @component AFTER @dataclass:\n\n        &gt;&gt;&gt; @component\n        ... @dataclass(slots=True)\n        ... class MyComponent:\n        ...     value: int\n    \"\"\"\n    if not (is_dataclass(cls) or _is_pydantic(cls)):\n        raise TypeError(\n            f\"Component {cls.__name__} must be a dataclass or Pydantic model. \"\n            f\"Did you forget @dataclass decorator?\"\n        )\n\n    meta = _registry.register(cls)\n    cls.__component_meta__ = meta  # type: ignore\n    return cls\n</code></pre>"},{"location":"api/core/#component-registry","title":"Component Registry","text":""},{"location":"api/core/#agentecs.core.component.ComponentRegistry","title":"<code>ComponentRegistry</code>","text":"<p>Process-local registry mapping component types to deterministic IDs.</p> <p>Maintains bidirectional mapping between component types and their IDs. Deterministic IDs ensure same code produces same IDs across nodes.</p>"},{"location":"api/core/#agentecs.core.component.ComponentRegistry--todo-figure-our-distributed-syncing-of-local-registrys-if-needed","title":"TODO: Figure our distributed syncing of local registrys if needed.","text":"Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>class ComponentRegistry:\n    \"\"\"Process-local registry mapping component types to deterministic IDs.\n\n    Maintains bidirectional mapping between component types and their IDs.\n    Deterministic IDs ensure same code produces same IDs across nodes.\n\n    # TODO: Figure our distributed syncing of local registrys if needed.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize empty component registry.\"\"\"\n        self._by_type: dict[type, ComponentMeta] = {}\n        self._by_id: dict[int, type] = {}\n\n    def register(self, cls: type) -&gt; ComponentMeta:\n        \"\"\"Register a component type and return its metadata.\n\n        Args:\n            cls: Component class to register.\n\n        Returns:\n            Component metadata including ID and type name.\n\n        Raises:\n            RuntimeError: If component ID collides with another registered type.\n        \"\"\"\n        if cls in self._by_type:\n            return self._by_type[cls]\n\n        component_id = _stable_component_id(cls)\n\n        if component_id in self._by_id:\n            existing = self._by_id[component_id]\n            raise RuntimeError(\n                f\"Component ID collision: {cls} and {existing} hash to {component_id}\"\n            )\n\n        meta = ComponentMeta(\n            component_id=component_id,\n            type_name=f\"{cls.__module__}.{cls.__qualname__}\",\n        )\n        self._by_type[cls] = meta\n        self._by_id[component_id] = cls\n        return meta\n\n    def get_meta(self, cls: type) -&gt; ComponentMeta | None:\n        \"\"\"Get metadata for a registered component type.\n\n        Args:\n            cls: Component class to look up.\n\n        Returns:\n            Component metadata if registered, None otherwise.\n        \"\"\"\n        return self._by_type.get(cls)\n\n    def get_type(self, component_id: int) -&gt; type | None:\n        \"\"\"Get component type by its ID.\n\n        Args:\n            component_id: Component ID to look up.\n\n        Returns:\n            Component class if found, None otherwise.\n        \"\"\"\n        return self._by_id.get(component_id)\n\n    def is_registered(self, cls: type) -&gt; bool:\n        \"\"\"Check if a type is registered as a component.\n\n        Args:\n            cls: Class to check.\n\n        Returns:\n            True if class is registered as component, False otherwise.\n        \"\"\"\n        return cls in self._by_type\n</code></pre>"},{"location":"api/core/#agentecs.core.component.ComponentRegistry.register","title":"<code>register(cls)</code>","text":"<p>Register a component type and return its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Component class to register.</p> required <p>Returns:</p> Type Description <code>ComponentMeta</code> <p>Component metadata including ID and type name.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If component ID collides with another registered type.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def register(self, cls: type) -&gt; ComponentMeta:\n    \"\"\"Register a component type and return its metadata.\n\n    Args:\n        cls: Component class to register.\n\n    Returns:\n        Component metadata including ID and type name.\n\n    Raises:\n        RuntimeError: If component ID collides with another registered type.\n    \"\"\"\n    if cls in self._by_type:\n        return self._by_type[cls]\n\n    component_id = _stable_component_id(cls)\n\n    if component_id in self._by_id:\n        existing = self._by_id[component_id]\n        raise RuntimeError(\n            f\"Component ID collision: {cls} and {existing} hash to {component_id}\"\n        )\n\n    meta = ComponentMeta(\n        component_id=component_id,\n        type_name=f\"{cls.__module__}.{cls.__qualname__}\",\n    )\n    self._by_type[cls] = meta\n    self._by_id[component_id] = cls\n    return meta\n</code></pre>"},{"location":"api/core/#agentecs.core.component.ComponentRegistry.get_meta","title":"<code>get_meta(cls)</code>","text":"<p>Get metadata for a registered component type.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Component class to look up.</p> required <p>Returns:</p> Type Description <code>ComponentMeta | None</code> <p>Component metadata if registered, None otherwise.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def get_meta(self, cls: type) -&gt; ComponentMeta | None:\n    \"\"\"Get metadata for a registered component type.\n\n    Args:\n        cls: Component class to look up.\n\n    Returns:\n        Component metadata if registered, None otherwise.\n    \"\"\"\n    return self._by_type.get(cls)\n</code></pre>"},{"location":"api/core/#agentecs.core.component.ComponentRegistry.get_type","title":"<code>get_type(component_id)</code>","text":"<p>Get component type by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>int</code> <p>Component ID to look up.</p> required <p>Returns:</p> Type Description <code>type | None</code> <p>Component class if found, None otherwise.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def get_type(self, component_id: int) -&gt; type | None:\n    \"\"\"Get component type by its ID.\n\n    Args:\n        component_id: Component ID to look up.\n\n    Returns:\n        Component class if found, None otherwise.\n    \"\"\"\n    return self._by_id.get(component_id)\n</code></pre>"},{"location":"api/core/#agentecs.core.component.ComponentRegistry.is_registered","title":"<code>is_registered(cls)</code>","text":"<p>Check if a type is registered as a component.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>Class to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if class is registered as component, False otherwise.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def is_registered(self, cls: type) -&gt; bool:\n    \"\"\"Check if a type is registered as a component.\n\n    Args:\n        cls: Class to check.\n\n    Returns:\n        True if class is registered as component, False otherwise.\n    \"\"\"\n    return cls in self._by_type\n</code></pre>"},{"location":"api/core/#agentecs.core.component.get_registry","title":"<code>get_registry()</code>","text":"<p>Access the global component registry.</p> <p>Returns:</p> Type Description <code>ComponentRegistry</code> <p>The process-local ComponentRegistry instance.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def get_registry() -&gt; ComponentRegistry:\n    \"\"\"Access the global component registry.\n\n    Returns:\n        The process-local ComponentRegistry instance.\n    \"\"\"\n    return _registry\n</code></pre>"},{"location":"api/core/#operation-protocols","title":"Operation Protocols","text":"<p>Components can optionally implement these protocols to enable advanced operations:</p>"},{"location":"api/core/#agentecs.core.component.Mergeable","title":"<code>Mergeable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Two instances \u2192 one combined instance.</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>@runtime_checkable\nclass Mergeable(Protocol):\n    \"\"\"Two instances \u2192 one combined instance.\"\"\"\n\n    def __merge__(self, other: Any) -&gt; Self: ...\n</code></pre>"},{"location":"api/core/#agentecs.core.component.Splittable","title":"<code>Splittable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>One instance \u2192 two instances (for agent splitting).</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>@runtime_checkable\nclass Splittable(Protocol):\n    \"\"\"One instance \u2192 two instances (for agent splitting).\"\"\"\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[Self, Self]: ...\n</code></pre>"},{"location":"api/core/#agentecs.core.component.Reducible","title":"<code>Reducible</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>N instances \u2192 one instance (for aggregation).</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>@runtime_checkable\nclass Reducible(Protocol):\n    \"\"\"N instances \u2192 one instance (for aggregation).\"\"\"\n\n    @classmethod\n    def __reduce_many__(cls, items: list[Self]) -&gt; Self: ...\n</code></pre>"},{"location":"api/core/#agentecs.core.component.Diffable","title":"<code>Diffable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Compute delta between instances (for sync/replication).</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>@runtime_checkable\nclass Diffable(Protocol):\n    \"\"\"Compute delta between instances (for sync/replication).\"\"\"\n\n    def __diff__(self, baseline: Self) -&gt; Self: ...\n    def __apply_diff__(self, diff: Self) -&gt; Self: ...\n</code></pre>"},{"location":"api/core/#agentecs.core.component.Interpolatable","title":"<code>Interpolatable</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Blend between instances (for continuous transitions).</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>@runtime_checkable\nclass Interpolatable(Protocol):\n    \"\"\"Blend between instances (for continuous transitions).\"\"\"\n\n    def __interpolate__(self, other: Self, t: float) -&gt; Self: ...\n</code></pre>"},{"location":"api/core/#strategy-enums","title":"Strategy Enums","text":""},{"location":"api/core/#agentecs.core.component.NonMergeableHandling","title":"<code>NonMergeableHandling</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Strategy for handling non-mergeable components during entity merge.</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>class NonMergeableHandling(Enum):\n    \"\"\"Strategy for handling non-mergeable components during entity merge.\"\"\"\n\n    ERROR = auto()  # Raise error if component not Mergeable\n    FIRST = auto()  # Keep component from first entity\n    SECOND = auto()  # Keep component from second entity\n    SKIP = auto()  # Don't include in merged entity\n\n    def get_strategy(self) -&gt; Callable[[T, T], T | None]:\n        \"\"\"Get the merge strategy function for this handling mode.\n\n        Returns:\n            Pure function implementing the merge strategy.\n        \"\"\"\n        # Late import to avoid circular dependency\n        from agentecs.core.component import operations\n\n        strategies = {\n            NonMergeableHandling.ERROR: operations.merge_error,\n            NonMergeableHandling.FIRST: operations.merge_take_first,\n            NonMergeableHandling.SECOND: operations.merge_take_second,\n            NonMergeableHandling.SKIP: operations.merge_skip,\n        }\n        return strategies[self]\n</code></pre>"},{"location":"api/core/#agentecs.core.component.NonMergeableHandling.get_strategy","title":"<code>get_strategy()</code>","text":"<p>Get the merge strategy function for this handling mode.</p> <p>Returns:</p> Type Description <code>Callable[[T, T], T | None]</code> <p>Pure function implementing the merge strategy.</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>def get_strategy(self) -&gt; Callable[[T, T], T | None]:\n    \"\"\"Get the merge strategy function for this handling mode.\n\n    Returns:\n        Pure function implementing the merge strategy.\n    \"\"\"\n    # Late import to avoid circular dependency\n    from agentecs.core.component import operations\n\n    strategies = {\n        NonMergeableHandling.ERROR: operations.merge_error,\n        NonMergeableHandling.FIRST: operations.merge_take_first,\n        NonMergeableHandling.SECOND: operations.merge_take_second,\n        NonMergeableHandling.SKIP: operations.merge_skip,\n    }\n    return strategies[self]\n</code></pre>"},{"location":"api/core/#agentecs.core.component.NonSplittableHandling","title":"<code>NonSplittableHandling</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Strategy for handling non-splittable components during entity split.</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>class NonSplittableHandling(Enum):\n    \"\"\"Strategy for handling non-splittable components during entity split.\"\"\"\n\n    ERROR = auto()  # Raise error if component not Splittable\n    FIRST = auto()  # Give component to first entity only\n    BOTH = auto()  # Clone component to both entities\n    SKIP = auto()  # Don't include in either entity\n\n    def get_strategy(self) -&gt; Callable[[T, float], tuple[T | None, T | None]]:\n        \"\"\"Get the split strategy function for this handling mode.\n\n        Returns:\n            Pure function implementing the split strategy.\n        \"\"\"\n        # Late import to avoid circular dependency\n        from agentecs.core.component import operations\n\n        strategies = {\n            NonSplittableHandling.ERROR: operations.split_error,\n            NonSplittableHandling.FIRST: operations.split_to_first,\n            NonSplittableHandling.BOTH: operations.split_to_both,\n            NonSplittableHandling.SKIP: operations.split_skip,\n        }\n        return strategies[self]\n</code></pre>"},{"location":"api/core/#agentecs.core.component.NonSplittableHandling.get_strategy","title":"<code>get_strategy()</code>","text":"<p>Get the split strategy function for this handling mode.</p> <p>Returns:</p> Type Description <code>Callable[[T, float], tuple[T | None, T | None]]</code> <p>Pure function implementing the split strategy.</p> Source code in <code>src/agentecs/core/component/models.py</code> <pre><code>def get_strategy(self) -&gt; Callable[[T, float], tuple[T | None, T | None]]:\n    \"\"\"Get the split strategy function for this handling mode.\n\n    Returns:\n        Pure function implementing the split strategy.\n    \"\"\"\n    # Late import to avoid circular dependency\n    from agentecs.core.component import operations\n\n    strategies = {\n        NonSplittableHandling.ERROR: operations.split_error,\n        NonSplittableHandling.FIRST: operations.split_to_first,\n        NonSplittableHandling.BOTH: operations.split_to_both,\n        NonSplittableHandling.SKIP: operations.split_skip,\n    }\n    return strategies[self]\n</code></pre>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#agentecs.core.component.merge_components","title":"<code>merge_components(a, b, strategy=None)</code>","text":"<p>Merge two components using custom strategy or component's merge method.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>T</code> <p>First component instance.</p> required <code>b</code> <code>T</code> <p>Second component instance (must be same type as a).</p> required <code>strategy</code> <code>Callable[[T, T], T] | None</code> <p>Optional custom merge function. If None, uses a.merge(b).</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Merged component instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If component doesn't implement Mergeable and no strategy provided.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def merge_components(a: T, b: T, strategy: Callable[[T, T], T] | None = None) -&gt; T:\n    \"\"\"Merge two components using custom strategy or component's __merge__ method.\n\n    Args:\n        a: First component instance.\n        b: Second component instance (must be same type as a).\n        strategy: Optional custom merge function. If None, uses a.__merge__(b).\n\n    Returns:\n        Merged component instance.\n\n    Raises:\n        TypeError: If component doesn't implement Mergeable and no strategy provided.\n    \"\"\"\n    if strategy:\n        return strategy(a, b)\n    if isinstance(a, Mergeable):\n        # a and b are same type T, and a is Mergeable, so b is too\n        # __merge__ uses Self type annotation, returns same type\n        return a.__merge__(b)  # type: ignore[return-value]\n    raise TypeError(f\"{type(a).__name__} is not Mergeable and no strategy provided\")\n</code></pre>"},{"location":"api/core/#agentecs.core.component.reduce_components","title":"<code>reduce_components(items, strategy=None)</code>","text":"<p>Reduce N components to one using strategy, reduce_many, or sequential merge.</p> <p>Tries in order: 1. Custom strategy function if provided 2. Class reduce_many method if component implements Reducible 3. Sequential pairwise merge using merge</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>List of component instances to reduce (must all be same type).</p> required <code>strategy</code> <code>Callable[[list[T]], T] | None</code> <p>Optional custom reduction function.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Single reduced component instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If items list is empty.</p> <code>TypeError</code> <p>If components don't implement Mergeable/Reducible and no strategy.</p> Source code in <code>src/agentecs/core/component/core.py</code> <pre><code>def reduce_components(items: list[T], strategy: Callable[[list[T]], T] | None = None) -&gt; T:\n    \"\"\"Reduce N components to one using strategy, __reduce_many__, or sequential merge.\n\n    Tries in order:\n    1. Custom strategy function if provided\n    2. Class __reduce_many__ method if component implements Reducible\n    3. Sequential pairwise merge using __merge__\n\n    Args:\n        items: List of component instances to reduce (must all be same type).\n        strategy: Optional custom reduction function.\n\n    Returns:\n        Single reduced component instance.\n\n    Raises:\n        ValueError: If items list is empty.\n        TypeError: If components don't implement Mergeable/Reducible and no strategy.\n    \"\"\"\n    if not items:\n        raise ValueError(\"Cannot reduce empty list\")\n    if len(items) == 1:\n        return items[0]\n\n    if strategy:\n        return strategy(items)\n\n    cls = type(items[0])\n    if isinstance(cls, type) and issubclass(cls, Reducible):\n        return cls.__reduce_many__(items)  # type: ignore\n\n    # Fallback to sequential merge\n    result = items[0]\n    for item in items[1:]:\n        result = merge_components(result, item)\n    return result\n</code></pre>"},{"location":"api/core/#identity-module","title":"Identity Module","text":"<p>Entity identification with generational indices.</p>"},{"location":"api/core/#agentecs.core.identity.EntityId","title":"<code>EntityId</code>  <code>dataclass</code>","text":"<p>Lightweight entity identifier with generation for safe handle reuse.</p> <p>Shard field enables future distributed scaling - each shard allocates indices independently within its range.</p> Source code in <code>src/agentecs/core/identity/models.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass EntityId:\n    \"\"\"Lightweight entity identifier with generation for safe handle reuse.\n\n    Shard field enables future distributed scaling - each shard allocates\n    indices independently within its range.\n    \"\"\"\n\n    shard: int = 0  # 0 = local, &gt;0 = remote shard\n    index: int = 0\n    generation: int = 0\n\n    def __hash__(self) -&gt; int:\n        return hash((self.shard, self.index, self.generation))\n\n    def is_local(self) -&gt; bool:\n        \"\"\"Check if this entity belongs to the local shard.\n\n        Returns:\n            True if entity is on shard 0 (local), False otherwise.\n        \"\"\"\n        return self.shard == 0\n</code></pre>"},{"location":"api/core/#agentecs.core.identity.EntityId.is_local","title":"<code>is_local()</code>","text":"<p>Check if this entity belongs to the local shard.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if entity is on shard 0 (local), False otherwise.</p> Source code in <code>src/agentecs/core/identity/models.py</code> <pre><code>def is_local(self) -&gt; bool:\n    \"\"\"Check if this entity belongs to the local shard.\n\n    Returns:\n        True if entity is on shard 0 (local), False otherwise.\n    \"\"\"\n    return self.shard == 0\n</code></pre>"},{"location":"api/core/#agentecs.core.identity.SystemEntity","title":"<code>SystemEntity</code>","text":"<p>Reserved entity IDs for singletons. Always on shard 0.</p> Source code in <code>src/agentecs/core/identity/models.py</code> <pre><code>class SystemEntity:\n    \"\"\"Reserved entity IDs for singletons. Always on shard 0.\"\"\"\n\n    WORLD = EntityId(shard=0, index=0, generation=0)\n    CLOCK = EntityId(shard=0, index=1, generation=0)\n    SCHEDULER = EntityId(shard=0, index=2, generation=0)\n\n    _RESERVED_COUNT = 1000  # First 1000 indices reserved\n</code></pre>"},{"location":"api/core/#query-module","title":"Query Module","text":"<p>Query builder for filtering entities by component types.</p>"},{"location":"api/core/#agentecs.core.query.Query","title":"<code>Query</code>  <code>dataclass</code>","text":"<p>Declarative query for access pattern declarations.</p> <p>Immutable - each method returns a new Query instance.</p> Source code in <code>src/agentecs/core/query/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Query:\n    \"\"\"Declarative query for access pattern declarations.\n\n    Immutable - each method returns a new Query instance.\n    \"\"\"\n\n    required: tuple[type, ...] = ()\n    excluded: tuple[type, ...] = ()\n\n    def __init__(self, *required: type):\n        object.__setattr__(self, \"required\", required)\n        object.__setattr__(self, \"excluded\", ())\n\n    def having(self, *types: type) -&gt; Query:\n        \"\"\"Entities must also have these component types.\"\"\"\n        new = Query(*self.required, *types)\n        object.__setattr__(new, \"excluded\", self.excluded)\n        return new\n\n    def excluding(self, *types: type) -&gt; Query:\n        \"\"\"Entities must NOT have these component types.\"\"\"\n        new = Query(*self.required)\n        object.__setattr__(new, \"excluded\", self.excluded + types)\n        return new\n\n    def __iter__(self) -&gt; Iterator[type]:\n        \"\"\"Allow Query to be used where tuple of types expected.\"\"\"\n        return iter(self.required)\n\n    def __contains__(self, item: type) -&gt; bool:\n        return item in self.required\n\n    def types(self) -&gt; frozenset[type]:\n        \"\"\"All types this query accesses (required only).\"\"\"\n        return frozenset(self.required)\n\n    def matches_archetype(self, has: frozenset[type]) -&gt; bool:\n        \"\"\"Check if an archetype (set of component types) matches this query.\"\"\"\n        return all(t in has for t in self.required) and all(t not in has for t in self.excluded)\n</code></pre>"},{"location":"api/core/#agentecs.core.query.Query.having","title":"<code>having(*types)</code>","text":"<p>Entities must also have these component types.</p> Source code in <code>src/agentecs/core/query/models.py</code> <pre><code>def having(self, *types: type) -&gt; Query:\n    \"\"\"Entities must also have these component types.\"\"\"\n    new = Query(*self.required, *types)\n    object.__setattr__(new, \"excluded\", self.excluded)\n    return new\n</code></pre>"},{"location":"api/core/#agentecs.core.query.Query.excluding","title":"<code>excluding(*types)</code>","text":"<p>Entities must NOT have these component types.</p> Source code in <code>src/agentecs/core/query/models.py</code> <pre><code>def excluding(self, *types: type) -&gt; Query:\n    \"\"\"Entities must NOT have these component types.\"\"\"\n    new = Query(*self.required)\n    object.__setattr__(new, \"excluded\", self.excluded + types)\n    return new\n</code></pre>"},{"location":"api/core/#agentecs.core.query.Query.types","title":"<code>types()</code>","text":"<p>All types this query accesses (required only).</p> Source code in <code>src/agentecs/core/query/models.py</code> <pre><code>def types(self) -&gt; frozenset[type]:\n    \"\"\"All types this query accesses (required only).\"\"\"\n    return frozenset(self.required)\n</code></pre>"},{"location":"api/core/#agentecs.core.query.Query.matches_archetype","title":"<code>matches_archetype(has)</code>","text":"<p>Check if an archetype (set of component types) matches this query.</p> Source code in <code>src/agentecs/core/query/models.py</code> <pre><code>def matches_archetype(self, has: frozenset[type]) -&gt; bool:\n    \"\"\"Check if an archetype (set of component types) matches this query.\"\"\"\n    return all(t in has for t in self.required) and all(t not in has for t in self.excluded)\n</code></pre>"},{"location":"api/core/#agentecs.core.query.AccessPattern","title":"<code>AccessPattern = AllAccess | TypeAccess | QueryAccess</code>  <code>module-attribute</code>","text":""},{"location":"api/core/#system-module","title":"System Module","text":"<p>Define systems with declared access patterns.</p>"},{"location":"api/core/#system-decorator","title":"System Decorator","text":""},{"location":"api/core/#agentecs.core.system.system","title":"<code>system = _SystemDecorator()</code>  <code>module-attribute</code>","text":""},{"location":"api/core/#system-metadata","title":"System Metadata","text":""},{"location":"api/core/#agentecs.core.system.SystemDescriptor","title":"<code>SystemDescriptor</code>  <code>dataclass</code>","text":"<p>Metadata about a registered system.</p> Source code in <code>src/agentecs/core/system/models.py</code> <pre><code>@dataclass(frozen=True)\nclass SystemDescriptor:\n    \"\"\"Metadata about a registered system.\"\"\"\n\n    name: str\n    run: Callable[..., Any]\n    reads: AccessPattern\n    writes: AccessPattern\n    mode: SystemMode\n    is_async: bool = False\n    frequency: float = 1.0\n    phase: str = \"update\"\n    runs_alone: bool = False  # If True, runs in its own execution group (dev mode)\n\n    def readable_types(self) -&gt; frozenset[type]:\n        \"\"\"Get all component types this system can read.\n\n        Returns:\n            Set of component types system has read or write access to.\n            Write access implies read access.\n        \"\"\"\n        r = self._extract_types(self.reads)\n        w = self._extract_types(self.writes)\n        return r | w  # Write implies read\n\n    def writable_types(self) -&gt; frozenset[type]:\n        \"\"\"Get all component types this system can write.\n\n        Returns:\n            Set of component types system has write access to.\n        \"\"\"\n        return self._extract_types(self.writes)\n\n    def _extract_types(self, pattern: AccessPattern) -&gt; frozenset[type]:\n        from agentecs.core.query.models import QueryAccess, TypeAccess\n\n        if isinstance(pattern, TypeAccess):\n            return pattern.types\n        if isinstance(pattern, QueryAccess):\n            return pattern.types()\n        return frozenset()  # Sentinel: empty means \"all\"\n\n    def is_dev_mode(self) -&gt; bool:\n        \"\"\"Check if system should run in isolation (dev mode).\n\n        Returns:\n            True if system should run alone in its own execution group.\n        \"\"\"\n        return self.runs_alone\n</code></pre>"},{"location":"api/core/#agentecs.core.system.SystemDescriptor.readable_types","title":"<code>readable_types()</code>","text":"<p>Get all component types this system can read.</p> <p>Returns:</p> Type Description <code>frozenset[type]</code> <p>Set of component types system has read or write access to.</p> <code>frozenset[type]</code> <p>Write access implies read access.</p> Source code in <code>src/agentecs/core/system/models.py</code> <pre><code>def readable_types(self) -&gt; frozenset[type]:\n    \"\"\"Get all component types this system can read.\n\n    Returns:\n        Set of component types system has read or write access to.\n        Write access implies read access.\n    \"\"\"\n    r = self._extract_types(self.reads)\n    w = self._extract_types(self.writes)\n    return r | w  # Write implies read\n</code></pre>"},{"location":"api/core/#agentecs.core.system.SystemDescriptor.writable_types","title":"<code>writable_types()</code>","text":"<p>Get all component types this system can write.</p> <p>Returns:</p> Type Description <code>frozenset[type]</code> <p>Set of component types system has write access to.</p> Source code in <code>src/agentecs/core/system/models.py</code> <pre><code>def writable_types(self) -&gt; frozenset[type]:\n    \"\"\"Get all component types this system can write.\n\n    Returns:\n        Set of component types system has write access to.\n    \"\"\"\n    return self._extract_types(self.writes)\n</code></pre>"},{"location":"api/core/#agentecs.core.system.SystemDescriptor.is_dev_mode","title":"<code>is_dev_mode()</code>","text":"<p>Check if system should run in isolation (dev mode).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if system should run alone in its own execution group.</p> Source code in <code>src/agentecs/core/system/models.py</code> <pre><code>def is_dev_mode(self) -&gt; bool:\n    \"\"\"Check if system should run in isolation (dev mode).\n\n    Returns:\n        True if system should run alone in its own execution group.\n    \"\"\"\n    return self.runs_alone\n</code></pre>"},{"location":"api/core/#agentecs.core.system.SystemMode","title":"<code>SystemMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Execution mode controlling access capabilities.</p> Source code in <code>src/agentecs/core/system/models.py</code> <pre><code>class SystemMode(Enum):\n    \"\"\"Execution mode controlling access capabilities.\"\"\"\n\n    INTERACTIVE = auto()  # Full ScopedAccess, writes during execution\n    PURE = auto()  # ReadOnlyAccess, must return all changes\n    READONLY = auto()  # ReadOnlyAccess, no writes allowed\n</code></pre>"},{"location":"api/scheduling/","title":"Scheduling API","text":"<p>Parallel execution engine with conflict detection.</p>"},{"location":"api/scheduling/#overview","title":"Overview","text":"<p>The scheduler automatically parallelizes system execution based on declared access patterns: - Conflict detection: Identifies write-write and read-write conflicts - Parallel execution: Groups non-conflicting systems - Query optimization: Leverages query disjointness for more parallelism - Async-first: Uses asyncio.gather for efficient concurrent execution</p> <p>Execution Modes: - Parallel: Default mode, maximizes throughput - Sequential: For debugging and deterministic execution</p>"},{"location":"api/scheduling/#simplescheduler","title":"SimpleScheduler","text":"<p>Parallel execution with conflict detection and query disjointness optimization.</p>"},{"location":"api/scheduling/#agentecs.scheduling.SimpleScheduler","title":"<code>SimpleScheduler</code>","text":"<p>Scheduler with parallel execution and configurable merge strategy.</p> <p>All systems execute in parallel (snapshot isolation), results merged at tick boundary using configured strategy.</p> <p>Execution grouping is delegated to an ExecutionGroupBuilder, enabling future extensions for dependency-based, frequency-based, or custom grouping strategies.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>SchedulerConfig | None</code> <p>Scheduler configuration (merge strategy, concurrency, retry).</p> <code>None</code> <code>group_builder</code> <code>ExecutionGroupBuilder | None</code> <p>Strategy for building execution groups from systems. Defaults to SingleGroupBuilder (all parallel, dev systems isolated).</p> <code>None</code> Source code in <code>src/agentecs/scheduling/scheduler.py</code> <pre><code>class SimpleScheduler:\n    \"\"\"Scheduler with parallel execution and configurable merge strategy.\n\n    All systems execute in parallel (snapshot isolation), results merged\n    at tick boundary using configured strategy.\n\n    Execution grouping is delegated to an ExecutionGroupBuilder, enabling\n    future extensions for dependency-based, frequency-based, or custom\n    grouping strategies.\n\n    Args:\n        config: Scheduler configuration (merge strategy, concurrency, retry).\n        group_builder: Strategy for building execution groups from systems.\n            Defaults to SingleGroupBuilder (all parallel, dev systems isolated).\n    \"\"\"\n\n    def __init__(\n        self,\n        config: SchedulerConfig | None = None,\n        group_builder: ExecutionGroupBuilder | None = None,\n    ) -&gt; None:\n        self._config = config or SchedulerConfig()\n        self._group_builder = group_builder or SingleGroupBuilder()\n        self._systems: list[SystemDescriptor] = []\n        self._execution_plan: ExecutionPlan | None = None\n\n    def register_system(self, descriptor: SystemDescriptor) -&gt; None:\n        \"\"\"Register system for execution. Invalidates cached execution plan.\"\"\"\n        self._systems.append(descriptor)\n        self._execution_plan = None\n\n    def build_execution_plan(self) -&gt; ExecutionPlan:\n        \"\"\"Build execution plan using the configured group builder.\"\"\"\n        return self._group_builder.build(self._systems)\n\n    async def tick_async(self, world: World) -&gt; None:\n        \"\"\"Execute all systems once, parallelizing where possible.\"\"\"\n        if self._execution_plan is None:\n            self._execution_plan = self.build_execution_plan()\n\n        for group in self._execution_plan:\n            await self._execute_group_async(world, group)\n\n    async def _execute_group_async(self, world: World, group: ExecutionGroup) -&gt; None:\n        \"\"\"Execute a group of systems in parallel, merge and apply results.\"\"\"\n        if not group.systems:\n            return\n\n        # Execute systems with concurrency limiting\n        results = await self._execute_systems_async(world, group.systems)\n\n        # Merge results using configured strategy\n        system_names = [s.name for s in group.systems]\n        merged = self._merge_results(results, system_names)\n\n        # Apply merged results\n        await world.apply_result_async(merged)\n\n    async def _execute_systems_async(\n        self, world: World, systems: list[SystemDescriptor]\n    ) -&gt; list[SystemResult]:\n        \"\"\"Execute systems with optional concurrency limiting and retry.\"\"\"\n        max_concurrent = self._config.max_concurrent\n\n        if max_concurrent is None:\n            # Unlimited concurrency\n            tasks = [self._execute_with_retry(world, system) for system in systems]\n            return list(await asyncio.gather(*tasks))\n        else:\n            # Semaphore-limited concurrency\n            semaphore = asyncio.Semaphore(max_concurrent)\n\n            async def limited_execute(system: SystemDescriptor) -&gt; SystemResult:\n                async with semaphore:\n                    return await self._execute_with_retry(world, system)\n\n            tasks = [limited_execute(system) for system in systems]\n            return list(await asyncio.gather(*tasks))\n\n    async def _execute_with_retry(self, world: World, system: SystemDescriptor) -&gt; SystemResult:\n        \"\"\"Execute system with retry policy.\n\n        Uses tenacity for retry logic when max_attempts &gt; 1.\n        Requires tenacity to be installed: pip install agentecs[retry]\n        \"\"\"\n        policy = self._config.retry_policy\n\n        if policy.max_attempts &lt;= 1:\n            return await world.execute_system_async(system)\n\n        if not TENACITY_AVAILABLE:\n            msg = \"Retry policy requires tenacity. Install with: pip install agentecs[retry]\"\n            raise ImportError(msg)\n\n        retryer = self._build_retryer(policy)\n\n        try:\n            async for attempt in retryer:\n                with attempt:\n                    return await world.execute_system_async(system)\n        except tenacity.RetryError as e:\n            if policy.on_exhausted == \"skip\":\n                return SystemResult()  # Empty result, skip this system\n            msg = f\"{system.name} failed after {policy.max_attempts} attempts\"\n            raise RuntimeError(msg) from e.last_attempt.exception()\n\n        return SystemResult()  # pragma: no cover\n\n    def _build_retryer(self, policy: RetryPolicy) -&gt; tenacity.AsyncRetrying:\n        \"\"\"Build a tenacity retryer from RetryPolicy configuration.\"\"\"\n        stop = tenacity.stop_after_attempt(policy.max_attempts)\n\n        wait: tenacity.wait.wait_base\n        if policy.backoff == \"exponential\":\n            wait = tenacity.wait_exponential(multiplier=policy.base_delay, min=policy.base_delay)\n        elif policy.backoff == \"linear\":\n            wait = tenacity.wait_incrementing(start=policy.base_delay, increment=policy.base_delay)\n        else:\n            wait = tenacity.wait_none()\n\n        return tenacity.AsyncRetrying(\n            stop=stop,\n            wait=wait,\n            reraise=False,\n        )\n\n    def _merge_results(self, results: list[SystemResult], system_names: list[str]) -&gt; SystemResult:\n        \"\"\"Merge results using configured strategy.\"\"\"\n        strategy = self._config.merge_strategy\n\n        if strategy == MergeStrategy.LAST_WRITER_WINS:\n            return merge_last_writer_wins(results, system_names)\n        elif strategy == MergeStrategy.MERGEABLE_FIRST:\n            return merge_mergeable_first(results, system_names)\n        elif strategy == MergeStrategy.ERROR:\n            return merge_error_on_conflict(results, system_names)\n        else:\n            raise ValueError(f\"Unknown merge strategy: {strategy}\")\n\n    def tick(self, world: World) -&gt; None:\n        \"\"\"Synchronous wrapper for tick_async.\"\"\"\n        asyncio.run(self.tick_async(world))\n\n    def get_execution_plan_info(self) -&gt; list[list[str]]:\n        \"\"\"Get human-readable execution plan (for debugging).\"\"\"\n        if self._execution_plan is None:\n            self._execution_plan = self.build_execution_plan()\n\n        return [[s.name for s in group.systems] for group in self._execution_plan]\n</code></pre>"},{"location":"api/scheduling/#agentecs.scheduling.SimpleScheduler.__init__","title":"<code>__init__(config=None, group_builder=None)</code>","text":"Source code in <code>src/agentecs/scheduling/scheduler.py</code> <pre><code>def __init__(\n    self,\n    config: SchedulerConfig | None = None,\n    group_builder: ExecutionGroupBuilder | None = None,\n) -&gt; None:\n    self._config = config or SchedulerConfig()\n    self._group_builder = group_builder or SingleGroupBuilder()\n    self._systems: list[SystemDescriptor] = []\n    self._execution_plan: ExecutionPlan | None = None\n</code></pre>"},{"location":"api/scheduling/#agentecs.scheduling.SimpleScheduler.tick","title":"<code>tick(world)</code>","text":"<p>Synchronous wrapper for tick_async.</p> Source code in <code>src/agentecs/scheduling/scheduler.py</code> <pre><code>def tick(self, world: World) -&gt; None:\n    \"\"\"Synchronous wrapper for tick_async.\"\"\"\n    asyncio.run(self.tick_async(world))\n</code></pre>"},{"location":"api/scheduling/#agentecs.scheduling.SimpleScheduler.tick_async","title":"<code>tick_async(world)</code>  <code>async</code>","text":"<p>Execute all systems once, parallelizing where possible.</p> Source code in <code>src/agentecs/scheduling/scheduler.py</code> <pre><code>async def tick_async(self, world: World) -&gt; None:\n    \"\"\"Execute all systems once, parallelizing where possible.\"\"\"\n    if self._execution_plan is None:\n        self._execution_plan = self.build_execution_plan()\n\n    for group in self._execution_plan:\n        await self._execute_group_async(world, group)\n</code></pre>"},{"location":"api/scheduling/#sequentialscheduler","title":"SequentialScheduler","text":"<p>Simple sequential execution for debugging.</p>"},{"location":"api/scheduling/#agentecs.scheduling.SequentialScheduler","title":"<code>SequentialScheduler()</code>","text":"<p>Create a scheduler that executes systems one at a time.</p> <p>Equivalent to SimpleScheduler with max_concurrent=1. Useful for debugging or when parallelism isn't needed.</p> Source code in <code>src/agentecs/scheduling/scheduler.py</code> <pre><code>def SequentialScheduler() -&gt; SimpleScheduler:  # noqa: N802\n    \"\"\"Create a scheduler that executes systems one at a time.\n\n    Equivalent to SimpleScheduler with max_concurrent=1.\n    Useful for debugging or when parallelism isn't needed.\n    \"\"\"\n    return SimpleScheduler(config=SchedulerConfig(max_concurrent=1))\n</code></pre>"},{"location":"api/scheduling/#conflict-detection","title":"Conflict Detection","text":"<p>How the scheduler determines if systems can run in parallel:</p>"},{"location":"api/scheduling/#write-write-conflicts","title":"Write-Write Conflicts","text":"<p>Two systems conflict if both write to the same component type.</p> <pre><code>@system(writes=(Position,))\ndef move_system(world): ...\n\n@system(writes=(Position,))  # Conflicts with move_system\ndef teleport_system(world): ...\n</code></pre>"},{"location":"api/scheduling/#read-write-conflicts","title":"Read-Write Conflicts","text":"<p>A system reading a component conflicts with one writing it.</p> <pre><code>@system(reads=(Position,), writes=(Velocity,))\ndef physics_system(world): ...\n\n@system(writes=(Position,))  # Conflicts with physics_system\ndef move_system(world): ...\n</code></pre>"},{"location":"api/scheduling/#query-disjointness","title":"Query Disjointness","text":"<p>Systems with provably disjoint queries can parallelize even with same component types.</p> <pre><code>@system(reads=Query().having(Agent, Active))\ndef active_agents(world): ...\n\n@system(reads=Query().having(Agent, Inactive))  # Disjoint!\ndef inactive_agents(world): ...\n</code></pre>"},{"location":"api/scheduling/#usage-example","title":"Usage Example","text":"<pre><code>from agentecs import World\nfrom agentecs.scheduling import SimpleScheduler, SchedulerConfig, MergeStrategy\n\n# Create world with scheduler\nworld = World(execution=SimpleScheduler())\n\n# Or with custom config\nworld = World(\n    execution=SimpleScheduler(\n        config=SchedulerConfig(\n            merge_strategy=MergeStrategy.LAST_WRITER_WINS,\n            max_concurrent=10\n        )\n    )\n)\n\n# Register systems\nworld.register_system(movement_system)\nworld.register_system(physics_system)\nworld.register_system(rendering_system)\n\n# Execute one tick (parallel)\nawait world.tick_async()\n\n# Or synchronous wrapper\nworld.tick()\n</code></pre>"},{"location":"api/scheduling/#future-enhancements","title":"Future Enhancements","text":"<p>Frequency-Based Execution (Planned): - Systems declare execution frequency (every N ticks) - Reduces unnecessary computation - Phase-based grouping</p> <p>Context-Aware Scheduling (Research): - Optimize for LLM cache hits - Group systems with overlapping context - Learn optimal schedules from execution patterns</p>"},{"location":"api/storage/","title":"Storage API","text":"<p>Pluggable storage backend for component data.</p>"},{"location":"api/storage/#overview","title":"Overview","text":"<p>AgentECS uses a protocol-based storage architecture, allowing different backend implementations: - LocalStorage: In-memory storage for single-process use - Future: Archetypal storage, distributed backends, persistent storage</p> <p>Key Features: - Protocol-based: Easy to swap implementations - Generational liveness: Safe entity recycling - Efficient queries: Filter entities by component types - Batch operations: Apply multiple updates atomically</p>"},{"location":"api/storage/#storage-protocol","title":"Storage Protocol","text":"<p>Interface that all storage backends must implement.</p>"},{"location":"api/storage/#agentecs.storage.Storage","title":"<code>Storage</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Abstract storage interface. Implementations handle actual data.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>class Storage(Protocol):\n    \"\"\"Abstract storage interface. Implementations handle actual data.\"\"\"\n\n    def create_entity(self) -&gt; EntityId:\n        \"\"\"Allocate new entity.\"\"\"\n        ...\n\n    def destroy_entity(self, entity: EntityId) -&gt; None:\n        \"\"\"Remove entity and all its components.\"\"\"\n        ...\n\n    def entity_exists(self, entity: EntityId) -&gt; bool:\n        \"\"\"Check if entity is alive.\"\"\"\n        ...\n\n    def all_entities(self) -&gt; Iterator[EntityId]:\n        \"\"\"Iterate all living entities.\"\"\"\n        ...\n\n    def get_component(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get component from entity.\"\"\"\n        ...\n\n    def set_component(self, entity: EntityId, component: Any) -&gt; None:\n        \"\"\"Set/update component on entity.\"\"\"\n        ...\n\n    def remove_component(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Remove component from entity. Returns True if existed.\"\"\"\n        ...\n\n    def has_component(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Check if entity has component.\"\"\"\n        ...\n\n    def get_component_types(self, entity: EntityId) -&gt; frozenset[type]:\n        \"\"\"Get all component types on entity.\"\"\"\n        ...\n\n    def query(\n        self,\n        *component_types: type,\n    ) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Find entities with all specified components.\"\"\"\n        ...\n\n    def query_single(self, component_type: type[T]) -&gt; Iterator[tuple[EntityId, T]]:\n        \"\"\"Optimized single-component query.\"\"\"\n        ...\n\n    def apply_updates(\n        self,\n        updates: dict[EntityId, dict[type, Any]],\n        inserts: dict[EntityId, list[Any]],\n        removes: dict[EntityId, list[type]],\n        destroys: list[EntityId],\n    ) -&gt; list[EntityId]:\n        \"\"\"Apply batched changes. Returns list of newly created entity IDs.\"\"\"\n        ...\n\n    def snapshot(self) -&gt; bytes:\n        \"\"\"Serialize entire storage state.\"\"\"\n        ...\n\n    def restore(self, data: bytes) -&gt; None:\n        \"\"\"Restore from snapshot.\"\"\"\n        ...\n\n    # Async variants for distributed/remote storage backends\n\n    async def get_component_async(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get component from entity (async variant for remote storage).\"\"\"\n        ...\n\n    def query_async(\n        self,\n        *component_types: type,\n    ) -&gt; AsyncIterator[tuple[EntityId, tuple[Any, ...]]] | Any:\n        \"\"\"Find entities with all specified components (async variant).\n\n        Returns an async iterator (typically via async generator implementation).\n        The `| Any` allows both async generators and awaitable-returning implementations.\n        \"\"\"\n        ...\n\n    async def apply_updates_async(\n        self,\n        updates: dict[EntityId, dict[type, Any]],\n        inserts: dict[EntityId, list[Any]],\n        removes: dict[EntityId, list[type]],\n        destroys: list[EntityId],\n    ) -&gt; list[EntityId]:\n        \"\"\"Apply batched changes asynchronously. Returns list of newly created entity IDs.\"\"\"\n        ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.create_entity","title":"<code>create_entity()</code>","text":"<p>Allocate new entity.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def create_entity(self) -&gt; EntityId:\n    \"\"\"Allocate new entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.destroy_entity","title":"<code>destroy_entity(entity)</code>","text":"<p>Remove entity and all its components.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def destroy_entity(self, entity: EntityId) -&gt; None:\n    \"\"\"Remove entity and all its components.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.entity_exists","title":"<code>entity_exists(entity)</code>","text":"<p>Check if entity is alive.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def entity_exists(self, entity: EntityId) -&gt; bool:\n    \"\"\"Check if entity is alive.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.get_component","title":"<code>get_component(entity, component_type)</code>","text":"<p>Get component from entity.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def get_component(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n    \"\"\"Get component from entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.set_component","title":"<code>set_component(entity, component)</code>","text":"<p>Set/update component on entity.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def set_component(self, entity: EntityId, component: Any) -&gt; None:\n    \"\"\"Set/update component on entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.remove_component","title":"<code>remove_component(entity, component_type)</code>","text":"<p>Remove component from entity. Returns True if existed.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def remove_component(self, entity: EntityId, component_type: type) -&gt; bool:\n    \"\"\"Remove component from entity. Returns True if existed.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.has_component","title":"<code>has_component(entity, component_type)</code>","text":"<p>Check if entity has component.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def has_component(self, entity: EntityId, component_type: type) -&gt; bool:\n    \"\"\"Check if entity has component.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.get_component_types","title":"<code>get_component_types(entity)</code>","text":"<p>Get all component types on entity.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def get_component_types(self, entity: EntityId) -&gt; frozenset[type]:\n    \"\"\"Get all component types on entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.query","title":"<code>query(*component_types)</code>","text":"<p>Find entities with all specified components.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def query(\n    self,\n    *component_types: type,\n) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n    \"\"\"Find entities with all specified components.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.apply_updates","title":"<code>apply_updates(updates, inserts, removes, destroys)</code>","text":"<p>Apply batched changes. Returns list of newly created entity IDs.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def apply_updates(\n    self,\n    updates: dict[EntityId, dict[type, Any]],\n    inserts: dict[EntityId, list[Any]],\n    removes: dict[EntityId, list[type]],\n    destroys: list[EntityId],\n) -&gt; list[EntityId]:\n    \"\"\"Apply batched changes. Returns list of newly created entity IDs.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.snapshot","title":"<code>snapshot()</code>","text":"<p>Serialize entire storage state.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def snapshot(self) -&gt; bytes:\n    \"\"\"Serialize entire storage state.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#agentecs.storage.Storage.restore","title":"<code>restore(data)</code>","text":"<p>Restore from snapshot.</p> Source code in <code>src/agentecs/storage/protocol.py</code> <pre><code>def restore(self, data: bytes) -&gt; None:\n    \"\"\"Restore from snapshot.\"\"\"\n    ...\n</code></pre>"},{"location":"api/storage/#localstorage","title":"LocalStorage","text":"<p>In-memory implementation for single-process use.</p>"},{"location":"api/storage/#agentecs.storage.LocalStorage","title":"<code>LocalStorage</code>","text":"<p>Simple in-memory storage using nested dicts.</p> Structure <p>_components[entity][component_type] = component_instance</p> <p>Not cache-efficient - for production, use archetypal storage.</p> <p>Parameters:</p> Name Type Description Default <code>shard</code> <code>int</code> <p>Shard number for this storage instance (default 0 for local).</p> <code>0</code> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>class LocalStorage:\n    \"\"\"Simple in-memory storage using nested dicts.\n\n    Structure:\n        _components[entity][component_type] = component_instance\n\n    Not cache-efficient - for production, use archetypal storage.\n\n    Args:\n        shard: Shard number for this storage instance (default 0 for local).\n    \"\"\"\n\n    def __init__(self, shard: int = 0):\n        \"\"\"Initialize local storage.\n\n        Args:\n            shard: Shard number for this storage instance (default 0).\n        \"\"\"\n        self._shard = shard\n        self._allocator = EntityAllocator(shard=shard)\n        self._components: dict[EntityId, dict[type, Any]] = {}\n\n    def create_entity(self) -&gt; EntityId:\n        \"\"\"Create a new entity and return its ID.\n\n        Returns:\n            Newly allocated EntityId.\n        \"\"\"\n        entity = self._allocator.allocate()\n        self._components[entity] = {}\n        return entity\n\n    def destroy_entity(self, entity: EntityId) -&gt; None:\n        \"\"\"Destroy an entity and remove all its components.\n\n        Args:\n            entity: Entity to destroy.\n        \"\"\"\n        if entity in self._components:\n            del self._components[entity]\n            self._allocator.deallocate(entity)\n\n    def entity_exists(self, entity: EntityId) -&gt; bool:\n        \"\"\"Check if an entity exists and is alive.\n\n        Args:\n            entity: Entity to check.\n\n        Returns:\n            True if entity exists and is alive, False otherwise.\n        \"\"\"\n        return entity in self._components and self._allocator.is_alive(entity)\n\n    def all_entities(self) -&gt; Iterator[EntityId]:\n        \"\"\"Iterate over all alive entities.\n\n        Yields:\n            EntityId for each alive entity.\n        \"\"\"\n        for entity in self._components:\n            if self._allocator.is_alive(entity):\n                yield entity\n\n    def get_component(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get a component from an entity.\n\n        Args:\n            entity: Entity to query.\n            component_type: Type of component to retrieve.\n\n        Returns:\n            Component instance or None if not present.\n        \"\"\"\n        if entity not in self._components:\n            return None\n        return self._components[entity].get(component_type)\n\n    def set_component(self, entity: EntityId, component: Any) -&gt; None:\n        \"\"\"Set or update a component on an entity.\n\n        Args:\n            entity: Entity to modify.\n            component: Component instance to set (type inferred).\n        \"\"\"\n        if entity not in self._components:\n            self._components[entity] = {}\n        self._components[entity][type(component)] = component\n\n    def remove_component(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Remove a component from an entity.\n\n        Args:\n            entity: Entity to modify.\n            component_type: Type of component to remove.\n\n        Returns:\n            True if component was removed, False if not present.\n        \"\"\"\n        if entity not in self._components:\n            return False\n        if component_type in self._components[entity]:\n            del self._components[entity][component_type]\n            return True\n        return False\n\n    def has_component(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Check if an entity has a specific component type.\n\n        Args:\n            entity: Entity to check.\n            component_type: Component type to look for.\n\n        Returns:\n            True if entity has component, False otherwise.\n        \"\"\"\n        if entity not in self._components:\n            return False\n        return component_type in self._components[entity]\n\n    def get_component_types(self, entity: EntityId) -&gt; frozenset[type]:\n        \"\"\"Get all component types present on an entity.\n\n        Args:\n            entity: Entity to query.\n\n        Returns:\n            Frozenset of component types on entity.\n        \"\"\"\n        if entity not in self._components:\n            return frozenset()\n        return frozenset(self._components[entity].keys())\n\n    def query(\n        self,\n        *component_types: type,\n    ) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Find entities with all specified components.\n\n        O(n) scan - archetypal storage would be O(matched).\n\n        Args:\n            *component_types: Component types to query for.\n\n        Yields:\n            Tuples of (entity, (component1, component2, ...)) for each match.\n        \"\"\"\n        type_set = set(component_types)\n        for entity, components in self._components.items():\n            if not self._allocator.is_alive(entity):\n                continue\n            if type_set.issubset(components.keys()):\n                result = tuple(components[t] for t in component_types)\n                yield entity, result\n\n    def query_single(self, component_type: type[T]) -&gt; Iterator[tuple[EntityId, T]]:\n        \"\"\"Optimized single-component query.\n\n        Args:\n            component_type: Component type to query for.\n\n        Yields:\n            Tuples of (entity, component) for each match.\n        \"\"\"\n        for entity, components in self._components.items():\n            if not self._allocator.is_alive(entity):\n                continue\n            if component_type in components:\n                yield entity, components[component_type]\n\n    def apply_updates(\n        self,\n        updates: dict[EntityId, dict[type, Any]],\n        inserts: dict[EntityId, list[Any]],\n        removes: dict[EntityId, list[type]],\n        destroys: list[EntityId],\n    ) -&gt; list[EntityId]:\n        \"\"\"Apply batched changes atomically.\n\n        Args:\n            updates: Entity -&gt; component type -&gt; component updates.\n            inserts: Entity -&gt; list of components to insert.\n            removes: Entity -&gt; list of component types to remove.\n            destroys: List of entities to destroy.\n\n        Returns:\n            List of newly created entity IDs (always empty for this implementation).\n        \"\"\"\n        new_entities: list[EntityId] = []\n\n        # Updates\n        for entity, components in updates.items():\n            for _, comp in components.items():\n                self.set_component(entity, comp)\n\n        # Inserts\n        for entity, component_list in inserts.items():\n            for comp in component_list:\n                self.set_component(entity, comp)\n\n        # Removes\n        for entity, types in removes.items():\n            for t in types:\n                self.remove_component(entity, t)\n\n        # Destroys\n        for entity in destroys:\n            self.destroy_entity(entity)\n\n        return new_entities\n\n    def snapshot(self) -&gt; bytes:\n        \"\"\"Pickle entire state for serialization.\n\n        Not efficient - use only for testing/prototyping, not production.\n\n        Returns:\n            Pickled bytes of storage state.\n        \"\"\"\n        return pickle.dumps(\n            {\n                \"shard\": self._shard,\n                \"components\": self._components,\n                \"allocator_next\": self._allocator._next_index,\n            }\n        )\n\n    def restore(self, data: bytes) -&gt; None:\n        \"\"\"Restore from pickle snapshot.\n\n        Args:\n            data: Pickled bytes from previous snapshot() call.\n        \"\"\"\n        state = pickle.loads(data)  # nosec B301 - Used only for local testing, not production\n        self._shard = state[\"shard\"]\n        self._components = state[\"components\"]\n        self._allocator._next_index = state[\"allocator_next\"]\n\n    # Async variants - for LocalStorage these just wrap sync methods\n    # Future distributed storage backends can implement truly async versions\n\n    async def get_component_async(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get component from entity (async wrapper for sync implementation).\n\n        Args:\n            entity: Entity to query.\n            component_type: Type of component to retrieve.\n\n        Returns:\n            Component instance or None if not present.\n        \"\"\"\n        return self.get_component(entity, component_type)\n\n    async def query_async(\n        self,\n        *component_types: type,\n    ) -&gt; AsyncIterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Find entities with all specified components (async wrapper).\n\n        Args:\n            *component_types: Component types to query for.\n\n        Yields:\n            Tuples of (entity, (component1, component2, ...)) for each match.\n        \"\"\"\n        for entity, components in self.query(*component_types):\n            # Test\n            yield entity, components\n\n    async def apply_updates_async(\n        self,\n        updates: dict[EntityId, dict[type, Any]],\n        inserts: dict[EntityId, list[Any]],\n        removes: dict[EntityId, list[type]],\n        destroys: list[EntityId],\n    ) -&gt; list[EntityId]:\n        \"\"\"Apply batched changes asynchronously (async wrapper).\n\n        Args:\n            updates: Entity -&gt; component type -&gt; component updates.\n            inserts: Entity -&gt; list of components to insert.\n            removes: Entity -&gt; list of component types to remove.\n            destroys: List of entities to destroy.\n\n        Returns:\n            List of newly created entity IDs (always empty for this implementation).\n        \"\"\"\n        return self.apply_updates(updates, inserts, removes, destroys)\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.__init__","title":"<code>__init__(shard=0)</code>","text":"<p>Initialize local storage.</p> <p>Parameters:</p> Name Type Description Default <code>shard</code> <code>int</code> <p>Shard number for this storage instance (default 0).</p> <code>0</code> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def __init__(self, shard: int = 0):\n    \"\"\"Initialize local storage.\n\n    Args:\n        shard: Shard number for this storage instance (default 0).\n    \"\"\"\n    self._shard = shard\n    self._allocator = EntityAllocator(shard=shard)\n    self._components: dict[EntityId, dict[type, Any]] = {}\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.create_entity","title":"<code>create_entity()</code>","text":"<p>Create a new entity and return its ID.</p> <p>Returns:</p> Type Description <code>EntityId</code> <p>Newly allocated EntityId.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def create_entity(self) -&gt; EntityId:\n    \"\"\"Create a new entity and return its ID.\n\n    Returns:\n        Newly allocated EntityId.\n    \"\"\"\n    entity = self._allocator.allocate()\n    self._components[entity] = {}\n    return entity\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.destroy_entity","title":"<code>destroy_entity(entity)</code>","text":"<p>Destroy an entity and remove all its components.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to destroy.</p> required Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def destroy_entity(self, entity: EntityId) -&gt; None:\n    \"\"\"Destroy an entity and remove all its components.\n\n    Args:\n        entity: Entity to destroy.\n    \"\"\"\n    if entity in self._components:\n        del self._components[entity]\n        self._allocator.deallocate(entity)\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.entity_exists","title":"<code>entity_exists(entity)</code>","text":"<p>Check if an entity exists and is alive.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if entity exists and is alive, False otherwise.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def entity_exists(self, entity: EntityId) -&gt; bool:\n    \"\"\"Check if an entity exists and is alive.\n\n    Args:\n        entity: Entity to check.\n\n    Returns:\n        True if entity exists and is alive, False otherwise.\n    \"\"\"\n    return entity in self._components and self._allocator.is_alive(entity)\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.get_component","title":"<code>get_component(entity, component_type)</code>","text":"<p>Get a component from an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to query.</p> required <code>component_type</code> <code>type[T]</code> <p>Type of component to retrieve.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Component instance or None if not present.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def get_component(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n    \"\"\"Get a component from an entity.\n\n    Args:\n        entity: Entity to query.\n        component_type: Type of component to retrieve.\n\n    Returns:\n        Component instance or None if not present.\n    \"\"\"\n    if entity not in self._components:\n        return None\n    return self._components[entity].get(component_type)\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.set_component","title":"<code>set_component(entity, component)</code>","text":"<p>Set or update a component on an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to modify.</p> required <code>component</code> <code>Any</code> <p>Component instance to set (type inferred).</p> required Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def set_component(self, entity: EntityId, component: Any) -&gt; None:\n    \"\"\"Set or update a component on an entity.\n\n    Args:\n        entity: Entity to modify.\n        component: Component instance to set (type inferred).\n    \"\"\"\n    if entity not in self._components:\n        self._components[entity] = {}\n    self._components[entity][type(component)] = component\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.remove_component","title":"<code>remove_component(entity, component_type)</code>","text":"<p>Remove a component from an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to modify.</p> required <code>component_type</code> <code>type</code> <p>Type of component to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if component was removed, False if not present.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def remove_component(self, entity: EntityId, component_type: type) -&gt; bool:\n    \"\"\"Remove a component from an entity.\n\n    Args:\n        entity: Entity to modify.\n        component_type: Type of component to remove.\n\n    Returns:\n        True if component was removed, False if not present.\n    \"\"\"\n    if entity not in self._components:\n        return False\n    if component_type in self._components[entity]:\n        del self._components[entity][component_type]\n        return True\n    return False\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.has_component","title":"<code>has_component(entity, component_type)</code>","text":"<p>Check if an entity has a specific component type.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to check.</p> required <code>component_type</code> <code>type</code> <p>Component type to look for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if entity has component, False otherwise.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def has_component(self, entity: EntityId, component_type: type) -&gt; bool:\n    \"\"\"Check if an entity has a specific component type.\n\n    Args:\n        entity: Entity to check.\n        component_type: Component type to look for.\n\n    Returns:\n        True if entity has component, False otherwise.\n    \"\"\"\n    if entity not in self._components:\n        return False\n    return component_type in self._components[entity]\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.get_component_types","title":"<code>get_component_types(entity)</code>","text":"<p>Get all component types present on an entity.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to query.</p> required <p>Returns:</p> Type Description <code>frozenset[type]</code> <p>Frozenset of component types on entity.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def get_component_types(self, entity: EntityId) -&gt; frozenset[type]:\n    \"\"\"Get all component types present on an entity.\n\n    Args:\n        entity: Entity to query.\n\n    Returns:\n        Frozenset of component types on entity.\n    \"\"\"\n    if entity not in self._components:\n        return frozenset()\n    return frozenset(self._components[entity].keys())\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.query","title":"<code>query(*component_types)</code>","text":"<p>Find entities with all specified components.</p> <p>O(n) scan - archetypal storage would be O(matched).</p> <p>Parameters:</p> Name Type Description Default <code>*component_types</code> <code>type</code> <p>Component types to query for.</p> <code>()</code> <p>Yields:</p> Type Description <code>tuple[EntityId, tuple[Any, ...]]</code> <p>Tuples of (entity, (component1, component2, ...)) for each match.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def query(\n    self,\n    *component_types: type,\n) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n    \"\"\"Find entities with all specified components.\n\n    O(n) scan - archetypal storage would be O(matched).\n\n    Args:\n        *component_types: Component types to query for.\n\n    Yields:\n        Tuples of (entity, (component1, component2, ...)) for each match.\n    \"\"\"\n    type_set = set(component_types)\n    for entity, components in self._components.items():\n        if not self._allocator.is_alive(entity):\n            continue\n        if type_set.issubset(components.keys()):\n            result = tuple(components[t] for t in component_types)\n            yield entity, result\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.apply_updates","title":"<code>apply_updates(updates, inserts, removes, destroys)</code>","text":"<p>Apply batched changes atomically.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>dict[EntityId, dict[type, Any]]</code> <p>Entity -&gt; component type -&gt; component updates.</p> required <code>inserts</code> <code>dict[EntityId, list[Any]]</code> <p>Entity -&gt; list of components to insert.</p> required <code>removes</code> <code>dict[EntityId, list[type]]</code> <p>Entity -&gt; list of component types to remove.</p> required <code>destroys</code> <code>list[EntityId]</code> <p>List of entities to destroy.</p> required <p>Returns:</p> Type Description <code>list[EntityId]</code> <p>List of newly created entity IDs (always empty for this implementation).</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def apply_updates(\n    self,\n    updates: dict[EntityId, dict[type, Any]],\n    inserts: dict[EntityId, list[Any]],\n    removes: dict[EntityId, list[type]],\n    destroys: list[EntityId],\n) -&gt; list[EntityId]:\n    \"\"\"Apply batched changes atomically.\n\n    Args:\n        updates: Entity -&gt; component type -&gt; component updates.\n        inserts: Entity -&gt; list of components to insert.\n        removes: Entity -&gt; list of component types to remove.\n        destroys: List of entities to destroy.\n\n    Returns:\n        List of newly created entity IDs (always empty for this implementation).\n    \"\"\"\n    new_entities: list[EntityId] = []\n\n    # Updates\n    for entity, components in updates.items():\n        for _, comp in components.items():\n            self.set_component(entity, comp)\n\n    # Inserts\n    for entity, component_list in inserts.items():\n        for comp in component_list:\n            self.set_component(entity, comp)\n\n    # Removes\n    for entity, types in removes.items():\n        for t in types:\n            self.remove_component(entity, t)\n\n    # Destroys\n    for entity in destroys:\n        self.destroy_entity(entity)\n\n    return new_entities\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.snapshot","title":"<code>snapshot()</code>","text":"<p>Pickle entire state for serialization.</p> <p>Not efficient - use only for testing/prototyping, not production.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Pickled bytes of storage state.</p> Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def snapshot(self) -&gt; bytes:\n    \"\"\"Pickle entire state for serialization.\n\n    Not efficient - use only for testing/prototyping, not production.\n\n    Returns:\n        Pickled bytes of storage state.\n    \"\"\"\n    return pickle.dumps(\n        {\n            \"shard\": self._shard,\n            \"components\": self._components,\n            \"allocator_next\": self._allocator._next_index,\n        }\n    )\n</code></pre>"},{"location":"api/storage/#agentecs.storage.LocalStorage.restore","title":"<code>restore(data)</code>","text":"<p>Restore from pickle snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>Pickled bytes from previous snapshot() call.</p> required Source code in <code>src/agentecs/storage/local.py</code> <pre><code>def restore(self, data: bytes) -&gt; None:\n    \"\"\"Restore from pickle snapshot.\n\n    Args:\n        data: Pickled bytes from previous snapshot() call.\n    \"\"\"\n    state = pickle.loads(data)  # nosec B301 - Used only for local testing, not production\n    self._shard = state[\"shard\"]\n    self._components = state[\"components\"]\n    self._allocator._next_index = state[\"allocator_next\"]\n</code></pre>"},{"location":"api/storage/#usage-example","title":"Usage Example","text":"<pre><code>from agentecs import World\nfrom agentecs.storage import LocalStorage\n\n# Use default LocalStorage\nworld = World()\n\n# Or provide custom storage\ncustom_storage = LocalStorage()\nworld = World(storage=custom_storage)\n</code></pre>"},{"location":"api/storage/#future-storage-backends","title":"Future Storage Backends","text":"<p>ArchetypalStorage (Planned): - Cache-friendly memory layout - O(matched) query performance - Optimized for iteration over large entity sets</p> <p>Distributed Storage (Research): - Cross-shard queries - Eventual consistency models - Network-aware optimization</p>"},{"location":"api/world/","title":"World API","text":"<p>Central coordination service for entity lifecycle and system execution.</p>"},{"location":"api/world/#overview","title":"Overview","text":"<p>The World is the main entry point for AgentECS. It coordinates: - Entity lifecycle: Spawn, destroy, and query entities - Component management: Get, set, and query components - System execution: Register and execute systems with proper isolation - Entity operations: Merge and split entities dynamically</p> <p>Key Features: - Snapshot isolation: Systems see their own writes immediately - Atomic updates: Changes applied at tick boundaries - Parallel execution: Non-conflicting systems run concurrently</p>"},{"location":"api/world/#world-class","title":"World Class","text":"<p>The central coordinator for your ECS world.</p>"},{"location":"api/world/#agentecs.world.World","title":"<code>World</code>","text":"<p>Central world state and system execution coordinator.</p> <p>Owns storage backend and execution strategy. Systems interact via ScopedAccess, not World directly. Execution strategy handles all system registration and orchestration.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>class World:\n    \"\"\"Central world state and system execution coordinator.\n\n    Owns storage backend and execution strategy. Systems interact via\n    ScopedAccess, not World directly. Execution strategy handles all\n    system registration and orchestration.\n    \"\"\"\n\n    def __init__(\n        self,\n        storage: Storage | None = None,\n        execution: ExecutionStrategy | None = None,\n    ):\n        self._storage = storage or LocalStorage()\n        # Import here to avoid circular dependency at module level\n        if execution is None:\n            from agentecs.scheduling import SimpleScheduler\n\n            execution = SimpleScheduler()\n        self._execution = execution\n        self._ensure_system_entities()\n\n    def _ensure_system_entities(self) -&gt; None:\n        \"\"\"Create reserved singleton entities if not present.\"\"\"\n        for entity in [SystemEntity.WORLD, SystemEntity.CLOCK]:\n            if not self._storage.entity_exists(entity):\n                # Bypass allocator\n                self._storage._components[entity] = {}  # type: ignore\n\n    def spawn(self, *components: Any) -&gt; EntityId:\n        \"\"\"Create entity with components. For use outside systems.\"\"\"\n        entity = self._storage.create_entity()\n        seen_types: set[type] = set()\n        for comp in components:\n            comp_type = type(comp)\n            if comp_type in seen_types:\n                warnings.warn(\n                    f\"spawn() received multiple components of type {comp_type.__name__}. \"\n                    f\"Only the last one will be kept.\",\n                    stacklevel=2,\n                )\n            seen_types.add(comp_type)\n            self._storage.set_component(entity, comp)\n        return entity\n\n    def destroy(self, entity: EntityId) -&gt; None:\n        \"\"\"Destroy entity. For use outside systems.\"\"\"\n        self._storage.destroy_entity(entity)\n\n    def get(self, entity: EntityId, component_type: type[ComponentT]) -&gt; ComponentT | None:\n        \"\"\"Get component copy. For use outside systems.\n\n        Returns a deep copy to prevent accidental mutation of world state.\n        Modifications must be written back via world.set() or world[entity, Type] = component.\n        \"\"\"\n        component = self._storage.get_component(entity, component_type)\n        return copy.deepcopy(component) if component is not None else None\n\n    def set(self, entity: EntityId, component: Any) -&gt; None:\n        \"\"\"Set component. For use outside systems.\"\"\"\n        self._storage.set_component(entity, component)\n\n    def singleton(self, component_type: type[ComponentT]) -&gt; ComponentT | None:\n        \"\"\"Get singleton component from WORLD entity.\"\"\"\n        return self.get(SystemEntity.WORLD, component_type)\n\n    def set_singleton(self, component: Any) -&gt; None:\n        \"\"\"Set singleton component on WORLD entity.\"\"\"\n        self.set(SystemEntity.WORLD, component)\n\n    def query(self, *component_types: type) -&gt; Iterator[tuple[EntityId, ...]]:\n        \"\"\"Query entities with specified component types. For use outside systems.\n\n        Returns iterator of tuples: (entity, component1, component2, ...)\n        where components are deep copies.\n\n        Example:\n            &gt;&gt;&gt; for entity, pos, vel in world.query(Position, Velocity):\n            ...     # Process entities with both Position and Velocity\n            ...     pass\n        \"\"\"\n        for entity, components in self._storage.query(*component_types):\n            # Return copies to prevent accidental mutation\n            copied_components = tuple(copy.deepcopy(c) for c in components)\n            yield (entity, *copied_components)\n\n    def merge_entities(\n        self,\n        entity1: EntityId,\n        entity2: EntityId,\n        on_non_mergeable: NonMergeableHandling = NonMergeableHandling.FIRST,\n    ) -&gt; EntityId:\n        \"\"\"Merge two entities into a single new entity.\n\n        Components implementing Mergeable protocol are merged via __merge__.\n        Non-mergeable components are handled according to the strategy.\n\n        Args:\n            entity1: First entity to merge.\n            entity2: Second entity to merge.\n            on_non_mergeable: How to handle non-mergeable components.\n                - ERROR: Raise TypeError if any component not Mergeable\n                - FIRST: Keep component from entity1\n                - SECOND: Keep component from entity2\n                - SKIP: Don't include in merged entity\n\n        Returns:\n            EntityId of the newly created merged entity.\n\n        Raises:\n            ValueError: If either entity doesn't exist.\n            TypeError: If on_non_mergeable=ERROR and component not Mergeable.\n\n        Example:\n            &gt;&gt;&gt; merged = world.merge_entities(agent1, agent2)\n            &gt;&gt;&gt; # agent1 and agent2 are destroyed\n            &gt;&gt;&gt; # merged has combined components\n        \"\"\"\n        if not self._storage.entity_exists(entity1):\n            raise ValueError(f\"Entity {entity1} does not exist\")\n        if not self._storage.entity_exists(entity2):\n            raise ValueError(f\"Entity {entity2} does not exist\")\n\n        # Collect all component types from both entities\n        types1 = self._storage.get_component_types(entity1)\n        types2 = self._storage.get_component_types(entity2)\n        all_types = types1 | types2\n\n        # Merge components using strategy functions\n        merged_components: list[Any] = []\n        non_mergeable_strategy = on_non_mergeable.get_strategy()\n\n        for comp_type in all_types:\n            comp1 = self._storage.get_component(entity1, comp_type)\n            comp2 = self._storage.get_component(entity2, comp_type)\n\n            if comp1 is not None and comp2 is not None:\n                # Both have this component - merge using protocol or strategy\n                if isinstance(comp1, Mergeable):\n                    from agentecs.core.component.operations import merge_using_protocol\n\n                    merged = merge_using_protocol(comp1, comp2)\n                else:\n                    merged = non_mergeable_strategy(comp1, comp2)\n\n                if merged is not None:\n                    merged_components.append(merged)\n\n            elif comp1 is not None:\n                # Only entity1 has this component\n                merged_components.append(comp1)\n            elif comp2 is not None:\n                # Only entity2 has this component\n                merged_components.append(comp2)\n\n        # Create merged entity and destroy originals\n        merged_entity = self.spawn(*merged_components)\n        self.destroy(entity1)\n        self.destroy(entity2)\n\n        return merged_entity\n\n    def split_entity(\n        self,\n        entity: EntityId,\n        ratio: float = 0.5,\n        on_non_splittable: NonSplittableHandling = NonSplittableHandling.BOTH,\n    ) -&gt; tuple[EntityId, EntityId]:\n        \"\"\"Split one entity into two new entities.\n\n        Components implementing Splittable protocol are split via __split__.\n        Non-splittable components are handled according to the strategy.\n\n        Args:\n            entity: Entity to split.\n            ratio: Split ratio for Splittable components (0.0 to 1.0).\n                   0.5 means equal split.\n            on_non_splittable: How to handle non-splittable components.\n                - ERROR: Raise TypeError if any component not Splittable\n                - FIRST: Give component to first entity only\n                - BOTH: Clone component to both entities (default)\n                - SKIP: Don't include in either entity\n\n        Returns:\n            Tuple of (first_entity, second_entity) IDs.\n\n        Raises:\n            ValueError: If entity doesn't exist or ratio out of range.\n            TypeError: If on_non_splittable=ERROR and component not Splittable.\n\n        Example:\n            &gt;&gt;&gt; left, right = world.split_entity(agent, ratio=0.5)\n            &gt;&gt;&gt; # original agent is destroyed\n            &gt;&gt;&gt; # left and right have split components\n        \"\"\"\n        if not self._storage.entity_exists(entity):\n            raise ValueError(f\"Entity {entity} does not exist\")\n        if not 0.0 &lt;= ratio &lt;= 1.0:\n            raise ValueError(f\"Ratio must be between 0.0 and 1.0, got {ratio}\")\n\n        # Collect all components and split using strategy functions\n        comp_types = self._storage.get_component_types(entity)\n        non_splittable_strategy = on_non_splittable.get_strategy()\n\n        first_components: list[Any] = []\n        second_components: list[Any] = []\n\n        for comp_type in comp_types:\n            comp = self._storage.get_component(entity, comp_type)\n            if comp is None:\n                continue\n\n            # Split using protocol or strategy\n            if isinstance(comp, Splittable):\n                from agentecs.core.component.operations import split_using_protocol\n\n                left, right = split_using_protocol(comp, ratio)\n            else:\n                left, right = non_splittable_strategy(comp, ratio)\n\n            if left is not None:\n                first_components.append(left)\n            if right is not None:\n                second_components.append(right)\n\n        # Create new entities and destroy original\n        first_entity = self.spawn(*first_components)\n        second_entity = self.spawn(*second_components)\n        self.destroy(entity)\n\n        return first_entity, second_entity\n\n    def _get_component(\n        self, entity: EntityId, component_type: type[ComponentT]\n    ) -&gt; ComponentT | None:\n        return self._storage.get_component(entity, component_type)\n\n    def _has_component(self, entity: EntityId, component_type: type) -&gt; bool:\n        return self._storage.has_component(entity, component_type)\n\n    def _query_components(\n        self,\n        *component_types: type,\n    ) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        return self._storage.query(*component_types)\n\n    def _all_entities(self) -&gt; Iterator[EntityId]:\n        return self._storage.all_entities()\n\n    def _get_component_types(self, entity: EntityId) -&gt; frozenset[type]:\n        return self._storage.get_component_types(entity)\n\n    # Async variants for internal use (enables async ScopedAccess methods)\n\n    async def _get_component_async(\n        self, entity: EntityId, component_type: type[ComponentT]\n    ) -&gt; ComponentT | None:\n        return await self._storage.get_component_async(entity, component_type)\n\n    async def _query_components_async(\n        self,\n        *component_types: type,\n    ) -&gt; AsyncIterator[tuple[EntityId, tuple[Any, ...]]]:\n        async for x in self._storage.query_async(*component_types):\n            yield x\n\n    def register_system(self, descriptor: SystemDescriptor) -&gt; None:\n        \"\"\"Register system for execution.\n\n        Delegates to the injected execution strategy.\n        \"\"\"\n        self._execution.register_system(descriptor)\n\n    def register_systems(self, *descriptors: SystemDescriptor) -&gt; None:\n        \"\"\"Register multiple systems.\"\"\"\n        for d in descriptors:\n            self.register_system(d)\n\n    async def execute_system_async(self, descriptor: SystemDescriptor) -&gt; SystemResult:\n        \"\"\"Execute single system asynchronously, returning collected changes.\n\n        Handles both sync and async systems automatically based on descriptor.is_async.\n        \"\"\"\n        result_buffer = SystemResult()\n        access = ScopedAccess(world=self, descriptor=descriptor, buffer=result_buffer)\n\n        # Run system (async if needed)\n        if descriptor.is_async:\n            returned = await descriptor.run(access)\n        else:\n            returned = descriptor.run(access)\n\n        # Merge return value into buffer\n        if returned is not None:\n            normalized = normalize_result(returned)\n            result_buffer.merge(normalized)\n\n        validate_result_access(\n            result_buffer,\n            descriptor.writable_types(),\n            descriptor.name,\n        )\n\n        return result_buffer\n\n    def execute_system(self, descriptor: SystemDescriptor) -&gt; SystemResult:\n        \"\"\"Execute single system synchronously (wrapper for execute_system_async).\n\n        For backward compatibility. Prefer execute_system_async() in async contexts.\n        \"\"\"\n        return asyncio.run(self.execute_system_async(descriptor))\n\n    async def apply_result_async(self, result: SystemResult) -&gt; list[EntityId]:\n        \"\"\"Apply system result to world state asynchronously.\n\n        For distributed storage, this enables parallel updates across shards.\n        For local storage, this is a simple async wrapper.\n\n        Args:\n            result: System execution result containing all changes.\n\n        Returns:\n            List of newly created entity IDs from spawns.\n        \"\"\"\n        # Handle spawns first to get real entity IDs\n        new_entities: list[EntityId] = []\n        for components in result.spawns:\n            entity = self._storage.create_entity()\n            new_entities.append(entity)\n            for comp in components:\n                self._storage.set_component(entity, comp)\n\n        # Apply updates asynchronously\n        await self._storage.apply_updates_async(\n            updates=result.updates,\n            inserts=result.inserts,\n            removes=result.removes,\n            destroys=result.destroys,\n        )\n\n        return new_entities\n\n    def apply_result(self, result: SystemResult) -&gt; list[EntityId]:\n        \"\"\"Apply system result to world state (sync wrapper for backward compatibility).\n\n        Prefer apply_result_async() in async contexts.\n\n        Args:\n            result: System execution result containing all changes.\n\n        Returns:\n            List of newly created entity IDs from spawns.\n        \"\"\"\n        return asyncio.run(self.apply_result_async(result))\n\n    async def tick_async(self) -&gt; None:\n        \"\"\"Execute all registered systems once asynchronously.\n\n        Delegates to the injected execution strategy, which handles\n        parallelization, conflict detection, or other orchestration logic.\n        \"\"\"\n        await self._execution.tick_async(self)\n\n    def tick(self) -&gt; None:\n        \"\"\"Execute all registered systems once synchronously (wrapper for tick_async).\n\n        For backward compatibility and simple scripts. Prefer tick_async() in async contexts.\n        \"\"\"\n        asyncio.run(self.tick_async())\n\n    def snapshot(self) -&gt; bytes:\n        \"\"\"Serialize world state.\"\"\"\n        return self._storage.snapshot()\n\n    def restore(self, data: bytes) -&gt; None:\n        \"\"\"Restore from snapshot.\"\"\"\n        self._storage.restore(data)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.__init__","title":"<code>__init__(storage=None, execution=None)</code>","text":"Source code in <code>src/agentecs/world/world.py</code> <pre><code>def __init__(\n    self,\n    storage: Storage | None = None,\n    execution: ExecutionStrategy | None = None,\n):\n    self._storage = storage or LocalStorage()\n    # Import here to avoid circular dependency at module level\n    if execution is None:\n        from agentecs.scheduling import SimpleScheduler\n\n        execution = SimpleScheduler()\n    self._execution = execution\n    self._ensure_system_entities()\n</code></pre>"},{"location":"api/world/#agentecs.world.World.spawn","title":"<code>spawn(*components)</code>","text":"<p>Create entity with components. For use outside systems.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def spawn(self, *components: Any) -&gt; EntityId:\n    \"\"\"Create entity with components. For use outside systems.\"\"\"\n    entity = self._storage.create_entity()\n    seen_types: set[type] = set()\n    for comp in components:\n        comp_type = type(comp)\n        if comp_type in seen_types:\n            warnings.warn(\n                f\"spawn() received multiple components of type {comp_type.__name__}. \"\n                f\"Only the last one will be kept.\",\n                stacklevel=2,\n            )\n        seen_types.add(comp_type)\n        self._storage.set_component(entity, comp)\n    return entity\n</code></pre>"},{"location":"api/world/#agentecs.world.World.destroy","title":"<code>destroy(entity)</code>","text":"<p>Destroy entity. For use outside systems.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def destroy(self, entity: EntityId) -&gt; None:\n    \"\"\"Destroy entity. For use outside systems.\"\"\"\n    self._storage.destroy_entity(entity)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.get","title":"<code>get(entity, component_type)</code>","text":"<p>Get component copy. For use outside systems.</p> <p>Returns a deep copy to prevent accidental mutation of world state. Modifications must be written back via world.set() or world[entity, Type] = component.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def get(self, entity: EntityId, component_type: type[ComponentT]) -&gt; ComponentT | None:\n    \"\"\"Get component copy. For use outside systems.\n\n    Returns a deep copy to prevent accidental mutation of world state.\n    Modifications must be written back via world.set() or world[entity, Type] = component.\n    \"\"\"\n    component = self._storage.get_component(entity, component_type)\n    return copy.deepcopy(component) if component is not None else None\n</code></pre>"},{"location":"api/world/#agentecs.world.World.set","title":"<code>set(entity, component)</code>","text":"<p>Set component. For use outside systems.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def set(self, entity: EntityId, component: Any) -&gt; None:\n    \"\"\"Set component. For use outside systems.\"\"\"\n    self._storage.set_component(entity, component)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.singleton","title":"<code>singleton(component_type)</code>","text":"<p>Get singleton component from WORLD entity.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def singleton(self, component_type: type[ComponentT]) -&gt; ComponentT | None:\n    \"\"\"Get singleton component from WORLD entity.\"\"\"\n    return self.get(SystemEntity.WORLD, component_type)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.set_singleton","title":"<code>set_singleton(component)</code>","text":"<p>Set singleton component on WORLD entity.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def set_singleton(self, component: Any) -&gt; None:\n    \"\"\"Set singleton component on WORLD entity.\"\"\"\n    self.set(SystemEntity.WORLD, component)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.merge_entities","title":"<code>merge_entities(entity1, entity2, on_non_mergeable=NonMergeableHandling.FIRST)</code>","text":"<p>Merge two entities into a single new entity.</p> <p>Components implementing Mergeable protocol are merged via merge. Non-mergeable components are handled according to the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>entity1</code> <code>EntityId</code> <p>First entity to merge.</p> required <code>entity2</code> <code>EntityId</code> <p>Second entity to merge.</p> required <code>on_non_mergeable</code> <code>NonMergeableHandling</code> <p>How to handle non-mergeable components. - ERROR: Raise TypeError if any component not Mergeable - FIRST: Keep component from entity1 - SECOND: Keep component from entity2 - SKIP: Don't include in merged entity</p> <code>FIRST</code> <p>Returns:</p> Type Description <code>EntityId</code> <p>EntityId of the newly created merged entity.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either entity doesn't exist.</p> <code>TypeError</code> <p>If on_non_mergeable=ERROR and component not Mergeable.</p> Example <p>merged = world.merge_entities(agent1, agent2)</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def merge_entities(\n    self,\n    entity1: EntityId,\n    entity2: EntityId,\n    on_non_mergeable: NonMergeableHandling = NonMergeableHandling.FIRST,\n) -&gt; EntityId:\n    \"\"\"Merge two entities into a single new entity.\n\n    Components implementing Mergeable protocol are merged via __merge__.\n    Non-mergeable components are handled according to the strategy.\n\n    Args:\n        entity1: First entity to merge.\n        entity2: Second entity to merge.\n        on_non_mergeable: How to handle non-mergeable components.\n            - ERROR: Raise TypeError if any component not Mergeable\n            - FIRST: Keep component from entity1\n            - SECOND: Keep component from entity2\n            - SKIP: Don't include in merged entity\n\n    Returns:\n        EntityId of the newly created merged entity.\n\n    Raises:\n        ValueError: If either entity doesn't exist.\n        TypeError: If on_non_mergeable=ERROR and component not Mergeable.\n\n    Example:\n        &gt;&gt;&gt; merged = world.merge_entities(agent1, agent2)\n        &gt;&gt;&gt; # agent1 and agent2 are destroyed\n        &gt;&gt;&gt; # merged has combined components\n    \"\"\"\n    if not self._storage.entity_exists(entity1):\n        raise ValueError(f\"Entity {entity1} does not exist\")\n    if not self._storage.entity_exists(entity2):\n        raise ValueError(f\"Entity {entity2} does not exist\")\n\n    # Collect all component types from both entities\n    types1 = self._storage.get_component_types(entity1)\n    types2 = self._storage.get_component_types(entity2)\n    all_types = types1 | types2\n\n    # Merge components using strategy functions\n    merged_components: list[Any] = []\n    non_mergeable_strategy = on_non_mergeable.get_strategy()\n\n    for comp_type in all_types:\n        comp1 = self._storage.get_component(entity1, comp_type)\n        comp2 = self._storage.get_component(entity2, comp_type)\n\n        if comp1 is not None and comp2 is not None:\n            # Both have this component - merge using protocol or strategy\n            if isinstance(comp1, Mergeable):\n                from agentecs.core.component.operations import merge_using_protocol\n\n                merged = merge_using_protocol(comp1, comp2)\n            else:\n                merged = non_mergeable_strategy(comp1, comp2)\n\n            if merged is not None:\n                merged_components.append(merged)\n\n        elif comp1 is not None:\n            # Only entity1 has this component\n            merged_components.append(comp1)\n        elif comp2 is not None:\n            # Only entity2 has this component\n            merged_components.append(comp2)\n\n    # Create merged entity and destroy originals\n    merged_entity = self.spawn(*merged_components)\n    self.destroy(entity1)\n    self.destroy(entity2)\n\n    return merged_entity\n</code></pre>"},{"location":"api/world/#agentecs.world.World.merge_entities--agent1-and-agent2-are-destroyed","title":"agent1 and agent2 are destroyed","text":""},{"location":"api/world/#agentecs.world.World.merge_entities--merged-has-combined-components","title":"merged has combined components","text":""},{"location":"api/world/#agentecs.world.World.split_entity","title":"<code>split_entity(entity, ratio=0.5, on_non_splittable=NonSplittableHandling.BOTH)</code>","text":"<p>Split one entity into two new entities.</p> <p>Components implementing Splittable protocol are split via split. Non-splittable components are handled according to the strategy.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity to split.</p> required <code>ratio</code> <code>float</code> <p>Split ratio for Splittable components (0.0 to 1.0).    0.5 means equal split.</p> <code>0.5</code> <code>on_non_splittable</code> <code>NonSplittableHandling</code> <p>How to handle non-splittable components. - ERROR: Raise TypeError if any component not Splittable - FIRST: Give component to first entity only - BOTH: Clone component to both entities (default) - SKIP: Don't include in either entity</p> <code>BOTH</code> <p>Returns:</p> Type Description <code>tuple[EntityId, EntityId]</code> <p>Tuple of (first_entity, second_entity) IDs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If entity doesn't exist or ratio out of range.</p> <code>TypeError</code> <p>If on_non_splittable=ERROR and component not Splittable.</p> Example <p>left, right = world.split_entity(agent, ratio=0.5)</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def split_entity(\n    self,\n    entity: EntityId,\n    ratio: float = 0.5,\n    on_non_splittable: NonSplittableHandling = NonSplittableHandling.BOTH,\n) -&gt; tuple[EntityId, EntityId]:\n    \"\"\"Split one entity into two new entities.\n\n    Components implementing Splittable protocol are split via __split__.\n    Non-splittable components are handled according to the strategy.\n\n    Args:\n        entity: Entity to split.\n        ratio: Split ratio for Splittable components (0.0 to 1.0).\n               0.5 means equal split.\n        on_non_splittable: How to handle non-splittable components.\n            - ERROR: Raise TypeError if any component not Splittable\n            - FIRST: Give component to first entity only\n            - BOTH: Clone component to both entities (default)\n            - SKIP: Don't include in either entity\n\n    Returns:\n        Tuple of (first_entity, second_entity) IDs.\n\n    Raises:\n        ValueError: If entity doesn't exist or ratio out of range.\n        TypeError: If on_non_splittable=ERROR and component not Splittable.\n\n    Example:\n        &gt;&gt;&gt; left, right = world.split_entity(agent, ratio=0.5)\n        &gt;&gt;&gt; # original agent is destroyed\n        &gt;&gt;&gt; # left and right have split components\n    \"\"\"\n    if not self._storage.entity_exists(entity):\n        raise ValueError(f\"Entity {entity} does not exist\")\n    if not 0.0 &lt;= ratio &lt;= 1.0:\n        raise ValueError(f\"Ratio must be between 0.0 and 1.0, got {ratio}\")\n\n    # Collect all components and split using strategy functions\n    comp_types = self._storage.get_component_types(entity)\n    non_splittable_strategy = on_non_splittable.get_strategy()\n\n    first_components: list[Any] = []\n    second_components: list[Any] = []\n\n    for comp_type in comp_types:\n        comp = self._storage.get_component(entity, comp_type)\n        if comp is None:\n            continue\n\n        # Split using protocol or strategy\n        if isinstance(comp, Splittable):\n            from agentecs.core.component.operations import split_using_protocol\n\n            left, right = split_using_protocol(comp, ratio)\n        else:\n            left, right = non_splittable_strategy(comp, ratio)\n\n        if left is not None:\n            first_components.append(left)\n        if right is not None:\n            second_components.append(right)\n\n    # Create new entities and destroy original\n    first_entity = self.spawn(*first_components)\n    second_entity = self.spawn(*second_components)\n    self.destroy(entity)\n\n    return first_entity, second_entity\n</code></pre>"},{"location":"api/world/#agentecs.world.World.split_entity--original-agent-is-destroyed","title":"original agent is destroyed","text":""},{"location":"api/world/#agentecs.world.World.split_entity--left-and-right-have-split-components","title":"left and right have split components","text":""},{"location":"api/world/#agentecs.world.World.register_system","title":"<code>register_system(descriptor)</code>","text":"<p>Register system for execution.</p> <p>Delegates to the injected execution strategy.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def register_system(self, descriptor: SystemDescriptor) -&gt; None:\n    \"\"\"Register system for execution.\n\n    Delegates to the injected execution strategy.\n    \"\"\"\n    self._execution.register_system(descriptor)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.execute_system","title":"<code>execute_system(descriptor)</code>","text":"<p>Execute single system synchronously (wrapper for execute_system_async).</p> <p>For backward compatibility. Prefer execute_system_async() in async contexts.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def execute_system(self, descriptor: SystemDescriptor) -&gt; SystemResult:\n    \"\"\"Execute single system synchronously (wrapper for execute_system_async).\n\n    For backward compatibility. Prefer execute_system_async() in async contexts.\n    \"\"\"\n    return asyncio.run(self.execute_system_async(descriptor))\n</code></pre>"},{"location":"api/world/#agentecs.world.World.execute_system_async","title":"<code>execute_system_async(descriptor)</code>  <code>async</code>","text":"<p>Execute single system asynchronously, returning collected changes.</p> <p>Handles both sync and async systems automatically based on descriptor.is_async.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>async def execute_system_async(self, descriptor: SystemDescriptor) -&gt; SystemResult:\n    \"\"\"Execute single system asynchronously, returning collected changes.\n\n    Handles both sync and async systems automatically based on descriptor.is_async.\n    \"\"\"\n    result_buffer = SystemResult()\n    access = ScopedAccess(world=self, descriptor=descriptor, buffer=result_buffer)\n\n    # Run system (async if needed)\n    if descriptor.is_async:\n        returned = await descriptor.run(access)\n    else:\n        returned = descriptor.run(access)\n\n    # Merge return value into buffer\n    if returned is not None:\n        normalized = normalize_result(returned)\n        result_buffer.merge(normalized)\n\n    validate_result_access(\n        result_buffer,\n        descriptor.writable_types(),\n        descriptor.name,\n    )\n\n    return result_buffer\n</code></pre>"},{"location":"api/world/#agentecs.world.World.tick","title":"<code>tick()</code>","text":"<p>Execute all registered systems once synchronously (wrapper for tick_async).</p> <p>For backward compatibility and simple scripts. Prefer tick_async() in async contexts.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def tick(self) -&gt; None:\n    \"\"\"Execute all registered systems once synchronously (wrapper for tick_async).\n\n    For backward compatibility and simple scripts. Prefer tick_async() in async contexts.\n    \"\"\"\n    asyncio.run(self.tick_async())\n</code></pre>"},{"location":"api/world/#agentecs.world.World.tick_async","title":"<code>tick_async()</code>  <code>async</code>","text":"<p>Execute all registered systems once asynchronously.</p> <p>Delegates to the injected execution strategy, which handles parallelization, conflict detection, or other orchestration logic.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>async def tick_async(self) -&gt; None:\n    \"\"\"Execute all registered systems once asynchronously.\n\n    Delegates to the injected execution strategy, which handles\n    parallelization, conflict detection, or other orchestration logic.\n    \"\"\"\n    await self._execution.tick_async(self)\n</code></pre>"},{"location":"api/world/#agentecs.world.World.apply_result","title":"<code>apply_result(result)</code>","text":"<p>Apply system result to world state (sync wrapper for backward compatibility).</p> <p>Prefer apply_result_async() in async contexts.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>SystemResult</code> <p>System execution result containing all changes.</p> required <p>Returns:</p> Type Description <code>list[EntityId]</code> <p>List of newly created entity IDs from spawns.</p> Source code in <code>src/agentecs/world/world.py</code> <pre><code>def apply_result(self, result: SystemResult) -&gt; list[EntityId]:\n    \"\"\"Apply system result to world state (sync wrapper for backward compatibility).\n\n    Prefer apply_result_async() in async contexts.\n\n    Args:\n        result: System execution result containing all changes.\n\n    Returns:\n        List of newly created entity IDs from spawns.\n    \"\"\"\n    return asyncio.run(self.apply_result_async(result))\n</code></pre>"},{"location":"api/world/#access-control","title":"Access Control","text":"<p>Systems access the world through scoped interfaces that enforce access patterns.</p>"},{"location":"api/world/#scopedaccess","title":"ScopedAccess","text":""},{"location":"api/world/#agentecs.world.ScopedAccess","title":"<code>ScopedAccess</code>","text":"<p>World access scoped to system's declared patterns with magic methods.</p> <p>Provides snapshot isolation: sees own writes immediately, others' writes only after tick boundary.</p> <p>Gotcha: For PURE mode systems, write methods raise AccessViolation.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>class ScopedAccess:\n    \"\"\"World access scoped to system's declared patterns with magic methods.\n\n    Provides snapshot isolation: sees own writes immediately, others' writes\n    only after tick boundary.\n\n    Gotcha: For PURE mode systems, write methods raise AccessViolation.\n    \"\"\"\n\n    def __init__(\n        self,\n        world: Any,  # World instance (avoid circular import)\n        descriptor: SystemDescriptor,\n        buffer: SystemResult,\n    ):\n        self._world = world\n        self._descriptor = descriptor\n        self._buffer = buffer\n        self._readable = descriptor.readable_types()\n        self._writable = descriptor.writable_types()\n        self._sync_runner: SyncRunner = SyncRunner.get()\n\n    def _check_readable(self, *types: type) -&gt; None:\n        if self._descriptor.is_dev_mode():\n            return\n        for t in types:\n            if self._readable and t not in self._readable:\n                raise AccessViolationError(\n                    f\"System '{self._descriptor.name}' cannot read {t.__name__}: \"\n                    f\"not in readable types\"\n                )\n\n    def _check_writable(self, t: type) -&gt; None:\n        from ..core.system import SystemMode\n\n        if self._descriptor.is_dev_mode():\n            return\n\n        # READONLY mode cannot write at all\n        if self._descriptor.mode == SystemMode.READONLY:\n            raise AccessViolationError(\n                f\"System '{self._descriptor.name}' is READONLY and cannot write {t.__name__}\"\n            )\n\n        if not self._writable:  # Empty = dev mode\n            return\n        if t not in self._writable:\n            if t in self._readable:\n                raise AccessViolationError(\n                    f\"System '{self._descriptor.name}' cannot write {t.__name__}: \"\n                    f\"declared as read-only\"\n                )\n            raise AccessViolationError(\n                f\"System '{self._descriptor.name}' cannot write {t.__name__}: not in writable types\"\n            )\n\n    def __getitem__(self, key: tuple[EntityId, type[T]]) -&gt; T:\n        \"\"\"Get directly the component T for the entity in key.\n\n        Example: world[entity, Position] -&gt; Position\n        \"\"\"\n        entity, component_type = key\n        return self.get(entity, component_type)\n\n    def __setitem__(self, key: tuple[EntityId, type], value: Any) -&gt; None:\n        \"\"\"Set directly the component T for entity in key.\n\n        Example: world[entity, Position] = new_pos.\n        \"\"\"\n        entity, _ = key\n        self.update(entity, value)\n\n    def __delitem__(self, key: tuple[EntityId, type]) -&gt; None:\n        \"\"\"Delete component.\n\n        Example: Del world[entity, Position].\n        \"\"\"\n        entity, component_type = key\n        self.remove(entity, component_type)\n\n    def __contains__(self, key: tuple[EntityId, type]) -&gt; bool:\n        \"\"\"(entity, Position) in world.\"\"\"\n        entity, component_type = key\n        return self.has(entity, component_type)\n\n    def __call__(self, *component_types: type) -&gt; QueryResult:\n        \"\"\"Create a query for component types.\n\n        Example: world(Position, Velocity) -&gt; QueryResult iterable.\n        \"\"\"\n        self._check_readable(*component_types)\n        return QueryResult(self, component_types)\n\n    def __iter__(self) -&gt; Iterator[EntityId]:\n        \"\"\"Iterate over entities.\n\n        Example: For entity in world: ...\n        \"\"\"\n        return self.entities()\n\n    def get(self, entity: EntityId, component_type: type[T]) -&gt; T:\n        \"\"\"Get component copy (from buffer or storage).\n\n        ALWAYS returns a copy to prevent accidental mutation of world state.\n        Modifications must be written back explicitly via world[entity, Type] = component.\n        \"\"\"\n        self._check_readable(component_type)\n\n        if entity in self._buffer.updates and component_type in self._buffer.updates[entity]:\n            return cast(T, copy.deepcopy(self._buffer.updates[entity][component_type]))\n\n        if component := self._world._get_component(entity, component_type):\n            return cast(T, copy.deepcopy(component))\n        else:\n            raise KeyError(f\"Entity {entity} has no component {component_type.__name__}\")\n\n    def has(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Check if entity has a specific component type.\"\"\"\n        self._check_readable(component_type)\n\n        if entity in self._buffer.inserts and any(\n            type(c) is component_type for c in self._buffer.inserts[entity]\n        ):\n            return True\n        if entity in self._buffer.removes and component_type in self._buffer.removes[entity]:\n            return False\n\n        return cast(bool, self._world._has_component(entity, component_type))\n\n    def _query_raw(\n        self,\n        *component_types: type,\n    ) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Internal query returning (entity, (comp1, comp2, ...)).\"\"\"\n        return self._sync_runner.iterate(self._query_raw_async(*component_types))\n\n    def query(\n        self,\n        *component_types: type,\n    ) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Query entities with components. Returns (entity, (comp1, comp2, ...)).\"\"\"\n        self._check_readable(*component_types)\n        return self._query_raw(*component_types)\n\n    async def _query_raw_async(\n        self,\n        *component_types: type,\n    ) -&gt; AsyncIterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Internal async query returning (entity, (comp1, comp2, ...)).\"\"\"\n        yielded_entities = set()\n\n        async for entity, components in self._world._query_components_async(*component_types):\n            should_skip = False\n            for comp_type in component_types:\n                if entity in self._buffer.removes and comp_type in self._buffer.removes[entity]:\n                    should_skip = True\n                    break\n            if should_skip:\n                continue\n\n            result = []\n            for comp_type, comp in zip(component_types, components, strict=False):\n                if entity in self._buffer.updates and comp_type in self._buffer.updates[entity]:\n                    result.append(self._buffer.updates[entity][comp_type])\n                else:\n                    result.append(comp)\n            yielded_entities.add(entity)\n            yield entity, tuple(result)\n\n        for entity in list(self._buffer.updates.keys()) + list(self._buffer.inserts.keys()):\n            if entity in yielded_entities:\n                continue\n\n            has_all = True\n            result = []\n            for comp_type in component_types:\n                comp = None\n\n                if entity in self._buffer.updates and comp_type in self._buffer.updates[entity]:\n                    comp = self._buffer.updates[entity][comp_type]\n                elif entity in self._buffer.inserts:\n                    for inserted_comp in self._buffer.inserts[entity]:\n                        if type(inserted_comp) is comp_type:\n                            comp = inserted_comp\n                            break\n                if comp is None:\n                    comp = await self._world._get_component_async(entity, comp_type)\n\n                if entity in self._buffer.removes and comp_type in self._buffer.removes[entity]:\n                    has_all = False\n                    break\n\n                if comp is None:\n                    has_all = False\n                    break\n\n                result.append(comp)\n\n            if has_all:\n                yielded_entities.add(entity)\n                yield entity, tuple(result)\n\n    async def query_async(\n        self,\n        *component_types: type,\n    ) -&gt; AsyncIterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Query entities with components asynchronously. Returns (entity, (comp1, comp2, ...)).\n\n        Async variant for use in async systems. For distributed storage, this enables\n        efficient remote queries.\n\n        Args:\n            *component_types: Component types to query for.\n\n        Yields:\n            Tuples of (entity, (component1, component2, ...)) for each match.\n        \"\"\"\n        self._check_readable(*component_types)\n        async for entity, components in self._query_raw_async(*component_types):\n            yield entity, components\n\n    async def get_async(self, entity: EntityId, component_type: type[T]) -&gt; T:\n        \"\"\"Get component asynchronously, checking buffer first (read own writes).\n\n        Async variant for use in async systems. For distributed storage, this enables\n        efficient remote component fetches.\n\n        Args:\n            entity: Entity to query.\n            component_type: Type of component to retrieve.\n\n        Returns:\n            Component instance.\n\n        Raises:\n            KeyError: If entity does not have the component.\n        \"\"\"\n        self._check_readable(component_type)\n\n        if entity in self._buffer.updates and component_type in self._buffer.updates[entity]:\n            return cast(T, copy.deepcopy(self._buffer.updates[entity][component_type]))\n\n        if component := await self._world._get_component_async(entity, component_type):\n            return cast(T, copy.deepcopy(component))\n        else:\n            raise KeyError(f\"Entity {entity} has no component {component_type.__name__}\")\n\n    def singleton(self, component_type: type[T]) -&gt; T:\n        \"\"\"Get singleton component from WORLD entity.\"\"\"\n        result = self.get(SystemEntity.WORLD, component_type)\n        if result is None:\n            raise KeyError(f\"No singleton {component_type.__name__} registered\")\n        return result\n\n    def entities(self) -&gt; Iterator[EntityId]:\n        \"\"\"Iterate all entities.\"\"\"\n        return cast(Iterator[EntityId], self._world._all_entities())\n\n    def entity(self, entity_id: EntityId) -&gt; EntityHandle:\n        \"\"\"Get handle for convenient single-entity operations.\"\"\"\n        return EntityHandle(self, entity_id)\n\n    def update(self, entity: EntityId, component: Any) -&gt; None:\n        \"\"\"Update/set component on entity.\"\"\"\n        comp_type = type(component)\n        self._check_writable(comp_type)\n\n        if entity not in self._buffer.updates:\n            self._buffer.updates[entity] = {}\n        self._buffer.updates[entity][comp_type] = component\n\n    def update_singleton(self, component: Any) -&gt; None:\n        \"\"\"Update/set singleton component on WORLD entity.\"\"\"\n        comp_type = type(component)\n        self._check_writable(comp_type)\n\n        if SystemEntity.WORLD not in self._buffer.updates:\n            self._buffer.updates[SystemEntity.WORLD] = {}\n        self._buffer.updates[SystemEntity.WORLD][comp_type] = component\n\n    def insert(self, entity: EntityId, component: Any) -&gt; None:\n        \"\"\"Add new component to entity.\"\"\"\n        comp_type = type(component)\n        self._check_writable(comp_type)\n\n        if entity not in self._buffer.inserts:\n            self._buffer.inserts[entity] = []\n        self._buffer.inserts[entity].append(component)\n\n    def remove(self, entity: EntityId, component_type: type) -&gt; None:\n        \"\"\"Remove component from entity.\"\"\"\n        self._check_writable(component_type)\n\n        if entity not in self._buffer.removes:\n            self._buffer.removes[entity] = []\n        self._buffer.removes[entity].append(component_type)\n\n    def spawn(self, *components: Any) -&gt; EntityId:\n        \"\"\"Spawn new entity with components. Returns provisional ID.\"\"\"\n        seen_types: set[type] = set()\n        for comp in components:\n            comp_type = type(comp)\n            self._check_writable(comp_type)\n            if comp_type in seen_types:\n                warnings.warn(\n                    f\"spawn() received multiple components of type {comp_type.__name__}. \"\n                    f\"Only the last one will be kept.\",\n                    stacklevel=2,\n                )\n            seen_types.add(comp_type)\n\n        self._buffer.spawns.append(components)\n        # Return provisional ID - actual ID assigned at apply time\n        return EntityId(shard=0, index=-len(self._buffer.spawns), generation=0)\n\n    def destroy(self, entity: EntityId) -&gt; None:\n        \"\"\"Queue entity for destruction.\"\"\"\n        self._buffer.destroys.append(entity)\n\n    def insert_shared(self, entities: Iterable[EntityId], component: Any) -&gt; None:\n        \"\"\"Multiple entities share same component instance.\n\n        Gotcha: Modifications affect all sharing entities.\n        \"\"\"\n        comp_type = type(component)\n        self._check_writable(comp_type)\n        # TODO: Implement via SharedComponentRef in storage\n        raise NotImplementedError(\"Shared components not yet implemented\")\n\n    def merge_entities(\n        self,\n        entities: list[EntityId],\n        into: EntityId | None = None,\n    ) -&gt; EntityId:\n        \"\"\"Merge multiple entities into one using Mergeable components.\"\"\"\n        # TODO: Implement using merge_components from component.py\n        raise NotImplementedError(\"Entity merging not yet implemented\")\n\n    def split_entity(\n        self,\n        entity: EntityId,\n        ratio: float = 0.5,\n    ) -&gt; tuple[EntityId, EntityId]:\n        \"\"\"Split entity into two using Splittable components.\"\"\"\n        # TODO: Implement using component protocols\n        raise NotImplementedError(\"Entity splitting not yet implemented\")\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get directly the component T for the entity in key.</p> <p>Example: world[entity, Position] -&gt; Position</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def __getitem__(self, key: tuple[EntityId, type[T]]) -&gt; T:\n    \"\"\"Get directly the component T for the entity in key.\n\n    Example: world[entity, Position] -&gt; Position\n    \"\"\"\n    entity, component_type = key\n    return self.get(entity, component_type)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set directly the component T for entity in key.</p> <p>Example: world[entity, Position] = new_pos.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def __setitem__(self, key: tuple[EntityId, type], value: Any) -&gt; None:\n    \"\"\"Set directly the component T for entity in key.\n\n    Example: world[entity, Position] = new_pos.\n    \"\"\"\n    entity, _ = key\n    self.update(entity, value)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete component.</p> <p>Example: Del world[entity, Position].</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def __delitem__(self, key: tuple[EntityId, type]) -&gt; None:\n    \"\"\"Delete component.\n\n    Example: Del world[entity, Position].\n    \"\"\"\n    entity, component_type = key\n    self.remove(entity, component_type)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.__contains__","title":"<code>__contains__(key)</code>","text":"<p>(entity, Position) in world.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def __contains__(self, key: tuple[EntityId, type]) -&gt; bool:\n    \"\"\"(entity, Position) in world.\"\"\"\n    entity, component_type = key\n    return self.has(entity, component_type)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.__call__","title":"<code>__call__(*component_types)</code>","text":"<p>Create a query for component types.</p> <p>Example: world(Position, Velocity) -&gt; QueryResult iterable.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def __call__(self, *component_types: type) -&gt; QueryResult:\n    \"\"\"Create a query for component types.\n\n    Example: world(Position, Velocity) -&gt; QueryResult iterable.\n    \"\"\"\n    self._check_readable(*component_types)\n    return QueryResult(self, component_types)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.spawn","title":"<code>spawn(*components)</code>","text":"<p>Spawn new entity with components. Returns provisional ID.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def spawn(self, *components: Any) -&gt; EntityId:\n    \"\"\"Spawn new entity with components. Returns provisional ID.\"\"\"\n    seen_types: set[type] = set()\n    for comp in components:\n        comp_type = type(comp)\n        self._check_writable(comp_type)\n        if comp_type in seen_types:\n            warnings.warn(\n                f\"spawn() received multiple components of type {comp_type.__name__}. \"\n                f\"Only the last one will be kept.\",\n                stacklevel=2,\n            )\n        seen_types.add(comp_type)\n\n    self._buffer.spawns.append(components)\n    # Return provisional ID - actual ID assigned at apply time\n    return EntityId(shard=0, index=-len(self._buffer.spawns), generation=0)\n</code></pre>"},{"location":"api/world/#agentecs.world.ScopedAccess.destroy","title":"<code>destroy(entity)</code>","text":"<p>Queue entity for destruction.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def destroy(self, entity: EntityId) -&gt; None:\n    \"\"\"Queue entity for destruction.\"\"\"\n    self._buffer.destroys.append(entity)\n</code></pre>"},{"location":"api/world/#readonlyaccess","title":"ReadOnlyAccess","text":""},{"location":"api/world/#agentecs.world.ReadOnlyAccess","title":"<code>ReadOnlyAccess</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Read-only world view for PURE and READONLY systems.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>class ReadOnlyAccess(Protocol):\n    \"\"\"Read-only world view for PURE and READONLY systems.\"\"\"\n\n    def query(self, *component_types: type) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n        \"\"\"Query entities by component types.\"\"\"\n        ...\n\n    def get(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get a component from an entity.\"\"\"\n        ...\n\n    def has(self, entity: EntityId, component_type: type) -&gt; bool:\n        \"\"\"Check if entity has a component.\"\"\"\n        ...\n\n    def singleton(self, component_type: type[T]) -&gt; T:\n        \"\"\"Get a singleton component.\"\"\"\n        ...\n\n    def entities(self) -&gt; Iterator[EntityId]:\n        \"\"\"Iterate all entities.\"\"\"\n        ...\n</code></pre>"},{"location":"api/world/#agentecs.world.ReadOnlyAccess.query","title":"<code>query(*component_types)</code>","text":"<p>Query entities by component types.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def query(self, *component_types: type) -&gt; Iterator[tuple[EntityId, tuple[Any, ...]]]:\n    \"\"\"Query entities by component types.\"\"\"\n    ...\n</code></pre>"},{"location":"api/world/#agentecs.world.ReadOnlyAccess.get","title":"<code>get(entity, component_type)</code>","text":"<p>Get a component from an entity.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def get(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n    \"\"\"Get a component from an entity.\"\"\"\n    ...\n</code></pre>"},{"location":"api/world/#agentecs.world.ReadOnlyAccess.has","title":"<code>has(entity, component_type)</code>","text":"<p>Check if entity has a component.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def has(self, entity: EntityId, component_type: type) -&gt; bool:\n    \"\"\"Check if entity has a component.\"\"\"\n    ...\n</code></pre>"},{"location":"api/world/#agentecs.world.ReadOnlyAccess.singleton","title":"<code>singleton(component_type)</code>","text":"<p>Get a singleton component.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def singleton(self, component_type: type[T]) -&gt; T:\n    \"\"\"Get a singleton component.\"\"\"\n    ...\n</code></pre>"},{"location":"api/world/#agentecs.world.ReadOnlyAccess.entities","title":"<code>entities()</code>","text":"<p>Iterate all entities.</p> Source code in <code>src/agentecs/world/access.py</code> <pre><code>def entities(self) -&gt; Iterator[EntityId]:\n    \"\"\"Iterate all entities.\"\"\"\n    ...\n</code></pre>"},{"location":"api/world/#entityhandle","title":"EntityHandle","text":"<p>Convenient wrapper for single-entity operations.</p>"},{"location":"api/world/#agentecs.world.EntityHandle","title":"<code>EntityHandle</code>","text":"<p>Convenient wrapper for repeated single-entity operations.</p> <p>Provides dict-style access to an entity's components with syntax like: e[Position] = pos, del e[Velocity], Position in e.</p> <p>Parameters:</p> Name Type Description Default <code>access</code> <code>ScopedAccess</code> <p>ScopedAccess instance.</p> required <code>entity</code> <code>EntityId</code> <p>EntityId to wrap.</p> required Source code in <code>src/agentecs/world/access.py</code> <pre><code>class EntityHandle:\n    \"\"\"Convenient wrapper for repeated single-entity operations.\n\n    Provides dict-style access to an entity's components with syntax like:\n    e[Position] = pos, del e[Velocity], Position in e.\n\n    Args:\n        access: ScopedAccess instance.\n        entity: EntityId to wrap.\n    \"\"\"\n\n    def __init__(self, access: ScopedAccess, entity: EntityId):\n        \"\"\"Initialize entity handle.\n\n        Args:\n            access: ScopedAccess instance.\n            entity: EntityId to wrap.\n        \"\"\"\n        self._access = access\n        self._entity = entity\n\n    @property\n    def id(self) -&gt; EntityId:\n        \"\"\"Get the entity ID for this handle.\n\n        Returns:\n            The EntityId this handle wraps.\n        \"\"\"\n        return self._entity\n\n    def __getitem__(self, component_type: type[T]) -&gt; T | None:\n        \"\"\"Get component from entity: e[Position] -&gt; Position or None.\n\n        Args:\n            component_type: Component type to retrieve.\n\n        Returns:\n            Component instance or None if not present.\n        \"\"\"\n        return self._access.get(self._entity, component_type)\n\n    def __setitem__(self, component_type: type, value: Any) -&gt; None:\n        \"\"\"Set component on entity: e[Position] = new_pos.\n\n        Args:\n            component_type: Component type (unused, inferred from value).\n            value: Component instance to set.\n        \"\"\"\n        self._access.update(self._entity, value)\n\n    def __delitem__(self, component_type: type) -&gt; None:\n        \"\"\"Remove component from entity: del e[Position].\n\n        Args:\n            component_type: Component type to remove.\n        \"\"\"\n        self._access.remove(self._entity, component_type)\n\n    def __contains__(self, component_type: type) -&gt; bool:\n        \"\"\"Check if entity has component: Position in e.\n\n        Args:\n            component_type: Component type to check.\n\n        Returns:\n            True if entity has component, False otherwise.\n        \"\"\"\n        return self._access.has(self._entity, component_type)\n</code></pre>"},{"location":"api/world/#system-results","title":"System Results","text":"<p>Systems can return results describing changes to apply.</p>"},{"location":"api/world/#agentecs.world.SystemResult","title":"<code>SystemResult</code>  <code>dataclass</code>","text":"<p>Accumulated changes from system execution.</p> Source code in <code>src/agentecs/world/result.py</code> <pre><code>@dataclass\nclass SystemResult:\n    \"\"\"Accumulated changes from system execution.\"\"\"\n\n    updates: dict[EntityId, dict[type, Any]] = field(default_factory=dict)\n    inserts: dict[EntityId, list[Any]] = field(default_factory=dict)\n    removes: dict[EntityId, list[type]] = field(default_factory=dict)\n    spawns: list[tuple[Any, ...]] = field(default_factory=list)\n    destroys: list[EntityId] = field(default_factory=list)\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if this result contains no changes.\n\n        Returns:\n            True if result has no updates, inserts, removes, spawns, or destroys.\n        \"\"\"\n        return (\n            not self.updates\n            and not self.inserts\n            and not self.removes\n            and not self.spawns\n            and not self.destroys\n        )\n\n    def merge(self, other: SystemResult) -&gt; None:\n        \"\"\"Merge other result into this one.\n\n        Combines all changes from other into self, mutating self in place.\n        Component updates are merged per-entity, per-type.\n\n        Args:\n            other: SystemResult to merge into this one.\n        \"\"\"\n        for entity, components in other.updates.items():\n            if entity not in self.updates:\n                self.updates[entity] = {}\n            self.updates[entity].update(components)\n\n        for entity, component_list in other.inserts.items():\n            if entity not in self.inserts:\n                self.inserts[entity] = []\n            self.inserts[entity].extend(component_list)\n\n        for entity, types in other.removes.items():\n            if entity not in self.removes:\n                self.removes[entity] = []\n            self.removes[entity].extend(types)\n\n        self.spawns.extend(other.spawns)\n        self.destroys.extend(other.destroys)\n</code></pre>"},{"location":"api/world/#agentecs.world.SystemResult.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if this result contains no changes.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if result has no updates, inserts, removes, spawns, or destroys.</p> Source code in <code>src/agentecs/world/result.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Check if this result contains no changes.\n\n    Returns:\n        True if result has no updates, inserts, removes, spawns, or destroys.\n    \"\"\"\n    return (\n        not self.updates\n        and not self.inserts\n        and not self.removes\n        and not self.spawns\n        and not self.destroys\n    )\n</code></pre>"},{"location":"api/world/#agentecs.world.SystemResult.merge","title":"<code>merge(other)</code>","text":"<p>Merge other result into this one.</p> <p>Combines all changes from other into self, mutating self in place. Component updates are merged per-entity, per-type.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>SystemResult</code> <p>SystemResult to merge into this one.</p> required Source code in <code>src/agentecs/world/result.py</code> <pre><code>def merge(self, other: SystemResult) -&gt; None:\n    \"\"\"Merge other result into this one.\n\n    Combines all changes from other into self, mutating self in place.\n    Component updates are merged per-entity, per-type.\n\n    Args:\n        other: SystemResult to merge into this one.\n    \"\"\"\n    for entity, components in other.updates.items():\n        if entity not in self.updates:\n            self.updates[entity] = {}\n        self.updates[entity].update(components)\n\n    for entity, component_list in other.inserts.items():\n        if entity not in self.inserts:\n            self.inserts[entity] = []\n        self.inserts[entity].extend(component_list)\n\n    for entity, types in other.removes.items():\n        if entity not in self.removes:\n            self.removes[entity] = []\n        self.removes[entity].extend(types)\n\n    self.spawns.extend(other.spawns)\n    self.destroys.extend(other.destroys)\n</code></pre>"},{"location":"api/world/#agentecs.world.normalize_result","title":"<code>normalize_result(raw)</code>","text":"<p>Convert any valid system return format to SystemResult.</p> <p>Supports multiple return formats for convenience: - None: No changes - SystemResult: Direct passthrough - Dict[EntityId, Dict[type, Any]]: Entity to component dict - Dict[EntityId, Any]: Entity to single component - List[Tuple[EntityId, Any]]: List of (entity, component) pairs</p> <p>Parameters:</p> Name Type Description Default <code>raw</code> <code>SystemReturn</code> <p>System return value in any supported format.</p> required <p>Returns:</p> Type Description <code>SystemResult</code> <p>Normalized SystemResult.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If return value is not a recognized format.</p> Source code in <code>src/agentecs/world/result.py</code> <pre><code>def normalize_result(raw: SystemReturn) -&gt; SystemResult:\n    \"\"\"Convert any valid system return format to SystemResult.\n\n    Supports multiple return formats for convenience:\n    - None: No changes\n    - SystemResult: Direct passthrough\n    - Dict[EntityId, Dict[type, Any]]: Entity to component dict\n    - Dict[EntityId, Any]: Entity to single component\n    - List[Tuple[EntityId, Any]]: List of (entity, component) pairs\n\n    Args:\n        raw: System return value in any supported format.\n\n    Returns:\n        Normalized SystemResult.\n\n    Raises:\n        TypeError: If return value is not a recognized format.\n    \"\"\"\n    if raw is None:\n        return SystemResult()\n\n    if isinstance(raw, SystemResult):\n        return raw\n\n    if isinstance(raw, dict):\n        result = SystemResult()\n        for entity, value in raw.items():\n            if not isinstance(entity, EntityId):\n                raise TypeError(f\"Expected EntityId key, got {type(entity)}\")\n\n            if isinstance(value, dict):\n                # {entity: {Type: component}}\n                result.updates[entity] = value\n            else:\n                # {entity: component} - infer type\n                result.updates[entity] = {type(value): value}\n        return result\n\n    if isinstance(raw, list):\n        result = SystemResult()\n        for item in raw:\n            if not isinstance(item, tuple) or len(item) != 2:\n                raise TypeError(f\"Expected (EntityId, component) tuple, got {item}\")\n            entity, component = item\n            if not isinstance(entity, EntityId):\n                raise TypeError(f\"Expected EntityId, got {type(entity)}\")\n\n            if entity not in result.updates:\n                result.updates[entity] = {}\n            result.updates[entity][type(component)] = component\n        return result\n\n    raise TypeError(f\"Invalid system return type: {type(raw)}\")\n</code></pre>"},{"location":"api/world/#entity-allocator","title":"Entity Allocator","text":"<p>Manages entity ID allocation with generational indices.</p>"},{"location":"api/world/#agentecs.world.EntityAllocator","title":"<code>EntityAllocator</code>","text":"<p>Allocates entity IDs with generation tracking for recycling.</p> <p>Maintains a free list of deallocated entity indices with incremented generations to safely reuse entity IDs. Starts allocation after reserved system entities.</p> <p>Parameters:</p> Name Type Description Default <code>shard</code> <code>int</code> <p>Shard number for this allocator (default 0 for local).</p> <code>0</code> Source code in <code>src/agentecs/storage/allocator.py</code> <pre><code>class EntityAllocator:\n    \"\"\"Allocates entity IDs with generation tracking for recycling.\n\n    Maintains a free list of deallocated entity indices with incremented generations\n    to safely reuse entity IDs. Starts allocation after reserved system entities.\n\n    Args:\n        shard: Shard number for this allocator (default 0 for local).\n    \"\"\"\n\n    def __init__(self, shard: int = 0):\n        \"\"\"Initialize entity allocator for a specific shard.\n\n        Args:\n            shard: Shard number for this allocator (default 0 for local).\n        \"\"\"\n        self._shard = shard\n        self._next_index = SystemEntity._RESERVED_COUNT\n        self._free_list: list[tuple[int, int]] = []  # (index, generation)\n        self._generations: dict[int, int] = {}\n\n    def allocate(self) -&gt; EntityId:\n        \"\"\"Allocate new entity ID, reusing recycled slots when available.\n\n        Prioritizes reusing freed entity IDs from the free list before allocating\n        new indices. Reused IDs have incremented generation numbers.\n\n        Returns:\n            Newly allocated EntityId.\n        \"\"\"\n        if self._free_list:\n            index, gen = self._free_list.pop()\n            return EntityId(shard=self._shard, index=index, generation=gen)\n\n        index = self._next_index\n        self._next_index += 1\n        self._generations[index] = 0\n        return EntityId(shard=self._shard, index=index, generation=0)\n\n    def deallocate(self, entity: EntityId) -&gt; None:\n        \"\"\"Return entity ID for reuse with incremented generation.\n\n        Adds the entity's index to the free list with an incremented generation\n        number, making it available for reallocation.\n\n        Args:\n            entity: Entity ID to deallocate.\n\n        Raises:\n            ValueError: If entity is from a different shard.\n        \"\"\"\n        if entity.shard != self._shard:\n            raise ValueError(\n                f\"Cannot deallocate entity from shard {entity.shard} on shard {self._shard}\"\n            )\n\n        new_gen = entity.generation + 1\n        self._generations[entity.index] = new_gen\n        self._free_list.append((entity.index, new_gen))\n\n    def is_alive(self, entity: EntityId) -&gt; bool:\n        \"\"\"Check if entity ID is still valid (not recycled).\n\n        Compares entity's generation number with the current generation for that\n        index to determine if the entity is still alive or has been recycled.\n\n        Args:\n            entity: Entity ID to check.\n\n        Returns:\n            True if entity is alive, False if recycled or from different shard.\n        \"\"\"\n        if entity.shard != self._shard:\n            return False  # TODO: cross-shard liveness check\n        current_gen = self._generations.get(entity.index, -1)\n        return current_gen == entity.generation\n</code></pre>"},{"location":"api/world/#agentecs.world.EntityAllocator.allocate","title":"<code>allocate()</code>","text":"<p>Allocate new entity ID, reusing recycled slots when available.</p> <p>Prioritizes reusing freed entity IDs from the free list before allocating new indices. Reused IDs have incremented generation numbers.</p> <p>Returns:</p> Type Description <code>EntityId</code> <p>Newly allocated EntityId.</p> Source code in <code>src/agentecs/storage/allocator.py</code> <pre><code>def allocate(self) -&gt; EntityId:\n    \"\"\"Allocate new entity ID, reusing recycled slots when available.\n\n    Prioritizes reusing freed entity IDs from the free list before allocating\n    new indices. Reused IDs have incremented generation numbers.\n\n    Returns:\n        Newly allocated EntityId.\n    \"\"\"\n    if self._free_list:\n        index, gen = self._free_list.pop()\n        return EntityId(shard=self._shard, index=index, generation=gen)\n\n    index = self._next_index\n    self._next_index += 1\n    self._generations[index] = 0\n    return EntityId(shard=self._shard, index=index, generation=0)\n</code></pre>"},{"location":"api/world/#agentecs.world.EntityAllocator.deallocate","title":"<code>deallocate(entity)</code>","text":"<p>Return entity ID for reuse with incremented generation.</p> <p>Adds the entity's index to the free list with an incremented generation number, making it available for reallocation.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity ID to deallocate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If entity is from a different shard.</p> Source code in <code>src/agentecs/storage/allocator.py</code> <pre><code>def deallocate(self, entity: EntityId) -&gt; None:\n    \"\"\"Return entity ID for reuse with incremented generation.\n\n    Adds the entity's index to the free list with an incremented generation\n    number, making it available for reallocation.\n\n    Args:\n        entity: Entity ID to deallocate.\n\n    Raises:\n        ValueError: If entity is from a different shard.\n    \"\"\"\n    if entity.shard != self._shard:\n        raise ValueError(\n            f\"Cannot deallocate entity from shard {entity.shard} on shard {self._shard}\"\n        )\n\n    new_gen = entity.generation + 1\n    self._generations[entity.index] = new_gen\n    self._free_list.append((entity.index, new_gen))\n</code></pre>"},{"location":"api/world/#agentecs.world.EntityAllocator.is_alive","title":"<code>is_alive(entity)</code>","text":"<p>Check if entity ID is still valid (not recycled).</p> <p>Compares entity's generation number with the current generation for that index to determine if the entity is still alive or has been recycled.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>EntityId</code> <p>Entity ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if entity is alive, False if recycled or from different shard.</p> Source code in <code>src/agentecs/storage/allocator.py</code> <pre><code>def is_alive(self, entity: EntityId) -&gt; bool:\n    \"\"\"Check if entity ID is still valid (not recycled).\n\n    Compares entity's generation number with the current generation for that\n    index to determine if the entity is still alive or has been recycled.\n\n    Args:\n        entity: Entity ID to check.\n\n    Returns:\n        True if entity is alive, False if recycled or from different shard.\n    \"\"\"\n    if entity.shard != self._shard:\n        return False  # TODO: cross-shard liveness check\n    current_gen = self._generations.get(entity.index, -1)\n    return current_gen == entity.generation\n</code></pre>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Coming Soon</p> <p>Practical examples and patterns will be added here.</p>"},{"location":"cookbook/#available-recipes","title":"Available Recipes","text":"<ul> <li>Basic Patterns (coming soon)</li> <li>System Patterns (coming soon)</li> <li>Advanced Patterns (coming soon)</li> <li>Testing Patterns (coming soon)</li> </ul> <p>For now, see the examples/ directory in the repository.</p>"},{"location":"start-up/core-concepts/","title":"Core Concepts","text":"<p>AgentECS is built on the Entity-Component-System (ECS) architectural pattern. This guide introduces the fundamental concepts and how they enable flexible multi-agent systems.</p>"},{"location":"start-up/core-concepts/#the-ecs-paradigm","title":"The ECS Paradigm","text":"<p>Traditional object-oriented frameworks bundle data and behavior into classes. ECS separates them:</p> <ul> <li> <p> Entities</p> <p>Lightweight unique identifiers for agents. Just IDs\u2014no data, no behavior.</p> </li> <li> <p> Components</p> <p>Pure data structures. Define what an entity is (task state, message history, token budget).</p> </li> <li> <p> Systems</p> <p>Functions that operate on entities with specific components. Define how entities behave.</p> </li> </ul> <pre><code>graph LR\n    E[Entity ID] --&gt; C1[Task]\n    E --&gt; C2[Context]\n    E --&gt; C3[TokenBudget]\n    E --&gt; C4[AgentTag]\n\n    S1[Task Processing] -.reads.-&gt; C1\n    S1 -.reads.-&gt; C3\n    S1 -.writes.-&gt; C1\n    S1 -.writes.-&gt; C3\n\n    S2[Context Management] -.reads.-&gt; C2\n    S2 -.writes.-&gt; C2\n\n    style E fill:#e1f5fe\n    style C1 fill:#fff3e0\n    style C2 fill:#fff3e0\n    style C3 fill:#fff3e0\n    style C4 fill:#fff3e0\n    style S1 fill:#c8e6c9\n    style S2 fill:#c8e6c9</code></pre> <p>Why ECS for AI Agents?</p> <ul> <li>Composition over Inheritance: Build agents from component combinations, not rigid class hierarchies</li> <li>Emergent Behavior: Complex workflows emerge from simple system interactions</li> <li>Dynamic Reconfiguration: Add/remove components at runtime to change agent capabilities</li> <li>Parallel Execution: Systems run concurrently with snapshot isolation</li> </ul>"},{"location":"start-up/core-concepts/#entities-agent-identities","title":"Entities: Agent Identities","text":"<p>Entities are unique identifiers with no inherent data or behavior.</p> <p>Creating Entities:</p> <pre><code>from agentecs import World, component\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    COMPLETED = \"completed\"\n\n@component\n@dataclass\nclass Task:\n    description: str\n    status: TaskStatus\n\nworld = World()\n\n# Spawn entity with components\nagent = world.spawn(Task(\"Analyze feedback\", TaskStatus.PENDING))\n</code></pre> <p>Entity Structure:</p> <pre><code>@dataclass(frozen=True)\nclass EntityId:\n    shard: int       # For distributed allocation (0 for local)\n    index: int       # Unique index within shard\n    generation: int  # Prevents stale references after recycling\n</code></pre> <p>Key Properties:</p> <ul> <li>Lightweight: Just three integers, no memory overhead</li> <li>Generational: Recycled indices get new generation, preventing confusion</li> <li>Distributed-Ready: Shard field supports multi-node allocation</li> </ul>"},{"location":"start-up/core-concepts/#components-agent-state","title":"Components: Agent State","text":"<p>Components are plain dataclasses containing only data\u2014no methods (except optional protocols).</p> <p>Defining Components:</p> <pre><code>from dataclasses import dataclass\nfrom agentecs import component\n\n@component\n@dataclass(slots=True)\nclass Task:\n    description: str\n    status: str\n\n@component\n@dataclass(slots=True)\nclass Message:\n    role: str\n    content: str\n\n@component\n@dataclass(slots=True)\nclass Context:\n    \"\"\"Conversation history.\"\"\"\n    messages: list[Message]\n\n@component\n@dataclass(slots=True)\nclass AgentTag:\n    \"\"\"Marker component for AI agents.\"\"\"\n    name: str\n</code></pre> <p>Use slots=True</p> <p><code>@dataclass(slots=True)</code> reduces memory usage and improves performance. Recommended for all components.</p> <p>Pydantic Components:</p> <p>For automatic validation, use Pydantic models:</p> <pre><code>from pydantic import BaseModel, Field\nfrom agentecs import component\n\n@component\nclass LLMConfig(BaseModel):\n    temperature: float = Field(gt=0, le=2.0)\n    max_tokens: int = Field(gt=0, le=4096)\n    model: str = \"claude-sonnet-4-20250514\"\n</code></pre> <p>Requires: <code>pip install agentecs[config]</code></p> <p>Component Composition:</p> <p>Entities with different component combinations behave differently:</p> <pre><code># Simple agent with task\nworld.spawn(Task(\"Analyze sentiment\", \"pending\"), AgentTag(\"Alice\"))\n\n# Agent with context tracking\nworld.spawn(\n    Task(\"Extract entities\", \"pending\"),\n    Context(messages=[]),\n    AgentTag(\"Bob\")\n)\n\n# Complex agent with token budget\nworld.spawn(\n    Task(\"Summarize text\", \"pending\"),\n    Context(messages=[]),\n    TokenBudget(available=1000, used=0),\n    AgentTag(\"Charlie\")\n)\n</code></pre>"},{"location":"start-up/core-concepts/#component-uniqueness","title":"Component Uniqueness","text":"<p>One Component Per Type Per Entity</p> <p>Each entity can have at most one component of each type. Attempting to spawn an entity with multiple components of the same type will result in only the last one being kept (with a warning).</p> <p>This is a fundamental ECS constraint shared by all major frameworks (Unity ECS, Bevy, EnTT). It enables efficient storage patterns like archetypal storage.</p> <p>Wrong - only last Task survives:</p> <pre><code># \u274c Silent overwrite - only \"Task D\" is kept\nagent = world.spawn(\n    Task(\"A\"),\n    Task(\"B\"),\n    Task(\"C\"),\n    Task(\"D\"),\n)\n</code></pre> <p>Correct - use a wrapper component:</p> <pre><code># \u2705 Use a list wrapper for multiple items\n@component\n@dataclass\nclass TaskList:\n    tasks: list[Task] = field(default_factory=list)\n\nagent = world.spawn(TaskList(tasks=[\n    Task(\"A\"),\n    Task(\"B\"),\n    Task(\"C\"),\n    Task(\"D\"),\n]))\n</code></pre> <p>Optional Component Protocols:</p> <p>Components can implement optional protocols for advanced features:</p> <pre><code>@component\n@dataclass\nclass TokenBudget:\n    available: int\n    used: int\n\n    def __merge__(self, other: \"TokenBudget\") -&gt; \"TokenBudget\":\n        \"\"\"Combine budgets when merging agents.\"\"\"\n        return TokenBudget(\n            available=self.available + other.available,\n            used=self.used + other.used\n        )\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[\"TokenBudget\", \"TokenBudget\"]:\n        \"\"\"Divide budget when splitting agents.\"\"\"\n        left_available = int(self.available * ratio)\n        right_available = self.available - left_available\n        return (\n            TokenBudget(left_available, 0),\n            TokenBudget(right_available, 0)\n        )\n</code></pre> <p>Available protocols: <code>Mergeable</code>, <code>Splittable</code>, <code>Reducible</code>, <code>Diffable</code>, <code>Interpolatable</code></p> <p>See Components for details.</p>"},{"location":"start-up/core-concepts/#systems-agent-behavior","title":"Systems: Agent Behavior","text":"<p>Systems are functions (sync or async) that query entities and apply transformations.</p> <p>Defining Systems:</p> <pre><code>from agentecs import system, ScopedAccess\n\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    \"\"\"Process tasks using available tokens.\"\"\"\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            new_task = Task(task.description, \"completed\")\n            new_budget = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n            world[entity, Task] = new_task\n            world[entity, TokenBudget] = new_budget\n</code></pre> <p>System Declaration:</p> <ul> <li><code>reads</code>: Component types the system reads</li> <li><code>writes</code>: Component types the system writes</li> <li>Both are optional\u2014omit for full access during prototyping</li> </ul> <p>Querying Entities:</p> <pre><code># Query entities with specific components\nfor entity, task, budget in world(Task, TokenBudget):\n    # entity: EntityId\n    # task: Task\n    # budget: TokenBudget\n    print(f\"Entity {entity} has task: {task.description}\")\n</code></pre> <p>Updating Components:</p> <pre><code>@system(reads=(TokenBudget,), writes=(TokenBudget,))\ndef decay_budget(world: ScopedAccess) -&gt; None:\n    for entity, budget in world(TokenBudget):\n        # budget is a copy - must write back changes\n        world[entity, TokenBudget] = TokenBudget(\n            available=budget.available - 1,\n            used=budget.used + 1\n        )\n</code></pre> <p>Components are Copies</p> <p>All reads return deep copies. Mutations won't persist unless you write back via <code>world[entity, Type] = value</code>.</p> <p>Async Systems:</p> <p>For I/O-bound operations (LLM calls, database queries):</p> <pre><code>@system(reads=(Task,), writes=(Response,))\nasync def llm_inference(world: ScopedAccess) -&gt; None:\n    \"\"\"Call LLM API for entities with tasks.\"\"\"\n    import asyncio\n\n    tasks = []\n    entities = []\n\n    for entity, task in world(Task):\n        tasks.append(call_llm_api(task.description))\n        entities.append(entity)\n\n    # Parallel API calls\n    responses = await asyncio.gather(*tasks)\n\n    for entity, response in zip(entities, responses):\n        world[entity, Response] = Response(response)\n</code></pre> <p>For more details on systems, see Systems.</p>"},{"location":"start-up/core-concepts/#the-world-state-container","title":"The World: State Container","text":"<p>The <code>World</code> is the central container managing entities, components, storage, and scheduling.</p> <p>Creating a World:</p> <pre><code>from agentecs import World\n\nworld = World()\n</code></pre> <p>Common Operations:</p> <pre><code># Spawn entities\nagent = world.spawn(Task(\"Analyze text\", \"pending\"), TokenBudget(1000, 0))\n\n# Get component\ntask = world.get_component(agent, Task)\n\n# Set component\nworld.set_component(agent, Task(\"New task\", \"pending\"))\n\n# Check component\nhas_budget = world.has_component(agent, TokenBudget)\n\n# Remove component\nworld.remove_component(agent, TokenBudget)\n\n# Destroy entity\nworld.destroy_entity(agent)\n\n# Register systems\nworld.register_system(process_tasks)\nworld.register_system(decay_budget)\n\n# Advance simulation\nworld.tick()  # Sync\nawait world.tick_async()  # Async\n</code></pre> <p>Singleton Components:</p> <p>Global state as components on system entities:</p> <pre><code># Set global config\nworld.set_singleton(LLMConfig(temperature=0.7, max_tokens=2000))\n\n# Read in any system\nconfig = world.singleton(LLMConfig)\n</code></pre> <p>See World Management for details.</p>"},{"location":"start-up/core-concepts/#execution-model","title":"Execution Model","text":"<p>Understanding how systems execute is key to using AgentECS effectively.</p>"},{"location":"start-up/core-concepts/#ticks-and-execution-groups","title":"Ticks and Execution Groups","text":"<p>A tick is one complete execution cycle. Systems are organized into execution groups:</p> <ul> <li>Group 1: Dev mode systems (<code>@system.dev()</code>) run in isolation</li> <li>Group 2: Normal systems run in parallel with snapshot isolation</li> </ul> <pre><code>graph LR\n    A[Group 1: Dev Systems] --&gt; B[Apply Results]\n    B --&gt; C[Group 2: Normal Systems]\n    C --&gt; D[Apply Results]\n    D --&gt; E[Next Tick]\n\n    style A fill:#ffcdd2\n    style C fill:#c8e6c9</code></pre> <p>Within a Group:</p> <ul> <li>All systems see the same initial state (snapshot)</li> <li>Systems execute in parallel (respecting concurrency limits)</li> <li>Changes are buffered</li> <li>Results merge at group boundary</li> </ul> <p>Between Groups:</p> <ul> <li>Previous group's changes are visible</li> <li>Next group sees updated state</li> </ul> <p>For detailed information on execution groups and scheduling, see Scheduling.</p>"},{"location":"start-up/core-concepts/#snapshot-isolation","title":"Snapshot Isolation","text":"<p>Systems in the same group see a consistent worldview:</p> <pre><code># Both systems see TokenBudget with available=1000\n@system(reads=(TokenBudget,), writes=(TokenBudget,))\ndef system_a(world: ScopedAccess) -&gt; None:\n    for e, b in world(TokenBudget):\n        # Sees 1000, writes 900\n        world[e, TokenBudget] = TokenBudget(available=900, used=b.used + 100)\n\n@system(reads=(TokenBudget,), writes=(TokenBudget,))\ndef system_b(world: ScopedAccess) -&gt; None:\n    for e, b in world(TokenBudget):\n        # Also sees 1000, writes 800\n        world[e, TokenBudget] = TokenBudget(available=800, used=b.used + 200)\n\n# After group: TokenBudget = 800 (LAST_WRITER_WINS merge strategy)\n</code></pre> <p>This enables safe parallelization without race conditions. For more on snapshot isolation, see Systems.</p>"},{"location":"start-up/core-concepts/#merge-strategies","title":"Merge Strategies","text":"<p>When multiple systems write to the same component, conflicts are resolved via merge strategies:</p> Strategy Behavior <code>LAST_WRITER_WINS</code> Later system (by registration order) overwrites <code>MERGEABLE_FIRST</code> Use <code>__merge__</code> if available, else overwrite <code>ERROR</code> Raise exception on conflict (debugging mode) <pre><code>from agentecs import SchedulerConfig, MergeStrategy\nfrom agentecs.scheduling import SimpleScheduler\n\nworld = World(\n    execution=SimpleScheduler(\n        config=SchedulerConfig(merge_strategy=MergeStrategy.MERGEABLE_FIRST)\n    )\n)\n</code></pre> <p>See Scheduling for details.</p>"},{"location":"start-up/core-concepts/#access-patterns","title":"Access Patterns","text":"<p>Systems can optionally declare which components they access for validation and documentation.</p> <p>When to Use:</p> <pre><code># Prototyping: no declarations, full access\n@system()\ndef prototype(world: ScopedAccess) -&gt; None:\n    # Can read/write anything\n    pass\n\n# Production: declared access for validation\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    for entity, task, budget in world(Task, TokenBudget):\n        world[entity, Task] = Task(task.description, \"completed\")\n\n# Debugging: dev mode for isolation\n@system.dev()\ndef debug_system(world: ScopedAccess) -&gt; None:\n    # Runs alone, full access, easier to reason about\n    pass\n</code></pre> <p>Write Implies Read</p> <p>If a system declares <code>writes=(Task,)</code>, it automatically has read access to <code>Task</code>. No need to list it in both.</p>"},{"location":"start-up/core-concepts/#practical-example","title":"Practical Example","text":"<p>Putting it all together - a simple LLM agent task processor:</p> <pre><code>from dataclasses import dataclass, field\nfrom enum import Enum\nfrom agentecs import World, component, system, ScopedAccess\n\n# Components\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    COMPLETED = \"completed\"\n\n@component\n@dataclass(slots=True)\nclass Task:\n    description: str\n    status: TaskStatus\n\n@component\n@dataclass(slots=True)\nclass Message:\n    role: str\n    content: str\n\n@component\n@dataclass(slots=True)\nclass Context:\n    messages: list[Message] = field(default_factory=list)\n    max_length: int = 10\n\n@component\n@dataclass(slots=True)\nclass TokenBudget:\n    available: int\n    total: int\n\n# Systems\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget, Context))\ndef process_task(world: ScopedAccess) -&gt; None:\n    \"\"\"Process tasks using token budget.\"\"\"\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == TaskStatus.PENDING and budget.available &gt;= 100:\n            # Process task\n            world[entity, Task] = Task(task.description, TaskStatus.COMPLETED)\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                total=budget.total\n            )\n\n            # Update context\n            if (entity, Context) in world:\n                ctx = world[entity, Context]\n                new_msgs = (ctx.messages + [\n                    Message(\"assistant\", f\"Completed: {task.description}\")\n                ])[-ctx.max_length:]\n                world[entity, Context] = Context(new_msgs, ctx.max_length)\n\n@system(reads=(TokenBudget,))\ndef monitor_budget(world: ScopedAccess) -&gt; None:\n    \"\"\"Warn on low budget.\"\"\"\n    for entity, budget in world(TokenBudget):\n        if budget.available &lt; 100:\n            used_pct = (budget.total - budget.available) / budget.total * 100\n            print(f\"Entity {entity.index}: {used_pct:.0f}% tokens used\")\n\n@system(reads=(Task, Context))\ndef cleanup_completed(world: ScopedAccess) -&gt; None:\n    \"\"\"Remove completed tasks.\"\"\"\n    to_destroy = []\n    for entity, task, ctx in world(Task, Context):\n        if task.status == TaskStatus.COMPLETED and len(ctx.messages) &gt; 5:\n            to_destroy.append(entity)\n\n    for entity in to_destroy:\n        world.destroy_entity(entity)\n\n# Create world and spawn agents\nworld = World()\n\nagent1 = world.spawn(\n    Task(\"Analyze customer feedback\", TaskStatus.PENDING),\n    TokenBudget(available=1000, total=1000),\n    Context()\n)\n\nagent2 = world.spawn(\n    Task(\"Generate weekly report\", TaskStatus.PENDING),\n    TokenBudget(available=500, total=1000),\n    Context()\n)\n\n# Register systems\nworld.register_system(process_task)\nworld.register_system(monitor_budget)\nworld.register_system(cleanup_completed)\n\n# Run simulation\nfor tick in range(10):\n    world.tick()\n</code></pre>"},{"location":"start-up/core-concepts/#key-takeaways","title":"Key Takeaways","text":"<ul> <li> <p> Composition</p> <p>Build agents from component combinations. No rigid class hierarchies.</p> </li> <li> <p> Systems are Functions</p> <p>Not classes. Just query, read, write. Keep them small and focused.</p> </li> <li> <p> Snapshot Isolation</p> <p>Systems in a group see the same initial state. Safe parallelism.</p> </li> <li> <p> Merge over Prevention</p> <p>Conflicts resolved via merge strategies, not rigid scheduling constraints.</p> </li> <li> <p> Flexibility First</p> <p>Optional declarations, optional protocols. Add structure incrementally.</p> </li> </ul>"},{"location":"start-up/core-concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics:</p> <ul> <li>Deep Dive: Read Systems for detailed system documentation</li> <li>Learn Components: Explore Component Protocols</li> <li>Understand Scheduling: Read Execution Groups</li> <li>See Real Examples: Check Task Dispatch Example</li> <li>Practical Patterns: Browse Cookbook</li> </ul>"},{"location":"start-up/core-concepts/#common-patterns","title":"Common Patterns","text":""},{"location":"start-up/core-concepts/#pattern-match-and-transform","title":"Pattern-Match and Transform","text":"<p>Query entities, transform each independently:</p> <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef update_task_status(world: ScopedAccess) -&gt; None:\n    for entity, task, budget in world(Task, TokenBudget):\n        if budget.available &gt;= 100:\n            world[entity, Task] = Task(task.description, TaskStatus.COMPLETED)\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                total=budget.total\n            )\n</code></pre>"},{"location":"start-up/core-concepts/#collect-and-operate-on-groups","title":"Collect and Operate on Groups","text":"<p>Collect entities, analyze as group, update:</p> <pre><code>@component\n@dataclass\nclass Opinion:\n    value: float  # -1.0 to 1.0\n\n@system(reads=(Context, Opinion), writes=(Opinion,))\ndef consensus(world: ScopedAccess) -&gt; None:\n    \"\"\"Agents influence each other's opinions based on context similarity.\"\"\"\n    agents = [(e, ctx, op) for e, ctx, op in world(Context, Opinion)]\n\n    for entity, context, opinion in agents:\n        # Find agents with similar context\n        similar = [\n            other_op for e, other_ctx, other_op in agents\n            if e != entity and has_overlap(context, other_ctx)\n        ]\n\n        if similar:\n            avg = sum(op.value for op in similar) / len(similar)\n            blended = opinion.value * 0.7 + avg * 0.3\n            world[entity, Opinion] = Opinion(blended)\n</code></pre>"},{"location":"start-up/core-concepts/#global-coordination","title":"Global Coordination","text":"<p>Access singletons for global parameters:</p> <pre><code>@system.dev()\ndef adjust_temperature(world: ScopedAccess) -&gt; None:\n    \"\"\"Lower temperature as agents converge.\"\"\"\n    converging = sum(1 for _ in world(ConvergingTag))\n    total = sum(1 for _ in world(AgentTag))\n\n    if total &gt; 0 and converging / total &gt; 0.7:\n        config = world.singleton(LLMConfig)\n        world.set_singleton(LLMConfig(\n            temperature=max(0.1, config.temperature - 0.1),\n            max_tokens=config.max_tokens,\n            model=config.model\n        ))\n</code></pre>"},{"location":"start-up/core-concepts/#see-also","title":"See Also","text":"<ul> <li>First Steps: Beginner tutorial with simple examples</li> <li>Design Philosophy: Architectural principles</li> <li>Systems: System declaration and execution in depth</li> <li>Components: Component protocols and operations</li> <li>Queries: Advanced query patterns</li> <li>World Management: Entity lifecycle</li> </ul>"},{"location":"start-up/first-steps/","title":"First Steps","text":"<p>Let's build your first AgentECS application: a simple task management system for AI agents. You'll learn the three core elements of ECS by implementing agents that process tasks.</p>"},{"location":"start-up/first-steps/#your-first-agent","title":"Your First Agent","text":"<p>Create a new file <code>my_first_agent.py</code>:</p> <pre><code>from dataclasses import dataclass\nfrom enum import Enum\nfrom agentecs import World, component, system, ScopedAccess\n\n# Step 1: Define components (data)\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n\n@component\n@dataclass\nclass Task:\n    description: str\n    status: TaskStatus\n\n@component\n@dataclass\nclass TokenBudget:\n    available: int\n    used: int\n\n# Step 2: Define a system (behavior)\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    \"\"\"Process pending tasks if tokens are available.\"\"\"\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == TaskStatus.PENDING and budget.available &gt;= 100:\n            # Simulate task processing\n            new_task = Task(task.description, TaskStatus.COMPLETED)\n            new_budget = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n            world[entity, Task] = new_task\n            world[entity, TokenBudget] = new_budget\n            print(f\"Entity {entity.index} completed: {task.description}\")\n            print(f\"  Tokens remaining: {new_budget.available}\")\n\n# Step 3: Create world and entities\nworld = World()\n\n# Spawn agents with tasks\nagent1 = world.spawn(\n    Task(\"Analyze user feedback\", TaskStatus.PENDING),\n    TokenBudget(available=500, used=0)\n)\n\nagent2 = world.spawn(\n    Task(\"Generate summary report\", TaskStatus.PENDING),\n    TokenBudget(available=150, used=0)\n)\n\n# Register system\nworld.register_system(process_tasks)\n\n# Run simulation\nfor tick in range(3):\n    print(f\"\\n=== Tick {tick + 1} ===\")\n    world.tick()\n</code></pre> <p>Run it:</p> <pre><code>python my_first_agent.py\n</code></pre> <p>You should see agents processing tasks when they have enough tokens:</p> <pre><code>=== Tick 1 ===\nEntity 0 completed: Analyze user feedback\n  Tokens remaining: 400\nEntity 1 completed: Generate summary report\n  Tokens remaining: 50\n\n=== Tick 2 ===\nEntity 0 completed: Analyze user feedback\n  Tokens remaining: 300\n\n=== Tick 3 ===\nEntity 0 completed: Analyze user feedback\n  Tokens remaining: 200\n</code></pre>"},{"location":"start-up/first-steps/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"start-up/first-steps/#components-are-data","title":"Components are Data","text":"<p>Components hold state. They're just dataclasses:</p> <pre><code>@component\n@dataclass\nclass Task:\n    description: str\n    status: TaskStatus\n</code></pre> <p>The <code>@component</code> decorator registers them with AgentECS so they can be queried.</p>"},{"location":"start-up/first-steps/#systems-are-behavior","title":"Systems are Behavior","text":"<p>Systems define what happens each tick. They query for entities with specific components:</p> <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    for entity, task, budget in world(Task, TokenBudget):\n        # Process task...\n</code></pre> <p>The <code>reads=</code> and <code>writes=</code> declarations are optional but help with: - Documentation (what does this system do?) - Validation (catching bugs early) - Parallelization (safe concurrent execution)</p>"},{"location":"start-up/first-steps/#entities-are-ids","title":"Entities are IDs","text":"<p>Entities are lightweight identifiers. When you spawn:</p> <pre><code>agent = world.spawn(Task(...), TokenBudget(...))\n</code></pre> <p>You get back an <code>EntityId</code>. The components are stored separately, accessed via queries.</p>"},{"location":"start-up/first-steps/#queries-find-patterns","title":"Queries Find Patterns","text":"<p>The query <code>world(Task, TokenBudget)</code> finds all entities with both components:</p> <pre><code>for entity, task, budget in world(Task, TokenBudget):\n    # Only entities with Task AND TokenBudget\n</code></pre>"},{"location":"start-up/first-steps/#copy-on-read-pattern","title":"Copy-on-Read Pattern","text":"<p>Important: All reads return copies. You must write back changes:</p> <pre><code># task is a COPY, not a reference\nnew_task = Task(task.description, TaskStatus.COMPLETED)\nworld[entity, Task] = new_task  # Write back required\n</code></pre> <p>This prevents accidental shared state and enables safe parallelization.</p>"},{"location":"start-up/first-steps/#adding-more-agents","title":"Adding More Agents","text":"<p>Let's add multiple agents with different capabilities:</p> <pre><code>from dataclasses import dataclass\nfrom enum import Enum\nfrom agentecs import World, component, system, ScopedAccess\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n\n@component\n@dataclass\nclass Task:\n    description: str\n    status: TaskStatus\n\n@component\n@dataclass\nclass Message:\n    role: str\n    content: str\n\n@component\n@dataclass\nclass Context:\n    \"\"\"Conversation history for an agent.\"\"\"\n    messages: list[Message]\n\n@system(reads=(Task,), writes=(Context,))\ndef track_conversation(world: ScopedAccess) -&gt; None:\n    \"\"\"Add completed tasks to conversation history.\"\"\"\n    for entity, task in world(Task):\n        if task.status == TaskStatus.COMPLETED:\n            # Get or create context\n            if (entity, Context) in world:\n                ctx = world[entity, Context]\n                new_messages = ctx.messages + [\n                    Message(\"assistant\", f\"Completed: {task.description}\")\n                ]\n                world[entity, Context] = Context(new_messages)\n            else:\n                # Insert new context component\n                world.insert(entity, Context([\n                    Message(\"assistant\", f\"Completed: {task.description}\")\n                ]))\n\nworld = World()\n\n# Spawn three agents\nworld.spawn(Task(\"Analyze sentiment\", TaskStatus.PENDING))\nworld.spawn(Task(\"Extract entities\", TaskStatus.PENDING))\nworld.spawn(Task(\"Summarize text\", TaskStatus.PENDING))\n\nworld.register_system(track_conversation)\n\nfor tick in range(2):\n    print(f\"\\nTick {tick + 1}:\")\n    world.tick()\n</code></pre> <p>All three agents track their conversation history independently.</p>"},{"location":"start-up/first-steps/#adding-another-system","title":"Adding Another System","text":"<p>Let's detect when agents are low on resources:</p> <pre><code>@component\n@dataclass\nclass TokenBudget:\n    available: int\n    used: int\n\n@system(reads=(TokenBudget,))\ndef budget_warning(world: ScopedAccess) -&gt; None:\n    \"\"\"Warn when agents are low on tokens.\"\"\"\n    for entity, budget in world(TokenBudget):\n        if budget.available &lt; 100:\n            print(f\"  Warning: Entity {entity.index} low on tokens ({budget.available} left)!\")\n\n# Register both systems\nworld.register_system(process_tasks)\nworld.register_system(budget_warning)\n\n# Both systems run each tick\nworld.tick()\n</code></pre> <p>Systems run in parallel by default (unless they conflict). More on this in Core Concepts.</p>"},{"location":"start-up/first-steps/#complete-example-llm-agent-workflow","title":"Complete Example: LLM Agent Workflow","text":"<p>Here's a full working example simulating a simple LLM agent workflow:</p> <pre><code>from dataclasses import dataclass\nfrom enum import Enum\nfrom agentecs import World, component, system, ScopedAccess\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    IN_PROGRESS = \"in_progress\"\n    COMPLETED = \"completed\"\n\n@component\n@dataclass\nclass Task:\n    description: str\n    status: TaskStatus\n\n@component\n@dataclass\nclass Message:\n    role: str\n    content: str\n\n@component\n@dataclass\nclass Context:\n    messages: list[Message]\n    max_length: int = 10\n\n@component\n@dataclass\nclass TokenBudget:\n    available: int\n    total: int\n\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget, Context))\ndef process_task_system(world: ScopedAccess) -&gt; None:\n    \"\"\"Process tasks using token budget.\"\"\"\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == TaskStatus.PENDING and budget.available &gt;= 100:\n            # Process task\n            world[entity, Task] = Task(task.description, TaskStatus.COMPLETED)\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                total=budget.total\n            )\n\n            # Add to context\n            msg = Message(\"assistant\", f\"Completed: {task.description}\")\n            if (entity, Context) in world:\n                ctx = world[entity, Context]\n                new_messages = (ctx.messages + [msg])[-ctx.max_length:]\n                world[entity, Context] = Context(new_messages, ctx.max_length)\n            else:\n                world.insert(entity, Context([msg]))\n\n@system(reads=(TokenBudget,))\ndef monitor_budget_system(world: ScopedAccess) -&gt; None:\n    \"\"\"Monitor token usage.\"\"\"\n    for entity, budget in world(TokenBudget):\n        used_pct = (budget.total - budget.available) / budget.total * 100\n        if used_pct &gt; 80:\n            print(f\"Entity {entity.index}: {used_pct:.0f}% tokens used\")\n\n@system(reads=(Task,))\ndef cleanup_system(world: ScopedAccess) -&gt; None:\n    \"\"\"Remove completed tasks.\"\"\"\n    to_remove = []\n    for entity, task in world(Task):\n        if task.status == TaskStatus.COMPLETED:\n            to_remove.append((entity, Task))\n\n    for entity, component_type in to_remove:\n        world.remove(entity, component_type)\n\n# Setup\nworld = World()\n\nworld.spawn(\n    Task(\"Analyze customer feedback\", TaskStatus.PENDING),\n    TokenBudget(available=1000, total=1000)\n)\n\nworld.spawn(\n    Task(\"Generate weekly report\", TaskStatus.PENDING),\n    TokenBudget(available=200, total=1000)\n)\n\nworld.register_system(process_task_system)\nworld.register_system(monitor_budget_system)\nworld.register_system(cleanup_system)\n\n# Run\nfor tick in range(3):\n    print(f\"\\n=== Tick {tick + 1} ===\")\n    world.tick()\n</code></pre>"},{"location":"start-up/first-steps/#next-steps","title":"Next Steps","text":"<p>You've learned the basics:</p> <ul> <li>Components hold data (Task, Message, Context, TokenBudget)</li> <li>Systems define behavior (process tasks, track context, monitor resources)</li> <li>Entities combine components</li> <li>Queries find patterns</li> <li>Copy-on-read prevents shared state</li> </ul> <p>Ready to dive deeper?</p> <ul> <li>Core Concepts: Learn about snapshot isolation, parallel execution, and async systems</li> <li>Cookbook: Practical patterns and examples</li> <li>Task Dispatch Example: See a complete LLM-based agent system</li> </ul>"},{"location":"start-up/first-steps/#common-questions","title":"Common Questions","text":"<p>Q: Do I need to specify <code>reads</code> and <code>writes</code>?</p> <p>No! They're optional. For prototyping, just use <code>@system()</code>. Add declarations later for documentation and optimization.</p> <p>Q: Can systems be async?</p> <p>Yes! Just define them with <code>async def</code>:</p> <pre><code>@system(reads=(Task,), writes=(Response,))\nasync def llm_system(world: ScopedAccess) -&gt; None:\n    # await LLM API calls...\n</code></pre> <p>Q: How do I access a specific entity?</p> <p>Use dict-style access:</p> <pre><code>task = world[agent, Task]  # Read\nworld[agent, Task] = new_task  # Write\n</code></pre> <p>Q: What if I query components an entity doesn't have?</p> <p>The query simply won't match that entity. Queries are safe and return only entities with all requested components.</p> <p>Q: How do I add a component to an existing entity?</p> <p>Use <code>world.insert()</code>:</p> <pre><code>world.insert(entity, Context([]))\n</code></pre> <p>Or within a system:</p> <pre><code>@system()\ndef add_context(world: ScopedAccess) -&gt; None:\n    for entity, task in world(Task):\n        if (entity, Context) not in world:\n            world.insert(entity, Context([]))\n</code></pre>"},{"location":"start-up/installation/","title":"Installation","text":"<p>AgentECS is a Python framework requiring Python 3.11 or higher.</p>"},{"location":"start-up/installation/#quick-install","title":"Quick Install","text":"<p>Install the core framework from PyPI:</p> <pre><code>pip install agentecs\n</code></pre> <p>This provides the minimal installation with just the ECS core functionality.</p>"},{"location":"start-up/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>AgentECS uses optional dependencies for additional features. Install them as needed:</p>"},{"location":"start-up/installation/#configuration-support","title":"Configuration Support","text":"<p>For Pydantic-based components and configuration:</p> <pre><code>pip install agentecs[config]\n</code></pre> <p>Enables: - Pydantic models as components - Automatic validation - Configuration management</p>"},{"location":"start-up/installation/#retry-logic","title":"Retry Logic","text":"<p>For automatic retry with exponential backoff:</p> <pre><code>pip install agentecs[retry]\n</code></pre> <p>Enables: - Configurable retry policies in scheduler - Exponential/linear backoff - Graceful failure handling for transient errors</p>"},{"location":"start-up/installation/#vector-storage","title":"Vector Storage","text":"<p>For ChromaDB-based vector storage (future):</p> <pre><code>pip install agentecs[chroma]\n</code></pre>"},{"location":"start-up/installation/#llm-integration","title":"LLM Integration","text":"<p>For built-in LLM client adapters:</p> <pre><code>pip install agentecs[llm]\n</code></pre>"},{"location":"start-up/installation/#visualization","title":"Visualization","text":"<p>The visualization tool is a separate package (agentecs-viz):</p> <pre><code># Option 1: Install directly\npip install agentecs-viz\n\n# Note: agentecs[viz] extra will be available once agentecs-viz is published to PyPI\n</code></pre> <p>This installs <code>agentecs</code> as a dependency automatically. See Visualization for usage.</p> <p>Local Development (for contributing to agentecs-viz):</p> <pre><code># Clone both repos side by side\ngit clone https://github.com/extensivelabs/agentecs\ngit clone https://github.com/extensivelabs/agentecs-viz\n\n# Install agentecs in editable mode\ncd agentecs &amp;&amp; pip install -e .\n\n# Install agentecs-viz in editable mode\ncd ../agentecs-viz &amp;&amp; pip install -e \".[dev]\"\n</code></pre>"},{"location":"start-up/installation/#all-optional-dependencies","title":"All Optional Dependencies","text":"<p>To install everything:</p> <pre><code>pip install agentecs[all]\n</code></pre> <p>Equivalent to: <pre><code>pip install agentecs[config,chroma,llm,retry,notebook]\n</code></pre></p> <p>Note: Visualization is installed separately with <code>pip install agentecs-viz</code>.</p>"},{"location":"start-up/installation/#development-installation","title":"Development Installation","text":"<p>For contributing to AgentECS or running examples:</p>"},{"location":"start-up/installation/#clone-repository","title":"Clone Repository","text":"<pre><code>git clone https://github.com/extensivelabs/agentecs\ncd agentecs\n</code></pre>"},{"location":"start-up/installation/#set-up-development-environment","title":"Set Up Development Environment","text":"<p>AgentECS uses <code>uv</code> for fast dependency management and <code>task</code> for build automation.</p> <p>Automatic Setup:</p> <pre><code>./scripts/bootstrap.sh\ntask setup\n</code></pre> <p>This will: 1. Install <code>uv</code> if not present 2. Create virtual environment 3. Install all dependencies (including dev dependencies) 4. Set up pre-commit hooks</p> <p>Manual Setup:</p> <p>If you prefer manual setup:</p> <pre><code># Install uv (if not already installed)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Create virtual environment and install dependencies\nuv sync\n\n# Activate virtual environment\nsource .venv/bin/activate  # Linux/macOS\n# or\n.venv\\Scripts\\activate  # Windows\n\n# Install pre-commit hooks\nuv run pre-commit install\n</code></pre>"},{"location":"start-up/installation/#verify-installation","title":"Verify Installation","text":"<p>Run tests to verify everything works:</p> <pre><code>task test\n</code></pre> <p>Run a simple example:</p> <pre><code>uv run python examples/simple_agents.py\n</code></pre>"},{"location":"start-up/installation/#development-tasks","title":"Development Tasks","text":"<p>AgentECS uses <code>task</code> (Taskfile) for common development operations:</p> <pre><code># Run all tests\ntask test\n\n# Run type checking\ntask type-check\n\n# Run linting\ntask lint\n\n# Auto-fix linting issues\ntask lint-fix\n\n# Build documentation\ntask docs\n\n# List all available tasks\ntask --list\n</code></pre>"},{"location":"start-up/installation/#verify-installation_1","title":"Verify Installation","text":"<p>Check your installation:</p> <pre><code>import agentecs\nprint(agentecs.__version__)\n\n# Try a simple example\nfrom dataclasses import dataclass\nfrom agentecs import World, component, system, ScopedAccess\n\n@component\n@dataclass\nclass Position:\n    x: float\n    y: float\n\n@system(reads=(Position,), writes=(Position,))\ndef move_right(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        world[entity, Position] = Position(pos.x + 1, pos.y)\n\nworld = World()\nentity = world.spawn(Position(0, 0))\nworld.register_system(move_right)\nworld.tick()\n\npos = world.get_component(entity, Position)\nassert pos.x == 1  # Entity moved right\nprint(\"\u2713 AgentECS is working!\")\n</code></pre>"},{"location":"start-up/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python: 3.11 or higher</li> <li>Operating Systems: Linux, macOS, Windows</li> <li>Memory: Minimal for core; scales with entity count</li> <li>Dependencies: Managed via <code>pyproject.toml</code></li> </ul>"},{"location":"start-up/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"start-up/installation/#import-errors","title":"Import Errors","text":"<p>If you see <code>ModuleNotFoundError: No module named 'agentecs'</code>:</p> <ul> <li>Ensure you activated the virtual environment</li> <li>Reinstall with <code>pip install agentecs</code> or <code>uv sync</code></li> </ul>"},{"location":"start-up/installation/#optional-dependency-errors","title":"Optional Dependency Errors","text":"<p>If you see errors about missing optional dependencies:</p> <pre><code>ImportError: Retry policy requires tenacity. Install with: pip install agentecs[retry]\n</code></pre> <p>Install the required optional dependency group as shown in the error message.</p>"},{"location":"start-up/installation/#development-setup-issues","title":"Development Setup Issues","text":"<p>If <code>./scripts/bootstrap.sh</code> fails:</p> <ol> <li>Check Python version: <code>python --version</code> (must be 3.11+)</li> <li>Install <code>uv</code> manually: <code>pip install uv</code></li> <li>Try manual setup steps above</li> </ol>"},{"location":"start-up/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Read Core Concepts to understand ECS fundamentals</li> <li>Explore Quick Example for a working system</li> <li>Check System Documentation for architecture details</li> <li>Browse Cookbook for practical patterns</li> </ul>"},{"location":"start-up/installation/#contributing","title":"Contributing","text":"<p>For detailed development setup and contribution guidelines, see:</p> <ul> <li>CONTRIBUTING.md</li> <li>Development Guide</li> </ul> <p>Report issues at: GitHub Issues</p>"},{"location":"system/","title":"System Documentation","text":"<p>Welcome to the documentation for AgentECS's systems and interfaces. In this section you will find detailed information about the core concepts, components, and systems that make up the AgentECS framework.</p> <p>If you are looking for how to implement specific use cases, please refer to the cookbook section here. Before diving into the details, you may want to read the Getting Started guide to set up your environment and create your first AgentECS application, and the Design Philosophy to understand the principles behind AgentECS's architecture.</p>"},{"location":"system/#getting-started","title":"Getting started","text":"<ul> <li>Design Philosophy</li> <li>Architecture</li> </ul>"},{"location":"system/#core-concepts","title":"Core Concepts","text":"<ul> <li>Components</li> <li>Entities</li> <li>Systems</li> </ul>"},{"location":"system/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>World Management</li> <li>Queries</li> <li>Scheduling</li> <li>Storage</li> <li>Roadmap</li> </ul>"},{"location":"system/architecture/","title":"Architecture","text":""},{"location":"system/architecture/#basic-concepts","title":"Basic Concepts","text":"<p>When setting up your AgentECS-based application, you will work with three primary concepts: Entities, Components, and Systems.</p>"},{"location":"system/architecture/#entities","title":"Entities","text":"<p>Entities represent unique instances, say an agent. Next to their unique identity, entities are collections of components. They do not contain any behavior themselves. More than that, the components are not part of the entity, but merely associated with it in the world state.</p> <p>Learn more about Entities.</p>"},{"location":"system/architecture/#components","title":"Components","text":"<p>Components are plain data structures that hold the state. An entity can have zero or more components associated with it. The combination of components defines the capabilities and characteristics of an entity. For example, an agent entity might have components like Tasks, Memory, and LLMConfig.</p> <p>Some entities share combinations of components. In this case, we call this type of entity an archetype. However, archetypes are not first-class citizens in the architecture, but merely an optimization for storage and querying.</p> <p>Learn more about Components.</p>"},{"location":"system/architecture/#systems","title":"Systems","text":"<p>Systems encapsulate the logic and behavior that operate on combinations of components - for entities, or across multiple entities. This point is crucial: Systems are not bound to a specific unit of operation (like an entity), but can operate on any level of granularity. For example, a system might process all agents with a Tasks component, or it might coordinate between multiple agents to achieve a shared goal.</p> <p>Learn more about Systems.</p>"},{"location":"system/architecture/#world-state-and-ticks","title":"World State and Ticks","text":"<p>The world state is the central repository that holds references to all entities and their associated components. Systems interact with the world state to read and write component data. As such, the world state handles the effects of systems in discrete ticks.</p> <p>Each tick represents a snapshot of the world state at a specific point in time. It is the smallest unit of change in AgentECS. During a tick, systems are executed, and their changes to the world state are applied at the end of the tick.</p> <p>Systems do not need to run every tick; they can be scheduled to run at specific intervals or based on certain conditions.</p>"},{"location":"system/architecture/#world-access","title":"World Access","text":"<p>Systems access the world state through a controlled interface that ensures consistency and isolation. When a system runs, it receives a scoped view of the world state that includes only the components it has declared access to. This scoped access allows systems to read and write component data without directly mutating the world state, enabling safe parallel execution and snapshot isolation.</p>"},{"location":"system/architecture/#scheduling-and-parallelism","title":"Scheduling and Parallelism","text":"<p>The scheduling of systems is a critical aspect of the AgentECS architecture. System declare their needs in terms of:</p> <ul> <li>Reads - Components that the system needs to read.</li> <li>Writes - Components that the system needs to write.</li> <li>Frequency - How often the system should run (every tick, every N ticks, on specific events).</li> <li>Conditions - Any conditions that must be met for the system to run.</li> <li>Dependencies - Other systems that must run before this system.</li> </ul> <p>The scheduler uses this information to determine the optimal order of system execution, allowing for parallelism where possible. First, the scheduler identifies systems that need to run in the current tick based on their frequency and conditions. Next, it resolves dependencies to ensure that systems run in the correct order. Based on the dependency graph, it creates execution groups of systems that can potentially run in parallel. Finally, it checks for access conflicts (e.g., two systems writing to the same component) and adjusts the execution plan accordingly.</p>"},{"location":"system/architecture/#future-learned-scheduling","title":"Future: Learned Scheduling","text":"<p>In future versions of AgentECS, we plan to introduce learned scheduling capabilities. By providing metrics such as execution time, latency, token-usage and performance outcomes, the scheduler can learn optimal execution strategies over time. These schedules are stored as part of the world state and can be used preferentially when similar conditions arise.</p>"},{"location":"system/architecture/#storage-performance-and-sharding","title":"Storage, Performance and Sharding","text":"<p>The world state is designed to be efficient and scalable, supporting large numbers of entities and components. It does not hold data directly, but rather references to component data stored in optimized data structures. This design allows for efficient querying and manipulation of entities based on their components.</p> <p>More details about storage and performance optimizations will be provided in future documentation.</p>"},{"location":"system/components/","title":"Components","text":"<p>Components are pure data structures that define what an entity is. They contain no logic themselves\u2014all behavior comes from Systems that operate on entities with specific component combinations.</p>"},{"location":"system/components/#overview","title":"Overview","text":"<p>In AgentECS, components are the fundamental building blocks of entity state. An entity is simply a unique ID plus a collection of components. By attaching different combinations of components to entities, you create diverse agents with varying capabilities and characteristics.</p> <p>Key Characteristics:</p> <ul> <li>Data-Only: Components are pure data containers (dataclasses or Pydantic models)</li> <li>Composable: Mix and match components to create different entity types</li> <li>Deterministic IDs: Same code produces same component IDs across nodes</li> <li>Optional Protocols: Components can opt-in to advanced operations (merge, split, diff, interpolate)</li> </ul> <pre><code>graph LR\n    A[Entity ID] --&gt; B[Task]\n    A --&gt; C[Context]\n    A --&gt; D[TokenBudget]\n    A --&gt; E[AgentTag]\n\n    style B fill:#e1f5fe\n    style C fill:#e1f5fe\n    style D fill:#e1f5fe\n    style E fill:#e1f5fe</code></pre> <p>Component Composition</p> <p>Entities with <code>Task + TokenBudget</code> behave differently from those with <code>Task + Context + AgentTag</code>. This composition is how AgentECS achieves flexibility without rigid class hierarchies.</p>"},{"location":"system/components/#basic-declaration","title":"Basic Declaration","text":"<p>Components are defined using Python dataclasses or Pydantic models, decorated with <code>@component</code>:</p> <pre><code>from dataclasses import dataclass\nfrom agentecs import component\n\n@component\n@dataclass(slots=True)\nclass Task:\n    description: str\n    status: str\n\n@component\n@dataclass(slots=True)\nclass TokenBudget:\n    available: int\n    used: int\n\n@component\n@dataclass(slots=True)\nclass AgentTag:\n    \"\"\"Marker component identifying AI agents.\"\"\"\n    name: str\n</code></pre> <p>Decorator Order</p> <p>ALWAYS apply <code>@component</code> decorator AFTER <code>@dataclass</code>:</p> <pre><code>@component       # \u2190 Second\n@dataclass       # \u2190 First\nclass MyComponent:\n    value: int\n</code></pre> <p>The reverse order will raise a <code>TypeError</code>.</p>"},{"location":"system/components/#what-happens-during-registration","title":"What Happens During Registration","text":"<p>When you decorate a class with <code>@component</code>, AgentECS:</p> <ol> <li>Validates the class is a dataclass or Pydantic model</li> <li>Generates a deterministic ID via SHA256 hash of the fully qualified class name</li> <li>Registers the mapping in a global registry</li> <li>Adds <code>__component_meta__</code> attribute to the class</li> </ol> <pre><code>sequenceDiagram\n    participant User as @component\n    participant Dec as Decorator\n    participant Reg as Registry\n\n    User-&gt;&gt;Dec: Apply to dataclass\n    Dec-&gt;&gt;Dec: Validate is dataclass\n    Dec-&gt;&gt;Dec: Hash qualified name\n    Dec-&gt;&gt;Reg: Register(type, ID)\n    Reg-&gt;&gt;Reg: Check collision\n    Reg--&gt;&gt;Dec: ComponentMeta\n    Dec-&gt;&gt;User: Add __component_meta__</code></pre>"},{"location":"system/components/#using-pydantic-models","title":"Using Pydantic Models","text":"<p>Components can also be Pydantic models for automatic validation:</p> <pre><code>from pydantic import BaseModel, Field\nfrom agentecs import component\n\n@component\nclass AgentConfig(BaseModel):\n    temperature: float = Field(gt=0, le=2.0)\n    max_tokens: int = Field(gt=0, le=4096)\n    model_name: str\n</code></pre> <p>Optional Dependency</p> <p>Pydantic is not required for AgentECS core functionality. Install with: <code>pip install agentecs[config]</code></p>"},{"location":"system/components/#advanced-features-component-protocols","title":"Advanced Features: Component Protocols","text":"<p>Components can optionally implement operation protocols to support advanced features like entity merging, splitting, and interpolation. These protocols are entirely optional\u2014components work fine without them.</p>"},{"location":"system/components/#how-to-use-component-protocols","title":"How to use Component Protocols","text":"<p>Protocols are defined as runtime-checkable interfaces. Simply implement the required methods on your component class:</p> <pre><code>from typing import Self\n\n@component\n@dataclass(slots=True)\nclass TokenBudget:\n    available: int\n    used: int\n\n    def __merge__(self, other: Self) -&gt; Self:\n        \"\"\"Merge by combining budgets.\"\"\"\n        return TokenBudget(\n            available=self.available + other.available,\n            used=self.used + other.used\n        )\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[Self, Self]:\n        \"\"\"Split budget by ratio.\"\"\"\n        left_available = int(self.available * ratio)\n        right_available = self.available - left_available\n        return (\n            TokenBudget(left_available, 0),\n            TokenBudget(right_available, 0)\n        )\n</code></pre> <p>Available protocols:</p> <ul> <li> <p> Mergeable</p> <p><code>__merge__(self, other: Self) -&gt; Self</code></p> <p>Combine two component instances into one (for agent merging)</p> </li> <li> <p> Splittable</p> <p><code>__split__(self, ratio: float) -&gt; tuple[Self, Self]</code></p> <p>Divide one component into two instances (for agent splitting)</p> </li> <li> <p> Reducible</p> <p><code>__reduce_many__(cls, items: list[Self]) -&gt; Self</code></p> <p>Aggregate N instances into one (classmethod)</p> </li> <li> <p> Diffable</p> <p><code>__diff__(self, baseline: Self) -&gt; Self</code> <code>__apply_diff__(self, diff: Self) -&gt; Self</code></p> <p>Compute and apply deltas (for synchronization)</p> </li> <li> <p> Interpolatable</p> <p><code>__interpolate__(self, other: Self, t: float) -&gt; Self</code></p> <p>Blend between two instances (for smooth transitions)</p> </li> </ul>"},{"location":"system/components/#mergeable-components","title":"Mergeable Components","text":"<p>The <code>Mergeable</code> protocol enables components to define how they combine during entity merges:</p> <pre><code>@component\n@dataclass(slots=True)\nclass Position:\n    x: float\n    y: float\n\n    def __merge__(self, other: \"Position\") -&gt; \"Position\":\n        \"\"\"Merge by averaging positions.\"\"\"\n        return Position(\n            x=(self.x + other.x) / 2,\n            y=(self.y + other.y) / 2\n        )\n\n@component\n@dataclass(slots=True)\nclass Memory:\n    facts: list[str]\n\n    def __merge__(self, other: \"Memory\") -&gt; \"Memory\":\n        \"\"\"Merge by combining unique facts.\"\"\"\n        return Memory(facts=list(set(self.facts + other.facts)))\n</code></pre> <p>Usage in Entity Merging:</p> <pre><code>from agentecs import NonMergeableHandling\n\n# Merge two agents - Mergeable components use __merge__\nmerged = world.merge_entities(\n    agent1,\n    agent2,\n    on_non_mergeable=NonMergeableHandling.FIRST  # Strategy for non-mergeable\n)\n</code></pre> <p>Non-Mergeable Strategies</p> <p>Components without <code>__merge__</code> use fallback strategies:</p> <ul> <li><code>ERROR</code>: Raise TypeError</li> <li><code>FIRST</code>: Keep component from first entity</li> <li><code>SECOND</code>: Keep component from second entity</li> <li><code>SKIP</code>: Exclude from merged entity</li> </ul>"},{"location":"system/components/#splittable-components","title":"Splittable Components","text":"<p>The <code>Splittable</code> protocol enables components to divide during entity splits:</p> <pre><code>@component\n@dataclass(slots=True)\nclass Credits:\n    amount: float\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[\"Credits\", \"Credits\"]:\n        \"\"\"Split credits proportionally.\"\"\"\n        left_amount = self.amount * ratio\n        right_amount = self.amount * (1 - ratio)\n        return Credits(left_amount), Credits(right_amount)\n\n@component\n@dataclass(slots=True)\nclass Task:\n    items: list[str]\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[\"Task\", \"Task\"]:\n        \"\"\"Split task list.\"\"\"\n        split_point = int(len(self.items) * ratio)\n        return Task(self.items[:split_point]), Task(self.items[split_point:])\n</code></pre> <p>Usage in Entity Splitting:</p> <pre><code>from agentecs import NonSplittableHandling\n\n# Split agent 70/30\nleft, right = world.split_entity(\n    agent,\n    ratio=0.7,\n    on_non_splittable=NonSplittableHandling.BOTH  # Clone to both\n)\n</code></pre> <p>Non-Splittable Strategies</p> <p>Components without <code>__split__</code> use fallback strategies:</p> <ul> <li><code>ERROR</code>: Raise TypeError</li> <li><code>FIRST</code>: Give component only to first entity</li> <li><code>BOTH</code>: Deep copy to both entities</li> <li><code>SKIP</code>: Exclude from both entities</li> </ul>"},{"location":"system/components/#reducible-components","title":"Reducible Components","text":"<p>The <code>Reducible</code> protocol aggregates N components into one:</p> <pre><code>@component\n@dataclass(slots=True)\nclass Vote:\n    choice: str\n    weight: float = 1.0\n\n    @classmethod\n    def __reduce_many__(cls, items: list[\"Vote\"]) -&gt; \"Vote\":\n        \"\"\"Aggregate votes by weighted majority.\"\"\"\n        weights = {}\n        for vote in items:\n            weights[vote.choice] = weights.get(vote.choice, 0) + vote.weight\n        winner = max(weights, key=weights.get)\n        return Vote(choice=winner, weight=sum(weights.values()))\n</code></pre> <p>Reducible is a Classmethod</p> <p>Unlike other protocols, <code>__reduce_many__</code> is a classmethod that takes a list of instances.</p> <p>Fallback to Merge</p> <p>If a component implements <code>Mergeable</code> but not <code>Reducible</code>, AgentECS automatically reduces via sequential pairwise merging.</p>"},{"location":"system/components/#diffable-components","title":"Diffable Components","text":"<p>Future Feature</p> <p>The <code>Diffable</code> protocol is defined but not yet used by the framework. It will enable efficient delta synchronization in distributed scenarios.</p> <pre><code>@component\n@dataclass(slots=True)\nclass BeliefState:\n    beliefs: dict[str, float]\n\n    def __diff__(self, baseline: \"BeliefState\") -&gt; \"BeliefState\":\n        \"\"\"Compute delta.\"\"\"\n        changes = {}\n        for key, value in self.beliefs.items():\n            if key not in baseline.beliefs or baseline.beliefs[key] != value:\n                changes[key] = value\n        return BeliefState(beliefs=changes)\n\n    def __apply_diff__(self, diff: \"BeliefState\") -&gt; \"BeliefState\":\n        \"\"\"Apply delta.\"\"\"\n        new_beliefs = self.beliefs.copy()\n        new_beliefs.update(diff.beliefs)\n        return BeliefState(beliefs=new_beliefs)\n</code></pre>"},{"location":"system/components/#interpolatable-components","title":"Interpolatable Components","text":"<p>The <code>Interpolatable</code> protocol enables smooth transitions between component states:</p> <pre><code>@component\n@dataclass(slots=True)\nclass Position:\n    x: float\n    y: float\n\n    def __interpolate__(self, other: \"Position\", t: float) -&gt; \"Position\":\n        \"\"\"Linearly interpolate between positions.\"\"\"\n        return Position(\n            x=self.x + (other.x - self.x) * t,\n            y=self.y + (other.y - self.y) * t\n        )\n</code></pre> <p>Use Case: Smooth Movement</p> <p>Interpolation is useful for smooth rendering, animation, or gradual state transitions in simulations.</p>"},{"location":"system/components/#global-components-singletons","title":"Global Components (Singletons)","text":"<p>AgentECS provides reserved singleton entities for global state:</p> <ul> <li><code>SystemEntity.WORLD</code>: Global world configuration and parameters</li> <li><code>SystemEntity.CLOCK</code>: Tick counter and timing information</li> </ul> <pre><code>from agentecs import SystemEntity\n\n# Set global configuration\nworld.set_singleton(GlobalConfig(temperature=0.7))\n\n# Read global configuration in a system\nconfig = world.singleton(GlobalConfig)\nif config:\n    print(f\"Temperature: {config.temperature}\")\n</code></pre> <pre><code>graph TD\n    A[World] --&gt;|SystemEntity.WORLD| B[Global Components]\n    B --&gt; C[GlobalConfig]\n    B --&gt; D[SharedResources]\n\n    A --&gt;|Regular Entities| E[Agent 1]\n    A --&gt;|Regular Entities| F[Agent 2]\n\n    E -.reads.-&gt; C\n    F -.reads.-&gt; C\n\n    style B fill:#fff3e0\n    style C fill:#ffe0b2\n    style D fill:#ffe0b2</code></pre> <p>When to Use Singletons</p> <p>Use singleton components for:</p> <ul> <li>Global configuration parameters</li> <li>Shared resources (LLM clients, databases)</li> <li>Environment state (temperature, pressure)</li> <li>Tick counters and timing</li> </ul> <p>Avoid for entity-specific data\u2014use regular components instead.</p>"},{"location":"system/components/#component-best-practices","title":"Component Best Practices","text":"<p>Keep Components Small</p> <p>Prefer many small, focused components over few large ones. Small components are more reusable and enable fine-grained system access patterns.</p> <p>Good: <code>Task</code>, <code>Context</code>, <code>TokenBudget</code>, <code>AgentTag</code></p> <p>Avoid: <code>EntityState</code> with 20 fields</p> <p>Use slots=True</p> <p>For better memory efficiency, use <code>@dataclass(slots=True)</code> or <code>@dataclass(slots=True, frozen=True)</code> for immutable components.</p> <p>Avoid Side Effects</p> <p>Component methods (like <code>__merge__</code> or <code>__split__</code>) should be pure functions with no side effects. They should not modify external state or perform I/O.</p> <p>Deterministic IDs</p> <p>Component IDs are derived from the fully qualified class name. This means:</p> <ul> <li>Same code = same IDs across different processes/nodes</li> <li>Renaming a component class changes its ID</li> <li>Moving a component to a different module changes its ID</li> </ul>"},{"location":"system/components/#see-also","title":"See Also","text":"<ul> <li>Systems: How to define logic that operates on components</li> <li>World Management: Entity lifecycle and merging/splitting</li> <li>Storage: How components are stored and queried</li> </ul>"},{"location":"system/design-philosophy/","title":"Design Philosophy","text":"<p>AgentECS applies the Entity-Component-System (ECS) paradigm to AI agent orchestration, emphasizing two key principles:</p> <ol> <li>Composition - Agents are composed of modular components that define their data and capabilities</li> <li>System-Driven Behavior - Behaviors emerge from systems operating on component patterns</li> </ol> <p>This architecture enables emergent workflows, where complex agent behaviors arise from the interaction of simple systems and components, rather than being explicitly defined.</p>"},{"location":"system/design-philosophy/#why-agentecs-for-ai-agents","title":"Why AgentECS for AI Agents?","text":"<p>Existing agent frameworks are largely either:</p> <ul> <li>Bundled agents interacting through handoffs</li> <li>Graph-based workflows connecting agentic actions</li> </ul> <p>Both approaches make strong assumptions: we know what workflow we need, and we know how it should be orchestrated.</p> <p>By contrast, AgentECS assumes we're in the early days of AI agent development. We don't yet know the best patterns, and premature optimization toward specific workflows may limit exploration.</p> <p>What AgentECS Enables:</p> <ol> <li>Flexibility - No rigid workflow graphs or agent hierarchies</li> <li>Scalability - From single agents to massive swarms</li> <li>Emergent Workflows - Behavior emerges from system interactions</li> <li>Resource Sharing - Agents can share or compete for resources (LLMs, context)</li> <li>Parallel Execution - Automatic parallelization with snapshot isolation</li> </ol>"},{"location":"system/design-philosophy/#core-architectural-principles","title":"Core Architectural Principles","text":""},{"location":"system/design-philosophy/#flexibility-over-enforcement","title":"Flexibility Over Enforcement","text":"<p>AgentECS prioritizes flexibility and rapid prototyping. Access declarations, type constraints, and validation are optional\u2014use them when they help, skip them when they don't.</p> <p>Why Optional: - Early-stage AI agent research requires experimentation - Different use cases need different levels of structure - Add rigor incrementally as patterns stabilize</p>"},{"location":"system/design-philosophy/#merge-over-prevention","title":"Merge Over Prevention","text":"<p>Instead of preventing conflicts through scheduling constraints, AgentECS embraces conflicts and resolves them through configurable merge strategies.</p> <p>Systems run in parallel, writing to isolated buffers. At group boundaries, results are merged using: - <code>LAST_WRITER_WINS</code>: Deterministic, simple, fast - <code>MERGEABLE_FIRST</code>: Use component's <code>__merge__</code> method if available - <code>ERROR</code>: Fail on conflicts (debugging mode)</p> <p>Why Merge-Based: - Enables parallelism without rigid dependency graphs - Semantic merging through component protocols preserves intent - Supports distributed execution across nodes - Reflects real-world agent coordination</p>"},{"location":"system/design-philosophy/#snapshot-isolation-with-execution-groups","title":"Snapshot Isolation with Execution Groups","text":"<p>Systems execute in groups. Within a group: - All systems see the same initial state (snapshot) - Systems run in parallel (respecting concurrency limits) - Results merge at group boundary - Next group sees merged changes</p> <p>Why Groups: - Safe parallelism without race conditions - Reasoning is local to a group, not global tick - Supports batch operations and optimizations</p>"},{"location":"system/design-philosophy/#buffered-writes","title":"Buffered Writes","text":"<p>Systems write to a buffer, not directly to storage. Changes are: - Immediately visible to the writing system (read-your-writes) - Invisible to other systems in the same group - Applied atomically at group boundaries</p> <p>Why Buffering: - Snapshot isolation (predictable system behavior) - Safe parallelization (no shared mutable state) - Testable systems (pure functions with explicit outputs)</p>"},{"location":"system/design-philosophy/#pluggable-storage-and-scheduling","title":"Pluggable Storage and Scheduling","text":"<p>Storage and execution are protocols, not implementations. Swap backends without changing logic.</p> <p>Why Pluggable: - Different workloads need different backends - Testing with mocks (no real database/API) - Gradual migration (prototype \u2192 production)</p>"},{"location":"system/design-philosophy/#optional-component-protocols","title":"Optional Component Protocols","text":"<p>Components are plain dataclasses. Advanced features are opt-in through runtime-checkable protocols:</p> <ul> <li><code>Mergeable</code>: Combine two components</li> <li><code>Splittable</code>: Divide component between entities</li> <li><code>Reducible</code>: Aggregate many components</li> <li><code>Diffable</code>: Delta operations</li> <li><code>Interpolatable</code>: Smooth transitions</li> </ul> <p>Why Optional: - Simple components stay simple (just data) - Add operations only when needed - Fallback strategies for components without protocols</p>"},{"location":"system/design-philosophy/#no-special-resources","title":"No Special Resources","text":"<p>Global state, shared resources, and configuration are components on singleton entities, not special framework constructs.</p> <p>Why Singletons as Components: - Consistent API (all state is components) - Systems declare access to singletons like any component - No special \"resource\" or \"config\" abstractions - Serializable world state</p>"},{"location":"system/design-philosophy/#generational-entity-ids","title":"Generational Entity IDs","text":"<p>Entities use generational indices to prevent stale references. Each EntityId contains a shard (for distribution), index (unique within shard), and generation (incremented on reuse).</p> <p>Why Generations: - Entity IDs can be recycled without confusion - Old references fail safely (generation mismatch) - Supports distributed allocation - Memory efficient</p>"},{"location":"system/design-philosophy/#async-first-design","title":"Async-First Design","text":"<p>Systems can be sync or async. Framework handles both seamlessly, detecting via inspection.</p> <p>Why Async-First: - AI agents are I/O-bound (LLM calls, database queries) - Maximize throughput with concurrent operations - Mix sync and async systems freely</p>"},{"location":"system/design-philosophy/#dev-mode-for-debugging","title":"Dev Mode for Debugging","text":"<p>Systems can run in dev mode for easier debugging: they run in isolation, have full access without declarations, and execute before normal systems.</p> <p>Why Dev Mode: - Simpler reasoning (no parallel interference) - Full access without declarations - Temporary debugging without changing architecture</p>"},{"location":"system/design-philosophy/#design-trade-offs","title":"Design Trade-offs","text":""},{"location":"system/design-philosophy/#flexibility-vs-structure","title":"Flexibility vs Structure","text":"<p>Trade-off: Optional access declarations mean less compile-time safety.</p> <p>Rationale: Early AI agent research needs experimentation. Add structure incrementally as patterns emerge.</p>"},{"location":"system/design-philosophy/#merge-vs-determinism","title":"Merge vs Determinism","text":"<p>Trade-off: Merge strategies can produce different results than sequential execution.</p> <p>Rationale: Parallelism is essential for scalability. Semantic merging (via <code>__merge__</code>) preserves intent better than forced sequencing.</p>"},{"location":"system/design-philosophy/#simplicity-vs-optimization","title":"Simplicity vs Optimization","text":"<p>Trade-off: Initial storage implementation prioritizes simplicity over performance.</p> <p>Rationale: Start simple, profile, optimize when needed. Premature optimization increases complexity without proven benefit.</p>"},{"location":"system/design-philosophy/#protocols-vs-base-classes","title":"Protocols vs Base Classes","text":"<p>Trade-off: Runtime protocol checking is slower than inheritance.</p> <p>Rationale: Protocols are non-invasive (components stay plain dataclasses). Runtime check overhead is negligible compared to LLM calls in agent workloads.</p>"},{"location":"system/design-philosophy/#see-also","title":"See Also","text":"<ul> <li>Architecture: Overall system architecture</li> <li>Systems: How systems implement these principles</li> <li>Components: Component protocols in detail</li> <li>Scheduling: Execution groups and merge strategies</li> <li>World Management: Entity lifecycle and operations</li> </ul>"},{"location":"system/queries/","title":"Query and Access System","text":"<p>AgentECS provides a flexible query system for finding entities by their component combinations. Systems use queries to iterate over relevant entities efficiently.</p>"},{"location":"system/queries/#overview","title":"Overview","text":"<p>Queries enable systems to find and iterate over entities that match specific component patterns:</p> <pre><code>graph LR\n    A[System Declares Access] --&gt; B{Access Level}\n    B --&gt;|Type-based| C[TypeAccess]\n    B --&gt;|Query-based| D[QueryAccess]\n    B --&gt;|Dev mode| E[AllAccess]\n\n    C --&gt; F[\"world(Task, TokenBudget)\"]\n    D --&gt; G[\"Query(Task).excluding(CompletedTag)\"]\n    E --&gt; H[\"world.has(), world.get()\"]\n\n    style C fill:#c8e6c9\n    style D fill:#fff9c4\n    style E fill:#ffcdd2</code></pre> <p>Query Characteristics:</p> <ul> <li>Lazy Evaluation: Queries return iterators, not lists\u2014entities are fetched on demand</li> <li>Type-Safe: Component types are checked at runtime</li> <li>Buffer-Aware: Queries see write buffer changes from current system</li> <li>Snapshot Isolated: Queries don't see other systems' writes until tick boundary</li> </ul>"},{"location":"system/queries/#basic-query-syntax","title":"Basic Query Syntax","text":""},{"location":"system/queries/#type-based-queries","title":"Type-Based Queries","text":"<p>Query entities by specifying component types. Results unpack to <code>(entity, component1, component2, ...)</code> tuples:</p> <p>Query Results are Copies</p> <p>All query results return deep copies of components. Mutations to <code>pos</code> or <code>vel</code> won't persist unless you write them back via <code>world[entity, Type] = value</code>.</p> <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    # Multi-component query\n    for entity, task, budget in world(Task, TokenBudget):\n        # task and budget are copies - must write back changes\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            world[entity, Task] = Task(task.description, \"completed\")\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n\n    # Single component\n    for entity, budget in world(TokenBudget):\n        if budget.available &lt; 100:\n            print(f\"Entity {entity} is low on tokens\")\n</code></pre> <p>Query multiple combinations within one system:</p> <pre><code>@system(reads=(Task, TokenBudget, Context), writes=(Task, Context))\ndef agent_workflow(world: ScopedAccess) -&gt; None:\n    # Query different combinations as needed\n    for entity, task, budget, ctx in world(Task, TokenBudget, Context):\n        # Process entities with all three components\n        pass\n\n    for entity, task, ctx in world(Task, Context):\n        # Process entities with Task + Context\n        pass\n</code></pre> <p>Query Returns What You Ask For</p> <p><code>world(A, B)</code> only returns entities that have BOTH A and B. It's an AND operation, not OR.</p>"},{"location":"system/queries/#dev-mode-access","title":"Dev Mode Access","text":"<p>Dev mode systems have unrestricted access without declaring reads/writes:</p> <pre><code>@system.dev()\ndef debug_inspector(world: ScopedAccess) -&gt; None:\n    \"\"\"Inspect all entities without restrictions.\"\"\"\n    for entity in world:\n        if world.has(entity, Position):\n            pos = world[entity, Position]\n            print(f\"Entity {entity} at ({pos.x}, {pos.y})\")\n</code></pre> <p>Dev Mode Trade-offs</p> <ul> <li>Pros: No access restrictions, flexible debugging</li> <li>Cons: Runs in isolation (cannot parallelize), no validation</li> </ul> <p>Use for debugging only\u2014add proper access patterns for production.</p>"},{"location":"system/queries/#query-result-methods","title":"Query Result Methods","text":"<p>Query results provide methods for common operations:</p> <p><code>.entities()</code> - Iterate just Entity IDs:</p> <pre><code>@system.dev()\ndef count_entities(world: ScopedAccess) -&gt; None:\n    # Skip component unpacking, just get IDs\n    agent_ids = list(world(Position, AgentTag).entities())\n    print(f\"Found {len(agent_ids)} agents\")\n</code></pre> <p><code>len()</code> - Count matches:</p> <pre><code>@system.dev()\ndef stats(world: ScopedAccess) -&gt; None:\n    moving_count = len(world(Position, Velocity))\n    total_count = len(world(Position))\n    print(f\"{moving_count}/{total_count} entities moving\")\n</code></pre> <p>len() Consumes Iterator</p> <p>Calling <code>len()</code> iterates through all matches. If you need both count and entities, collect to a list first:</p> <pre><code>entities = list(world(Position, Velocity))\ncount = len(entities)\n</code></pre>"},{"location":"system/queries/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"system/queries/#query-objects-with-having-and-excluding","title":"Query Objects with having() and excluding()","text":"<p>Use <code>Query</code> objects for fine-grained filtering:</p> <pre><code>from agentecs import Query\n\n@system(\n    reads=Query(Position, Velocity).having(ActiveTag).excluding(FrozenTag),\n    writes=Query(Position),\n)\ndef active_movement(world: ScopedAccess) -&gt; None:\n    \"\"\"Move entities that are active but not frozen.\"\"\"\n    # Query returns entities with Position, Velocity, ActiveTag, but NOT FrozenTag\n    for entity, pos, vel, active in world(Position, Velocity, ActiveTag):\n        world[entity, Position] = Position(pos.x + vel.dx, pos.y + vel.dy)\n</code></pre> <p>Combining multiple filters:</p> <pre><code>@system(\n    reads=Query(Position, Health)\n        .having(EnemyTag)\n        .excluding(DeadTag, InvulnerableTag),\n    writes=Query(Health).having(EnemyTag),\n)\ndef damage_living_enemies(world: ScopedAccess) -&gt; None:\n    \"\"\"Damage enemies that are alive and vulnerable.\"\"\"\n    for entity, pos, health, enemy in world(Position, Health, EnemyTag):\n        world[entity, Health] = Health(health.hp - 10, health.max_hp)\n</code></pre> <p>Excluding vs. Runtime Checks</p> <p><code>.excluding()</code> filters at the storage level, avoiding unnecessary component fetches:</p> <pre><code># Efficient - excludes at storage level\n@system(reads=Query(Position).excluding(Frozen))\n\n# Less efficient - checks every Position entity\n@system(reads=(Position,))\ndef move(world):\n    for entity, pos in world(Position):\n        if not world.has(entity, Frozen):  # Runtime check\n            ...\n</code></pre> <p>Query Methods are Immutable</p> <p><code>.having()</code> and <code>.excluding()</code> return new Query objects:</p> <pre><code>base = Query(Position)\nwith_vel = base.having(Velocity)  # New query\n# base is still Query(Position)\n</code></pre>"},{"location":"system/queries/#archetype-matching","title":"Archetype Matching","text":"<p>Query objects can test if an archetype (set of component types) matches:</p> <pre><code>from agentecs import Query\n\n# Define query\nq = Query(Position, Velocity).having(Health).excluding(FrozenTag)\n\n# Test archetypes\narchetype1 = frozenset({Position, Velocity, Health})\narchetype2 = frozenset({Position, Velocity, Health, FrozenTag})\n\nprint(q.matches_archetype(archetype1))  # True\nprint(q.matches_archetype(archetype2))  # False (has FrozenTag)\n</code></pre> <p>Used for Optimization</p> <p>Archetype matching is used internally for query disjointness detection. Future archetypal storage backends will use this for O(matched entities) queries.</p>"},{"location":"system/queries/#field-level-filtering-future","title":"Field-Level Filtering (Future)","text":"<p>Future Feature</p> <p>Field-level filtering is planned. Currently, filter at query time:</p> <pre><code>@system(reads=(Position,), writes=())\ndef entities_past_x100(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        if pos.x &gt; 100:\n            # Process entity\n            pass\n</code></pre>"},{"location":"system/queries/#performance-considerations","title":"Performance Considerations","text":"<p>Narrow Your Queries</p> <p>More component types = fewer matches = faster:</p> <ul> <li><code>world(Position)</code> \u2192 Many matches</li> <li><code>world(Position, Velocity)</code> \u2192 Fewer matches</li> <li><code>world(Position, Velocity, AIAgent, Health)</code> \u2192 Very few matches</li> </ul> <p>Avoid Materializing Large Results</p> <p>Queries are lazy iterators. Don't collect to lists unnecessarily:</p> <pre><code># Good - processes one at a time\nfor entity, pos in world(Position):\n    process(entity, pos)\n\n# Avoid - materializes all at once\nall_entities = list(world(Position))\nfor entity, pos in all_entities:\n    process(entity, pos)\n</code></pre>"},{"location":"system/queries/#query-disjointness-and-parallelization","title":"Query Disjointness and Parallelization","text":"<p>The scheduler uses query disjointness to enable parallelization:</p> <pre><code>graph TD\n    A[\"System A&lt;br/&gt;Query(Position).having(PlayerTag)\"] -.-&gt;|disjoint| B[\"System B&lt;br/&gt;Query(Position).having(EnemyTag)\"]\n    A -.-&gt;|can parallelize| B\n\n    C[\"System C&lt;br/&gt;Position + Velocity\"] -.-&gt;|overlapping| D[\"System D&lt;br/&gt;Position + Health\"]\n    C -.-&gt;|sequential| D\n\n    style A fill:#c8e6c9\n    style B fill:#c8e6c9\n    style C fill:#fff9c4\n    style D fill:#fff9c4</code></pre> <p>How Disjointness Works:</p> <p>Two queries are disjoint if they can never match the same entity:</p> <pre><code># Disjoint - can parallelize even though both write Position\n@system(writes=Query(Position).having(PlayerTag))\n@system(writes=Query(Position).having(EnemyTag))\n# PlayerTag and EnemyTag are mutually exclusive\n\n# Overlapping - runs sequentially\n@system(writes=(Position,))  # All Position entities\n@system(writes=(Position,))  # All Position entities\n</code></pre> <p>Conservative Analysis</p> <p>The scheduler assumes queries overlap unless it can prove they're disjoint.</p>"},{"location":"system/queries/#direct-component-access","title":"Direct Component Access","text":"<p>Beyond queries, <code>ScopedAccess</code> provides direct component access:</p> <pre><code>@system.dev()\ndef direct_access(world: ScopedAccess) -&gt; None:\n    entity = some_entity_id\n\n    # Get component\n    pos = world[entity, Position]\n\n    # Set component (buffered)\n    world[entity, Position] = Position(10, 20)\n\n    # Delete component (buffered)\n    del world[entity, Velocity]\n\n    # Check membership\n    if (entity, Health) in world:\n        print(\"Has Health\")\n\n    # Has component (alternative)\n    if world.has(entity, Position):\n        print(\"Has Position\")\n</code></pre> <p>EntityHandle for repeated access:</p> <pre><code>@system.dev()\ndef entity_handle_usage(world: ScopedAccess) -&gt; None:\n    e = world.entity(some_entity_id)\n\n    # Dict-style operations\n    e[Position] = Position(5, 5)\n    pos = e[Position]\n    del e[Velocity]\n\n    if Health in e:\n        print(\"Has health\")\n</code></pre> <p>When to Use EntityHandle</p> <p>Use <code>EntityHandle</code> when accessing multiple components on the same entity. It's more ergonomic than repeated <code>world[entity, Type]</code> calls.</p>"},{"location":"system/queries/#access-control","title":"Access Control","text":"<p>AgentECS enforces access patterns at runtime:</p> <pre><code>@system(reads=(Position,), writes=(Velocity,))\ndef illegal_access(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        # This will raise AccessViolationError!\n        health = world[entity, Health]  # Health not in reads\n</code></pre> <p>Access Violations</p> <p>Accessing undeclared component types raises <code>AccessViolationError</code> (except in dev mode). This provides runtime validation and helps document system dependencies.</p>"},{"location":"system/queries/#see-also","title":"See Also","text":"<ul> <li>Systems: How to declare and use queries in systems</li> <li>World Management: Entity and component lifecycle</li> <li>Scheduling: How snapshot isolation and merge strategies work</li> <li>Storage: How queries are implemented at the storage level</li> </ul>"},{"location":"system/roadmap/","title":"Roadmap","text":""},{"location":"system/roadmap/#current-status-v010","title":"Current Status (v0.1.0)","text":"<p>Core ECS implementation:</p> <ul> <li>Entity identity with generational indices</li> <li>Component registry and decorator</li> <li>System decorator with access control</li> <li>World coordination and scoped access</li> <li>Local storage backend</li> <li>Basic parallel scheduler</li> <li>Async-first architecture</li> <li>LLM and vector database integrations</li> </ul>"},{"location":"system/roadmap/#roadmap_1","title":"Roadmap","text":""},{"location":"system/roadmap/#advanced-scheduling","title":"Advanced Scheduling","text":"<ul> <li>Frequency-based system execution</li> <li>Dependency-based execution</li> <li>Learnable scheduler optimization (context efficiency and cache-awareness)</li> </ul>"},{"location":"system/roadmap/#standard-library-systems","title":"Standard Library systems","text":"<ul> <li>Roles, Planning, and Memory</li> <li>Task management systems</li> <li>Context management systems</li> <li> </li> </ul>"},{"location":"system/roadmap/#tool-use-mcp-and-a2a-protocol-systems","title":"Tool use, MCP and A2A protocol systems","text":""},{"location":"system/roadmap/#component-operations","title":"Component Operations","text":"<ul> <li>Shared and owned component management</li> <li>Standard library contains resource allocation mechanisms (queues, bidding)</li> </ul>"},{"location":"system/roadmap/#storage-backend","title":"Storage Backend","text":"<ul> <li>Archetypal storage for cache-efficient queries</li> <li>Serialization and persistence</li> <li>Cross-process storage (Redis, etc.)</li> </ul>"},{"location":"system/roadmap/#external-integrations","title":"External Integrations","text":"<ul> <li>MCP (Model Context Protocol) adapter</li> <li>A2A (Agent-to-Agent) protocol support</li> </ul>"},{"location":"system/roadmap/#long-term","title":"Long Term","text":""},{"location":"system/roadmap/#distributed-scaling","title":"Distributed Scaling","text":"<ul> <li>Multi-node execution</li> <li>Shard-based entity distribution</li> <li>Cross-shard queries</li> <li>Consistency models (eventual/strong)</li> <li>Network communication layer</li> </ul>"},{"location":"system/roadmap/#rust-backend","title":"Rust Backend","text":"<ul> <li>PyO3 bindings for performance-critical operations</li> <li>Rust storage implementation</li> <li>Rust query engine</li> <li>Hybrid Python/Rust architecture</li> </ul>"},{"location":"system/roadmap/#research-features","title":"Research Features","text":"<ul> <li>Topology components (spatial, graph-based)</li> <li>Local parameter systems (proximity effects)</li> <li>Information aggregation mechanisms (voting, consensus)</li> <li>Contested resource management</li> <li>Agent merging/splitting research</li> </ul>"},{"location":"system/scheduling/","title":"Scheduling","text":"<p>Schedulers orchestrate system execution, determining which systems run, in what order, and how their results are merged. AgentECS provides a pluggable scheduling architecture with snapshot isolation and configurable merge strategies.</p>"},{"location":"system/scheduling/#overview","title":"Overview","text":"<p>The scheduler is the brain of AgentECS execution. It manages execution groups, handles parallelism, and merges results using configurable strategies.</p> <p>Scheduler Responsibilities:</p> <ul> <li>System Registration: Collect system descriptors as they're registered</li> <li>Execution Planning: Build execution groups (via ExecutionGroupBuilder)</li> <li>Execution Orchestration: Run systems (sequentially or in parallel)</li> <li>Result Merging: Combine results using configured merge strategy</li> <li>Result Application: Apply changes to storage at group boundaries</li> </ul> <pre><code>graph TD\n    A[World.register_system] --&gt;|delegates to| B[Scheduler]\n    B --&gt;|stores| C[System Descriptors]\n\n    D[World.tick_async] --&gt;|delegates to| B\n    B --&gt;|calls| E[ExecutionGroupBuilder]\n    E --&gt;|builds| F[Execution Plan]\n\n    F --&gt; G[Execute Groups]\n    G --&gt;|Group 1| H[Dev Systems - isolated]\n    G --&gt;|Group 2| I[Normal Systems - parallel]\n\n    I --&gt; J[Merge Results]\n    J --&gt;|LastWriterWins| K[Apply to Storage]\n\n    style B fill:#ffb74d\n    style E fill:#ba68c8\n    style J fill:#81c784</code></pre>"},{"location":"system/scheduling/#core-concepts","title":"Core Concepts","text":""},{"location":"system/scheduling/#snapshot-isolation","title":"Snapshot Isolation","text":"<p>All systems within an execution group see the same initial state. Changes are buffered during execution and applied at group boundaries.</p> <pre><code># Both systems see Counter(0), even though they both write to it\n@system(reads=(Counter,), writes=(Counter,))\ndef add_one(access):\n    for e, c in access(Counter):\n        access[e, Counter] = Counter(c.value + 1)  # Sees 0, writes 1\n\n@system(reads=(Counter,), writes=(Counter,))\ndef add_ten(access):\n    for e, c in access(Counter):\n        access[e, Counter] = Counter(c.value + 10)  # Sees 0, writes 10\n\n# After tick: Counter = 10 (LastWriterWins, add_ten registered second)\n</code></pre>"},{"location":"system/scheduling/#merge-strategies","title":"Merge Strategies","text":"<p>When multiple systems write to the same (entity, component), the merge strategy determines the final value:</p> Strategy Behavior Use Case <code>LAST_WRITER_WINS</code> Later system (by registration) overwrites Default, simple, deterministic <code>MERGEABLE_FIRST</code> Use <code>__merge__</code> if available, else overwrite Semantic merging (counters, aggregations) <code>ERROR</code> Raise <code>ConflictError</code> on conflict Debugging, catching unintended overwrites <pre><code>from agentecs import World, MergeStrategy, SchedulerConfig\nfrom agentecs.scheduling import SimpleScheduler\n\n# Configure merge strategy\nworld = World(\n    execution=SimpleScheduler(\n        config=SchedulerConfig(merge_strategy=MergeStrategy.MERGEABLE_FIRST)\n    )\n)\n</code></pre>"},{"location":"system/scheduling/#execution-groups","title":"Execution Groups","text":"<p>Systems are organized into execution groups. Groups execute sequentially; systems within groups execute in parallel.</p> <pre><code>graph LR\n    subgraph \"Group 1 (Dev)\"\n        A[debug_system]\n    end\n    subgraph \"Group 2 (Normal)\"\n        B[movement]\n        C[damage]\n        D[render]\n    end\n\n    A --&gt;|then| B\n    B -.parallel.- C\n    C -.parallel.- D</code></pre> <p>Default Grouping (SingleGroupBuilder):</p> <ul> <li>Dev mode systems (<code>@system.dev()</code>) each get their own group (run alone)</li> <li>All other systems go in one group (run in parallel)</li> </ul>"},{"location":"system/scheduling/#simplescheduler","title":"SimpleScheduler","text":"<p>The primary scheduler with parallel execution and configurable behavior.</p> <pre><code>from agentecs import World, SchedulerConfig, MergeStrategy\nfrom agentecs.scheduling import SimpleScheduler\n\n# Default configuration\nworld = World(execution=SimpleScheduler())\n\n# Full configuration\nworld = World(\n    execution=SimpleScheduler(\n        config=SchedulerConfig(\n            merge_strategy=MergeStrategy.LAST_WRITER_WINS,\n            max_concurrent=10,  # Limit parallel systems\n            retry_policy=RetryPolicy(max_attempts=3)\n        )\n    )\n)\n</code></pre>"},{"location":"system/scheduling/#configuration-options","title":"Configuration Options","text":""},{"location":"system/scheduling/#merge-strategy","title":"Merge Strategy","text":"<pre><code>from agentecs import MergeStrategy, SchedulerConfig\n\n# Default: later registration wins\nconfig = SchedulerConfig(merge_strategy=MergeStrategy.LAST_WRITER_WINS)\n\n# Use Mergeable protocol when available\nconfig = SchedulerConfig(merge_strategy=MergeStrategy.MERGEABLE_FIRST)\n\n# Error on conflicts (useful for debugging)\nconfig = SchedulerConfig(merge_strategy=MergeStrategy.ERROR)\n</code></pre>"},{"location":"system/scheduling/#concurrency-limiting","title":"Concurrency Limiting","text":"<p>Useful for systems that call external APIs with rate limits:</p> <pre><code># Limit to 5 concurrent system executions\nconfig = SchedulerConfig(max_concurrent=5)\n</code></pre>"},{"location":"system/scheduling/#retry-policy","title":"Retry Policy","text":"<p>Handle transient failures (e.g., API timeouts):</p> <pre><code>from agentecs.scheduling import RetryPolicy\n\nconfig = SchedulerConfig(\n    retry_policy=RetryPolicy(\n        max_attempts=3,\n        backoff=\"exponential\",  # or \"linear\", \"none\"\n        base_delay=0.1,\n        on_exhausted=\"skip\"  # or \"fail\"\n    )\n)\n</code></pre>"},{"location":"system/scheduling/#sequentialscheduler","title":"SequentialScheduler","text":"<p>Alias for <code>SimpleScheduler</code> with <code>max_concurrent=1</code>. Useful for debugging.</p> <pre><code>from agentecs.scheduling import SequentialScheduler\n\n# These are equivalent:\nworld = World(execution=SequentialScheduler())\nworld = World(execution=SimpleScheduler(config=SchedulerConfig(max_concurrent=1)))\n</code></pre>"},{"location":"system/scheduling/#executiongroupbuilder","title":"ExecutionGroupBuilder","text":"<p>The extension point for custom grouping strategies. Implement this protocol to control how systems are grouped.</p> <pre><code>from agentecs.scheduling import ExecutionGroupBuilder, ExecutionGroup, ExecutionPlan\nfrom agentecs.core.system import SystemDescriptor\n\nclass CustomGroupBuilder:\n    \"\"\"Example: put each system in its own group (fully sequential).\"\"\"\n\n    def build(self, systems: list[SystemDescriptor]) -&gt; ExecutionPlan:\n        return [ExecutionGroup(systems=[s]) for s in systems]\n\n# Use custom builder\nworld = World(\n    execution=SimpleScheduler(group_builder=CustomGroupBuilder())\n)\n</code></pre>"},{"location":"system/scheduling/#built-in-builders","title":"Built-in Builders","text":"<p>SingleGroupBuilder (default): All normal systems parallel, dev systems isolated.</p> <pre><code>from agentecs.scheduling import SingleGroupBuilder\n\nbuilder = SingleGroupBuilder()\n# Dev systems \u2192 individual groups (run first, alone)\n# Normal systems \u2192 one group (run in parallel)\n</code></pre>"},{"location":"system/scheduling/#future-builders-planned","title":"Future Builders (Planned)","text":"Builder Purpose <code>DependencyGroupBuilder</code> Groups based on <code>depends_on</code> declarations <code>FrequencyGroupBuilder</code> Groups based on tick frequency <code>ConditionGroupBuilder</code> Groups based on runtime conditions"},{"location":"system/scheduling/#system-access-patterns","title":"System Access Patterns","text":""},{"location":"system/scheduling/#optional-declarations","title":"Optional Declarations","text":"<p>Access declarations are optional. Systems without declarations have full access:</p> <pre><code># Full access, runs in parallel with others\n@system()\ndef full_access_system(access):\n    # Can read/write any component\n    pass\n\n# Declared access, validated at runtime\n@system(reads=(Position,), writes=(Velocity,))\ndef movement(access):\n    pass\n\n# Dev mode: full access AND runs in isolation\n@system.dev()\ndef debug_system(access):\n    pass\n</code></pre> <p>When to Declare Access</p> <ul> <li>Always declare when you want validation and documentation</li> <li>Skip declarations for quick prototyping or simple scripts</li> <li>Use dev mode when debugging (runs alone, easier to reason about)</li> </ul>"},{"location":"system/scheduling/#dev-mode-isolation","title":"Dev Mode Isolation","text":"<p>Dev mode systems run in their own execution group, seeing all previous changes:</p> <pre><code>@system.dev()\ndef debug_system(access):\n    # Runs alone, sees all changes from previous groups\n    pass\n\n@system(reads=(Counter,), writes=(Counter,))\ndef normal_system(access):\n    # Runs in parallel with other normal systems\n    pass\n\n# Execution order:\n# 1. debug_system (alone) \u2192 apply results\n# 2. normal_system (parallel with others) \u2192 apply results\n</code></pre>"},{"location":"system/scheduling/#workflow-inside-tick_async","title":"Workflow: Inside tick_async()","text":"<pre><code>sequenceDiagram\n    participant W as World\n    participant S as Scheduler\n    participant B as GroupBuilder\n    participant Sys as Systems\n\n    W-&gt;&gt;S: tick_async()\n    S-&gt;&gt;B: build(systems)\n    B--&gt;&gt;S: ExecutionPlan\n\n    loop Each ExecutionGroup\n        S-&gt;&gt;Sys: Execute in parallel\n        Sys--&gt;&gt;S: SystemResults\n        S-&gt;&gt;S: Merge results (strategy)\n        S-&gt;&gt;W: apply_result_async()\n    end</code></pre> <p>Step by step:</p> <ol> <li>Build Plan: GroupBuilder creates ExecutionPlan from registered systems</li> <li>Execute Groups: For each group:</li> <li>Execute all systems in parallel (with concurrency limit)</li> <li>Retry failed systems per RetryPolicy</li> <li>Merge results using MergeStrategy</li> <li>Apply merged result to storage</li> <li>Next Group: Subsequent groups see applied changes</li> </ol>"},{"location":"system/scheduling/#distributed-scheduling-future","title":"Distributed Scheduling (Future)","text":"<p>AgentECS is designed to support distributed execution:</p>"},{"location":"system/scheduling/#executionbackend-protocol","title":"ExecutionBackend Protocol","text":"<pre><code>class ExecutionBackend(Protocol):\n    async def execute_group(\n        self, systems: list[SystemDescriptor], world: World\n    ) -&gt; list[SystemResult]:\n        \"\"\"Execute group across nodes.\"\"\"\n        ...\n</code></pre> <p>Future backends:</p> <ul> <li>Ray Backend: Distribute across Ray cluster</li> <li>Dask Backend: Use Dask for task scheduling</li> </ul>"},{"location":"system/scheduling/#design-considerations","title":"Design Considerations","text":"<p>With merge-based conflict resolution (rather than conflict prevention), distributed execution becomes feasible:</p> <ul> <li>Systems execute independently on different nodes</li> <li>Results merge at coordinator</li> <li>Conflicts resolved by strategy, not prevented</li> </ul> <p>Distributed is Future Work</p> <p>Current focus is local execution. The architecture supports distributed backends, but implementations are not yet built.</p>"},{"location":"system/scheduling/#best-practices","title":"Best Practices","text":"<p>Start Simple</p> <p>Begin with <code>SimpleScheduler()</code> defaults. Only tune when profiling shows need.</p> <p>Use Merge Strategies Wisely</p> <ul> <li><code>LAST_WRITER_WINS</code>: Simple, deterministic, good default</li> <li><code>MERGEABLE_FIRST</code>: When you have semantic merge logic</li> <li><code>ERROR</code>: During development to catch unintended overlaps</li> </ul> <p>Dev Mode for Debugging</p> <p>Use <code>@system.dev()</code> when debugging. It runs in isolation, making it easier to reason about state.</p> <p>Concurrency Limits for APIs</p> <p>If systems call external APIs, use <code>max_concurrent</code> to respect rate limits: <pre><code>config = SchedulerConfig(max_concurrent=5)\n</code></pre></p> <p>Profile Before Optimizing</p> <p>Parallelization has overhead. Profile to verify speedup: <pre><code>import time\nstart = time.time()\nawait world.tick_async()\nprint(f\"Tick time: {time.time() - start:.3f}s\")\n</code></pre></p>"},{"location":"system/scheduling/#see-also","title":"See Also","text":"<ul> <li>Systems: How to declare systems with access patterns</li> <li>World Management: How world delegates to scheduler</li> <li>Queries: Query patterns and filtering</li> <li>Storage: How storage backends interact with scheduling</li> </ul>"},{"location":"system/storage/","title":"Storage","text":"<p>Storage backends provide the persistence layer for entities and components in AgentECS. The pluggable storage architecture enables swapping implementations from simple in-memory storage to distributed, persistent, or specialized backends.</p>"},{"location":"system/storage/#overview","title":"Overview","text":"<p>The storage layer abstracts how entities and components are stored, queried, and updated. This separation from World and Scheduler enables:</p> <ul> <li>Swappable Backends: Change storage without touching game logic</li> <li>Testing: Mock storage for unit tests</li> <li>Optimization: Specialized storage for different workloads</li> <li>Distribution: Shard entities across nodes for scale</li> </ul> <pre><code>graph TD\n    A[World] --&gt;|delegates to| B[Storage Protocol]\n    B -.implements.-&gt; C[LocalStorage]\n    B -.implements.-&gt; D[DistributedStorage Future]\n    B -.implements.-&gt; E[PersistentStorage Future]\n\n    C --&gt;|uses| F[EntityAllocator]\n    C --&gt;|stores in| G[dict entity, components]\n\n    D --&gt;|shards across| H[Multiple Nodes]\n    E --&gt;|persists to| I[Database]\n\n    style B fill:#ffb74d\n    style C fill:#81c784\n    style D fill:#e0e0e0\n    style E fill:#e0e0e0</code></pre> <p>Storage Responsibilities:</p> <ul> <li>Entity Lifecycle: Create, destroy, check existence</li> <li>Component Access: Get, set, remove, check presence</li> <li>Queries: Find entities by component types</li> <li>Batch Operations: Apply multiple updates atomically</li> <li>Serialization: Snapshot and restore world state</li> </ul>"},{"location":"system/storage/#storage-interface","title":"Storage Interface","text":"<p>The <code>Storage</code> protocol defines the contract all storage backends must implement:</p>"},{"location":"system/storage/#entity-lifecycle-methods","title":"Entity Lifecycle Methods","text":"<p>create_entity() \u2192 EntityId</p> <p>Allocate a new unique entity ID:</p> <pre><code>entity = storage.create_entity()\n# Returns: EntityId(shard=0, index=1, generation=0)\n</code></pre> <p>destroy_entity(entity: EntityId) \u2192 None</p> <p>Remove an entity and all its components:</p> <pre><code>storage.destroy_entity(entity)\n# Entity no longer exists, components deleted\n</code></pre> <p>entity_exists(entity: EntityId) \u2192 bool</p> <p>Check if an entity is alive:</p> <pre><code>if storage.entity_exists(entity):\n    print(\"Entity is alive\")\n</code></pre> <p>Generational Indices</p> <p>EntityIds include a generation counter. Even if an ID is recycled, the generation ensures old references don't accidentally access new entities.</p> <p>all_entities() \u2192 Iterator[EntityId]</p> <p>Iterate over all living entities:</p> <pre><code>for entity in storage.all_entities():\n    process(entity)\n</code></pre>"},{"location":"system/storage/#component-access-methods","title":"Component Access Methods","text":"<p>get_component(entity: EntityId, component_type: type[T]) \u2192 T | None</p> <p>Retrieve a component from an entity:</p> <pre><code>pos = storage.get_component(entity, Position)\nif pos:\n    print(f\"Position: ({pos.x}, {pos.y})\")\n</code></pre> <p>set_component(entity: EntityId, component: Any) \u2192 None</p> <p>Add or update a component on an entity:</p> <pre><code>storage.set_component(entity, Position(10, 20))\n# Component type inferred from instance\n</code></pre> <p>remove_component(entity: EntityId, component_type: type) \u2192 bool</p> <p>Delete a component from an entity:</p> <pre><code>removed = storage.remove_component(entity, Velocity)\nif removed:\n    print(\"Velocity component removed\")\n</code></pre> <p>has_component(entity: EntityId, component_type: type) \u2192 bool</p> <p>Check if entity has a specific component:</p> <pre><code>if storage.has_component(entity, Health):\n    print(\"Entity has Health\")\n</code></pre> <p>get_component_types(entity: EntityId) \u2192 frozenset[type]</p> <p>Get all component types on an entity:</p> <pre><code>types = storage.get_component_types(entity)\nprint(f\"Entity has: {[t.__name__ for t in types]}\")\n</code></pre>"},{"location":"system/storage/#query-methods","title":"Query Methods","text":"<p>query(*component_types: type) \u2192 Iterator[tuple[EntityId, tuple[Any, ...]]]</p> <p>Find entities with all specified components:</p> <pre><code># Find entities with Position AND Velocity\nfor entity, (pos, vel) in storage.query(Position, Velocity):\n    print(f\"Entity {entity} at ({pos.x}, {pos.y})\")\n</code></pre> <p>Query Returns Tuples</p> <p><code>query()</code> returns <code>(entity, (comp1, comp2, ...))</code>. Components are in the same order as the query types.</p> <p>query_single(component_type: type[T]) \u2192 Iterator[tuple[EntityId, T]]</p> <p>Optimized query for a single component type:</p> <pre><code># Find all entities with Health\nfor entity, health in storage.query_single(Health):\n    if health.hp &lt; 10:\n        print(f\"Entity {entity} is low health\")\n</code></pre>"},{"location":"system/storage/#batch-update-methods","title":"Batch Update Methods","text":"<p>apply_updates(...) \u2192 list[EntityId]</p> <p>Apply multiple changes atomically:</p> <pre><code>new_entities = storage.apply_updates(\n    updates={entity1: {Position: Position(5, 5)}},\n    inserts={entity2: [Velocity(1, 0)]},\n    removes={entity3: [Health]},\n    destroys=[entity4]\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>updates</code>: Modify existing components <code>{entity: {Type: component}}</code></li> <li><code>inserts</code>: Add new components <code>{entity: [component, ...]}</code></li> <li><code>removes</code>: Delete components <code>{entity: [Type, ...]}</code></li> <li><code>destroys</code>: Delete entities <code>[entity, ...]</code></li> </ul> <p>Returns: List of newly created EntityIds (for spawns)</p> <p>Atomic Application</p> <p>All changes in a single <code>apply_updates</code> call are applied atomically. Either all succeed or none do (implementation-dependent).</p>"},{"location":"system/storage/#serialization-methods","title":"Serialization Methods","text":"<p>snapshot() \u2192 bytes</p> <p>Serialize entire storage state:</p> <pre><code>data = storage.snapshot()\nwith open(\"save.bin\", \"wb\") as f:\n    f.write(data)\n</code></pre> <p>restore(data: bytes) \u2192 None</p> <p>Restore from snapshot:</p> <pre><code>with open(\"save.bin\", \"rb\") as f:\n    data = f.read()\nstorage.restore(data)\n</code></pre> <p>Snapshot Format is Implementation-Specific</p> <p>Different storage backends may use different serialization formats. Snapshots are not portable across implementations.</p>"},{"location":"system/storage/#async-variants","title":"Async Variants","text":"<p>For distributed or remote storage, async variants are provided:</p> <pre><code># Async query\nasync for entity, (pos, vel) in storage.query_async(Position, Velocity):\n    process(entity, pos, vel)\n\n# Async get\ncomponent = await storage.get_component_async(entity, Position)\n\n# Async apply\nnew_entities = await storage.apply_updates_async(updates, inserts, removes, destroys)\n</code></pre> <p>Local vs Remote Storage</p> <p>LocalStorage provides both sync and async methods (async wraps sync). Remote storage implementations may only support async methods for network I/O.</p>"},{"location":"system/storage/#entity-allocator","title":"Entity Allocator","text":"<p>The EntityAllocator manages entity ID generation and recycling:</p>"},{"location":"system/storage/#generational-indices","title":"Generational Indices","text":"<p>EntityIds use a three-part structure:</p> <pre><code>@dataclass(frozen=True)\nclass EntityId:\n    shard: int        # Which shard owns this entity (0 for local)\n    index: int        # Unique index within shard\n    generation: int   # Incremented on reuse\n</code></pre> <pre><code>sequenceDiagram\n    participant User\n    participant Allocator\n    participant FreeList\n\n    User-&gt;&gt;Allocator: allocate()\n    Allocator-&gt;&gt;Allocator: Check free list\n    alt Free list empty\n        Allocator-&gt;&gt;Allocator: index = next_index++\n        Allocator--&gt;&gt;User: EntityId(0, index, 0)\n    else Free list has IDs\n        Allocator-&gt;&gt;FreeList: Pop ID\n        FreeList--&gt;&gt;Allocator: (index, gen)\n        Allocator-&gt;&gt;Allocator: Increment generation\n        Allocator--&gt;&gt;User: EntityId(0, index, gen+1)\n    end\n\n    User-&gt;&gt;Allocator: deallocate(entity)\n    Allocator-&gt;&gt;FreeList: Push (index, gen)</code></pre> <p>Prevents Stale References</p> <p>If you hold an <code>EntityId</code> and the entity is destroyed then recreated, the generation counter ensures your old ID won't accidentally access the new entity:</p> <pre><code>entity1 = allocator.allocate()  # EntityId(0, 1, 0)\nallocator.deallocate(entity1)\n\nentity2 = allocator.allocate()  # EntityId(0, 1, 1)  \u2190 Same index, different generation\n# entity1 != entity2 (generation differs)\n</code></pre>"},{"location":"system/storage/#allocator-methods","title":"Allocator Methods","text":"<p>allocate() \u2192 EntityId</p> <p>Allocate a new entity ID:</p> <pre><code>entity = allocator.allocate()\n</code></pre> <p>deallocate(entity: EntityId) \u2192 None</p> <p>Return entity ID to free list:</p> <pre><code>allocator.deallocate(entity)\n# ID can be recycled with incremented generation\n</code></pre> <p>is_alive(entity: EntityId) \u2192 bool</p> <p>Check if entity ID is currently active:</p> <pre><code>if allocator.is_alive(entity):\n    # Entity exists and generation matches\n    pass\n</code></pre> <p>Liveness Check</p> <p><code>is_alive()</code> checks if the entity's generation matches the allocator's current generation for that index. Destroyed entities have mismatched generations.</p>"},{"location":"system/storage/#sharding-support","title":"Sharding Support","text":"<p>The allocator supports sharding for distributed scenarios:</p> <pre><code># Shard 0 allocator\nallocator0 = EntityAllocator(shard=0)\ne1 = allocator0.allocate()  # EntityId(0, 1, 0)\n\n# Shard 1 allocator\nallocator1 = EntityAllocator(shard=1)\ne2 = allocator1.allocate()  # EntityId(1, 1, 0)  \u2190 Different shard\n</code></pre> <p>Future: Distributed Allocation</p> <p>Shards enable partitioning entities across nodes. Each node has its own allocator with a unique shard ID, preventing ID collisions.</p>"},{"location":"system/storage/#built-in-storage-implementations","title":"Built-in Storage Implementations","text":""},{"location":"system/storage/#local-storage","title":"Local Storage","text":"<p><code>LocalStorage</code> is the default in-memory storage backend:</p> <p>Implementation:</p> <pre><code>class LocalStorage:\n    def __init__(self, shard: int = 0):\n        self._shard = shard\n        self._allocator = EntityAllocator(shard=shard)\n        self._components: dict[EntityId, dict[type, Any]] = {}\n</code></pre> <p>Data Structure:</p> <pre><code>_components = {\n    EntityId(0, 1, 0): {\n        Position: Position(10, 20),\n        Velocity: Velocity(1, 0),\n        Health: Health(100, 100)\n    },\n    EntityId(0, 2, 0): {\n        Position: Position(5, 5),\n        AgentTag: AgentTag(\"Alice\")\n    }\n}\n</code></pre> <p>Characteristics:</p> <ul> <li> <p> Simple</p> <p>Dict-based, easy to understand and debug</p> </li> <li> <p> Fast for Small Scale</p> <p>Good performance for 100s-1000s of entities</p> </li> <li> <p> High Memory</p> <p>Stores all entities in memory, no persistence</p> </li> <li> <p> O(n) Queries</p> <p>Must check every entity (no archetypal optimization)</p> </li> </ul> <p>Usage:</p> <pre><code>from agentecs import World\nfrom agentecs.storage import LocalStorage\n\n# Default (shard 0)\nworld = World()\n\n# Explicit local storage\nworld = World(storage=LocalStorage(shard=0))\n</code></pre> <p>Serialization:</p> <p>Uses <code>pickle</code> for snapshot/restore:</p> <pre><code>data = world.snapshot()  # Pickles _components dict\nworld.restore(data)      # Unpickles and restores\n</code></pre> <p>Pickle Security</p> <p>LocalStorage uses <code>pickle</code> which is not secure for untrusted data. Only restore snapshots from trusted sources.</p> <p>Performance Characteristics:</p> Operation Complexity Notes <code>create_entity()</code> O(1) Allocator amortized <code>get_component()</code> O(1) Dict lookup <code>set_component()</code> O(1) Dict insert <code>query(*types)</code> O(n\u00d7m) n=entities, m=types <code>apply_updates()</code> O(k) k=total changes <p>Optimization Opportunity</p> <p>Future: Implement archetypal storage where entities with the same component types are stored contiguously. This reduces queries from O(n\u00d7m) to O(matched entities).</p>"},{"location":"system/storage/#remote-storage-options","title":"Remote Storage Options","text":"<p>Future Feature</p> <p>Remote storage backends for distributed or persistent scenarios:</p> <p>PostgreSQL Backend:</p> <pre><code># Future API\nfrom agentecs.storage.postgres import PostgreSQLStorage\n\nstorage = PostgreSQLStorage(\n    connection_string=\"postgresql://localhost/agentecs\"\n)\nworld = World(storage=storage)\n</code></pre> <ul> <li>Persistent storage across runs</li> <li>SQL queries for analytics</li> <li>ACID transactions</li> <li>Slower than in-memory</li> </ul> <p>Redis Backend:</p> <pre><code># Future API\nfrom agentecs.storage.redis import RedisStorage\n\nstorage = RedisStorage(host=\"localhost\", port=6379)\nworld = World(storage=storage)\n</code></pre> <ul> <li>In-memory with optional persistence</li> <li>Fast read/write</li> <li>Pub/sub for distributed scenarios</li> <li>TTL for automatic cleanup</li> </ul> <p>S3/Cloud Storage:</p> <pre><code># Future API\nfrom agentecs.storage.s3 import S3Storage\n\nstorage = S3Storage(bucket=\"my-simulation-state\")\nworld = World(storage=storage)\n</code></pre> <ul> <li>Cheap persistent storage</li> <li>Good for checkpointing</li> <li>High latency (not for real-time)</li> <li>Versioning support</li> </ul>"},{"location":"system/storage/#distributed-storage","title":"Distributed Storage","text":"<p>Future Feature</p> <p>Shard entities across multiple nodes:</p> <pre><code>graph TD\n    A[Coordinator] --&gt;|manages| B[Storage Shard 0]\n    A --&gt;|manages| C[Storage Shard 1]\n    A --&gt;|manages| D[Storage Shard 2]\n\n    B --&gt;|stores| E[Entities 0-999]\n    C --&gt;|stores| F[Entities 1000-1999]\n    D --&gt;|stores| G[Entities 2000-2999]\n\n    H[System] -.queries.-&gt; B\n    H -.queries.-&gt; C\n    H -.queries.-&gt; D\n\n    style A fill:#ffb74d\n    style B fill:#81c784\n    style C fill:#81c784\n    style D fill:#81c784</code></pre> <p>Sharding Strategies:</p> <ul> <li>Hash-based: <code>shard = hash(entity) % num_shards</code></li> <li>Range-based: <code>shard = entity.index // shard_size</code></li> <li>Spatial: Entities near each other on same shard (for locality)</li> <li>Component-based: Shard by primary component type</li> </ul> <p>Challenges:</p> <ul> <li>Cross-shard queries: Entity on shard A references component from shard B</li> <li>Load balancing: Some shards may have more entities</li> <li>Consistency: Distributed transactions or eventual consistency</li> <li>Network overhead: Remote queries are slower than local</li> </ul> <p>Example API:</p> <pre><code># Future API\nfrom agentecs.storage.distributed import DistributedStorage, HashSharding\n\nstorage = DistributedStorage(\n    shards=[\n        (\"node1:5000\", 0),\n        (\"node2:5000\", 1),\n        (\"node3:5000\", 2)\n    ],\n    strategy=HashSharding()\n)\n\nworld = World(storage=storage)\n</code></pre>"},{"location":"system/storage/#archetypal-storage-optimization","title":"Archetypal Storage Optimization","text":"<p>Future Feature</p> <p>Current LocalStorage is entity-first (dict of entities). Archetypal storage is component-first:</p> <p>Entity-First (Current):</p> <pre><code>{\n    Entity1: {Position, Velocity, Health},\n    Entity2: {Position, Velocity},\n    Entity3: {Position, Health},\n}\n</code></pre> <p>Archetype-First (Future):</p> <pre><code>{\n    Archetype(Position, Velocity, Health): [Entity1],\n    Archetype(Position, Velocity): [Entity2],\n    Archetype(Position, Health): [Entity3],\n}\n</code></pre> <p>Benefits:</p> <ul> <li>O(matched) Queries: Only iterate entities with matching archetype</li> <li>Cache Locality: Components stored contiguously in memory</li> <li>Batch Operations: Process all entities with same archetype together</li> </ul> <p>Trade-offs:</p> <ul> <li>More complex implementation</li> <li>Component add/remove requires archetype change (slower)</li> <li>Memory overhead for archetype tracking</li> </ul> <p>When to Use:</p> <ul> <li>10,000+ entities</li> <li>Many entities share same component combinations</li> <li>Query-heavy workloads</li> </ul>"},{"location":"system/storage/#storage-best-practices","title":"Storage Best Practices","text":"<p>Start with LocalStorage</p> <p>Begin with LocalStorage. Only move to distributed or persistent storage when profiling shows it's necessary.</p> <p>Profile Query Patterns</p> <p>Understand your query patterns before choosing storage:</p> <ul> <li>Many queries, few updates \u2192 Archetypal storage</li> <li>Frequent component changes \u2192 Entity-first storage</li> <li>Need persistence \u2192 Database backend</li> <li>Massive scale \u2192 Distributed storage</li> </ul> <p>Beware of Cross-Shard Queries</p> <p>In distributed scenarios, queries that span shards are expensive. Design component relationships to minimize cross-shard access.</p> <p>Use Snapshots for Checkpointing</p> <p>Periodic snapshots enable:</p> <ul> <li>Crash recovery</li> <li>Debugging (rewind to previous state)</li> <li>A/B testing (fork simulation from snapshot)</li> </ul> <p>Consider Consistency Requirements</p> <p>Different storage backends offer different consistency guarantees:</p> <ul> <li>LocalStorage: Strong consistency (single node)</li> <li>Distributed: Eventual consistency (requires conflict resolution)</li> <li>Persistent: ACID transactions (slow but safe)</li> </ul>"},{"location":"system/storage/#storage-protocol-example-implementation","title":"Storage Protocol Example Implementation","text":"<p>Here's a minimal custom storage implementation:</p> <pre><code>from agentecs.storage.protocol import Storage\nfrom agentecs.core.identity import EntityId\n\nclass InMemoryStorage(Storage):\n    \"\"\"Simple in-memory storage (minimal implementation).\"\"\"\n\n    def __init__(self):\n        self._data: dict[EntityId, dict[type, Any]] = {}\n        self._next_id = 0\n\n    def create_entity(self) -&gt; EntityId:\n        entity = EntityId(0, self._next_id, 0)\n        self._next_id += 1\n        self._data[entity] = {}\n        return entity\n\n    def destroy_entity(self, entity: EntityId) -&gt; None:\n        if entity in self._data:\n            del self._data[entity]\n\n    def entity_exists(self, entity: EntityId) -&gt; bool:\n        return entity in self._data\n\n    def get_component(self, entity: EntityId, component_type: type[T]) -&gt; T | None:\n        return self._data.get(entity, {}).get(component_type)\n\n    def set_component(self, entity: EntityId, component: Any) -&gt; None:\n        if entity in self._data:\n            self._data[entity][type(component)] = component\n\n    # ... implement other protocol methods ...\n</code></pre> <p>Use custom storage:</p> <pre><code>world = World(storage=InMemoryStorage())\n</code></pre>"},{"location":"system/storage/#see-also","title":"See Also","text":"<ul> <li>World Management: How World interacts with storage</li> <li>Scheduling: How storage affects scheduling decisions</li> <li>Queries: How queries are executed against storage</li> <li>Components: What storage stores</li> </ul>"},{"location":"system/systems/","title":"Systems","text":"<p>Systems contain the logic that operates on entities with specific component combinations. While Components define what entities are, systems define how they behave.</p>"},{"location":"system/systems/#overview","title":"Overview","text":"<p>Systems are functions (or async functions) that query entities by their components and apply transformations. AgentECS uses access pattern declarations for validation and documentation, with optional declarations for flexibility.</p> <p>Key Characteristics:</p> <ul> <li>Function-Based: Systems are decorated functions, not classes</li> <li>Optional Declarations: Declare <code>reads</code> and <code>writes</code> for validation, or omit for full access</li> <li>Snapshot Isolation: Systems in the same execution group see a consistent worldview</li> <li>Async-First: Systems can be sync or async, framework handles both seamlessly</li> </ul> <pre><code>graph TD\n    A[System] --&gt;|Declares| B[reads: Task, TokenBudget]\n    A --&gt;|Declares| C[writes: Task, TokenBudget]\n    A --&gt;|Queries| D[World]\n    D --&gt;|Returns| E[Entities with Components]\n    A --&gt;|Updates| F[Write Buffer]\n    F --&gt;|Applied at| G[Group Boundary]\n\n    style A fill:#c5e1a5\n    style D fill:#e1f5fe\n    style F fill:#ffecb3</code></pre> <p>Systems are Pure (Within an Execution Group)</p> <p>Systems read from storage and write to a buffer. Changes aren't visible to other systems in the same group until the group boundary, enabling parallelization without race conditions. Subsequent groups see applied changes.</p>"},{"location":"system/systems/#basic-declaration","title":"Basic Declaration","text":"<p>Systems are defined using the <code>@system</code> decorator:</p> <pre><code>from agentecs import system, ScopedAccess\n\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    \"\"\"Process tasks using available tokens.\"\"\"\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            world[entity, Task] = Task(task.description, \"completed\")\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n</code></pre>"},{"location":"system/systems/#system-function-signature","title":"System Function Signature","text":"<p>Required Parameter: - <code>world: ScopedAccess</code> - Provides controlled access to the world</p> <p>Optional Return: - <code>None</code> - No explicit changes (use <code>world[entity, Type] = value</code>) - <code>SystemResult</code> - Explicit result object - <code>dict[EntityId, dict[type, Any]]</code> - Entity \u2192 components mapping - <code>dict[EntityId, Any]</code> - Entity \u2192 single component (type inferred) - <code>list[tuple[EntityId, Any]]</code> - List of (entity, component) pairs</p> Direct Updates (Recommended)Dict ReturnSystemResult Return <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            world[entity, Task] = Task(task.description, \"completed\")\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n</code></pre> <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; dict[EntityId, dict[type, Any]]:\n    return {\n        entity: {\n            Task: Task(task.description, \"completed\"),\n            TokenBudget: TokenBudget(budget.available - 100, budget.used + 100)\n        }\n        for entity, task, budget in world(Task, TokenBudget)\n        if task.status == \"pending\" and budget.available &gt;= 100\n    }\n</code></pre> <pre><code>from agentecs import SystemResult\n\n@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; SystemResult:\n    result = SystemResult()\n    for entity, task, budget in world(Task, TokenBudget):\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            if entity not in result.updates:\n                result.updates[entity] = {}\n            result.updates[entity][Task] = Task(task.description, \"completed\")\n            result.updates[entity][TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n    return result\n</code></pre> <p>Prefer Direct Updates</p> <p>Using <code>world[entity, Type] = value</code> is more ergonomic and readable than returning dicts or SystemResult objects. Save return values for pure systems or when you need fine-grained control.</p>"},{"location":"system/systems/#access-pattern-declaration","title":"Access Pattern Declaration","text":"<p>Systems can optionally declare which component types they read and write:</p> <pre><code>@system(\n    reads=(Task, TokenBudget, Context),  # Can read these types\n    writes=(Task, Context),              # Can write these types\n)\ndef my_system(world: ScopedAccess) -&gt; None:\n    pass\n</code></pre> <p>Access Declarations Are Optional</p> <p>For quick prototyping, omit declarations entirely:</p> <pre><code>@system()  # Full access, runs in parallel with other systems\ndef quick_prototype(world: ScopedAccess) -&gt; None:\n    # Can read/write any component\n    pass\n</code></pre> <p>When to Declare Access</p> <ul> <li>Skip declarations for quick prototyping or simple scripts</li> <li>Add declarations when you want validation and documentation</li> <li>Use dev mode when debugging (runs alone, easier to reason about)</li> </ul> <p>Write Implies Read</p> <p>If a system declares a type in <code>writes</code>, it automatically has read access to that type. You don't need to list it in both.</p>"},{"location":"system/systems/#querying-entities-and-components","title":"Querying Entities and Components","text":"<p>Systems query entities using the <code>world(ComponentType, ...)</code> syntax:</p>"},{"location":"system/systems/#query-syntax","title":"Query Syntax","text":"<p>Basic Multi-Component Query:</p> <pre><code>@system(reads=(Task, TokenBudget), writes=(Task, TokenBudget))\ndef process_tasks(world: ScopedAccess) -&gt; None:\n    # Iterate entities with BOTH Task AND TokenBudget\n    for entity, task, budget in world(Task, TokenBudget):\n        # task and budget are copies - must write back changes\n        if task.status == \"pending\" and budget.available &gt;= 100:\n            print(f\"Entity {entity} processing: {task.description}\")\n            world[entity, Task] = Task(task.description, \"completed\")\n            world[entity, TokenBudget] = TokenBudget(\n                available=budget.available - 100,\n                used=budget.used + 100\n            )\n</code></pre> <p>Single-Component Query:</p> <pre><code>@system(reads=(TokenBudget,), writes=(TokenBudget,))\ndef decay_budget(world: ScopedAccess) -&gt; None:\n    for entity, budget in world(TokenBudget):\n        world[entity, TokenBudget] = TokenBudget(\n            available=budget.available - 1,\n            used=budget.used + 1\n        )\n</code></pre> <p>Entity Handle for Repeated Access:</p> <pre><code>@system(reads=(Position, Velocity, Health), writes=(Position, Health))\ndef complex_system(world: ScopedAccess) -&gt; None:\n    for entity_id, pos in world(Position):\n        e = world.entity(entity_id)  # Get EntityHandle\n\n        # Dict-style access\n        if Velocity in e:\n            vel = e[Velocity]\n            e[Position] = Position(pos.x + vel.dx, pos.y + vel.dy)\n\n        if Health in e:\n            e[Health] = Health(e[Health].hp - 1, e[Health].max_hp)\n</code></pre> <p>Query Returns Iterator</p> <p><code>world(Type1, Type2)</code> returns a <code>QueryResult</code> that yields <code>(entity, comp1, comp2)</code> tuples. It's lazy\u2014entities are fetched on iteration.</p>"},{"location":"system/systems/#updating-components","title":"Updating Components","text":""},{"location":"system/systems/#all-reads-return-copies","title":"All Reads Return Copies","text":"<p>IMPORTANT: All component reads return deep copies, not references.</p> <pre><code>@system(reads=(Position, Velocity), writes=(Position,))\ndef movement(world: ScopedAccess) -&gt; None:\n    for entity, pos, vel in world(Position, Velocity):\n        # pos and vel are COPIES - safe to mutate\n        pos.x += vel.dx\n        pos.y += vel.dy\n        world[entity, Position] = pos  # Must write back!\n\n        # Or create new instance (same effect):\n        # world[entity, Position] = Position(pos.x + vel.dx, pos.y + vel.dy)\n</code></pre> <p>Must Write Back</p> <p>Mutations to retrieved components do NOT persist automatically. You must write back via <code>world[entity, Type] = component</code>. This applies to all reads: <code>world[entity, Type]</code>, <code>world(Type)</code> queries, and <code>world.get(entity, Type)</code>.</p> <p>Why Copies?</p> <p>Returning copies prevents accidental mutation of world state, works with any storage backend (including remote/serialized), and maintains snapshot isolation guarantees.</p>"},{"location":"system/systems/#updating-multiple-components","title":"Updating Multiple Components","text":"<p>Update multiple components on the same entity:</p> <pre><code>@system(reads=(Position, Velocity, Fuel), writes=(Position, Velocity, Fuel))\ndef movement_with_fuel(world: ScopedAccess) -&gt; None:\n    for entity, pos, vel, fuel in world(Position, Velocity, Fuel):\n        if fuel.amount &gt; 0:\n            # Update multiple components\n            world[entity, Position] = Position(pos.x + vel.dx, pos.y + vel.dy)\n            world[entity, Fuel] = Fuel(fuel.amount - 1)\n        else:\n            # Stop moving when out of fuel\n            world[entity, Velocity] = Velocity(0, 0)\n</code></pre>"},{"location":"system/systems/#updating-via-return-values","title":"Updating via Return Values","text":"<p>For pure functional systems, return changes instead of writing to world:</p> <pre><code>@system(reads=(Input,), writes=(Output,), mode=SystemMode.PURE)\ndef transform(world: ReadOnlyAccess) -&gt; dict[EntityId, dict[type, Any]]:\n    \"\"\"Pure system - must return all changes.\"\"\"\n    return {\n        entity: {Output: Output(inp.value * 2)}\n        for entity, inp in world.query(Input)\n    }\n</code></pre> <p>SystemMode.PURE</p> <p>Pure systems receive <code>ReadOnlyAccess</code> and must return all changes. They cannot use <code>world[entity, Type] = value</code>.</p>"},{"location":"system/systems/#understanding-execution-behavior","title":"Understanding Execution Behavior","text":""},{"location":"system/systems/#access-levels","title":"Access Levels","text":"<p>AgentECS provides three access levels:</p> <ul> <li> <p> Standard Access</p> <pre><code>@system(reads=(A, B), writes=(C,))\n</code></pre> <p>Type-level access. System can read A, B and write C. Runs in parallel with other systems.</p> </li> <li> <p> Full Access (Optional Declarations)</p> <pre><code>@system()  # No reads/writes declared\n</code></pre> <p>Unrestricted access. Still runs in parallel with other systems.</p> </li> <li> <p> Dev Mode</p> <pre><code>@system.dev()\n</code></pre> <p>Unrestricted access AND runs in isolation. Use for debugging.</p> </li> </ul> <p>How Access Affects Execution:</p> <pre><code>graph LR\n    A[\"debug_system&lt;br/&gt;@system.dev&lt;br/&gt;(Group 1)\"]\n    B[\"movement&lt;br/&gt;reads: Pos, Vel&lt;br/&gt;(Group 2)\"]\n    C[\"damage&lt;br/&gt;writes: Health&lt;br/&gt;(Group 2)\"]\n    D[\"render&lt;br/&gt;full access&lt;br/&gt;(Group 2)\"]\n\n    A --&gt;|runs first,&lt;br/&gt;then| B\n    B -.runs in parallel.- C\n    C -.runs in parallel.- D\n\n    style A fill:#ffcdd2\n    style B fill:#c8e6c9\n    style C fill:#c8e6c9\n    style D fill:#c8e6c9</code></pre> <p>Snapshot Isolation and Merge Strategies</p> <p>All systems in an execution group see the same initial state (snapshot isolation). When multiple systems write to the same entity/component, results are merged using configurable strategies:</p> <ul> <li>LastWriterWins (default): Later system (by registration) overwrites earlier</li> <li>MergeableFirst: Use <code>__merge__</code> method if available</li> <li>Error: Raise exception on conflict (useful for debugging)</li> </ul> <p>See Scheduling for details on merge strategies.</p>"},{"location":"system/systems/#when-to-use-access-declarations","title":"When to Use Access Declarations","text":"<p>Access declarations are optional in AgentECS. Under snapshot isolation with merge strategies, correctness doesn't require declarations. Here's when each approach is appropriate:</p> Approach Syntax Use When No declarations <code>@system()</code> Quick prototyping, scripts, simple systems With declarations <code>@system(reads=..., writes=...)</code> Production code, team projects, complex systems Dev mode <code>@system.dev()</code> Debugging, inspecting state, tracing issues <p>Benefits of Declaring Access:</p> <ul> <li>Runtime validation: Catch accidental access to undeclared components</li> <li>Documentation: Declarations show intent at a glance</li> <li>Future optimization: Declarations enable smarter scheduling (planned)</li> <li>Refactoring safety: Easier to understand what a system touches</li> </ul> <p>When to Skip Declarations:</p> <ul> <li>Rapid prototyping where you're still figuring out what components you need</li> <li>One-off scripts or experiments</li> <li>Systems that legitimately need access to many/all components (aggregators, debuggers)</li> </ul> <pre><code># Quick prototype - figure out what you need first\n@system()\ndef experimental(world: ScopedAccess) -&gt; None:\n    for e, pos in world(Position):\n        # Still exploring what else we need...\n        if Health in world.entity(e):\n            world[e, Health] = Health(100)\n\n# Production - declare what you use\n@system(reads=(Position, Health), writes=(Health,))\ndef production_ready(world: ScopedAccess) -&gt; None:\n    for e, pos, health in world(Position, Health):\n        world[e, Health] = Health(100)\n</code></pre> <p>Gradual Adoption</p> <p>Start with <code>@system()</code> to explore, then add declarations as your system stabilizes. This keeps iteration fast while enabling validation in production.</p>"},{"location":"system/systems/#frequency","title":"Frequency","text":"<p>Future Feature</p> <p><code>frequency</code> parameter exists but isn't yet used by scheduler:</p> <pre><code>@system(reads=(A,), writes=(B,), frequency=0.5)\ndef every_other_tick(world: ScopedAccess) -&gt; None:\n    # Future: Run every 2 ticks\n    pass\n</code></pre> <p>Planned for frequency-based execution in a future release.</p>"},{"location":"system/systems/#conditions","title":"Conditions","text":"<p>Future Feature</p> <p>Condition-based execution is planned but not yet implemented:</p> <pre><code># Future API (not yet available)\n@system(reads=(Temperature,), writes=(Alert,),\n        condition=lambda world: world.singleton(Temperature).value &gt; 100)\ndef overheat_alert(world: ScopedAccess) -&gt; None:\n    pass\n</code></pre>"},{"location":"system/systems/#dependencies","title":"Dependencies","text":"<p>Future Feature</p> <p>Explicit dependencies are planned but not yet implemented:</p> <pre><code># Future API (not yet available)\n@system(reads=(A,), writes=(B,), depends_on=[systemA, systemB])\ndef dependent_system(world: ScopedAccess) -&gt; None:\n    # Runs after systemA and systemB\n    pass\n</code></pre> <p>Currently, use execution groups to control ordering. Dev mode systems run in separate groups before normal systems.</p>"},{"location":"system/systems/#typical-workflows","title":"Typical Workflows","text":"<p>AgentECS is extremely flexible in how systems can be defined. Here are common patterns to get started:</p>"},{"location":"system/systems/#pattern-match-and-execute-per-entity","title":"Pattern-Match and execute per entity","text":"<p>Process each entity individually based on its components:</p> <pre><code>@system(reads=(Position, Velocity, Health), writes=(Position, Health))\ndef entity_update(world: ScopedAccess) -&gt; None:\n    \"\"\"Update each entity independently.\"\"\"\n    for entity, pos, vel, health in world(Position, Velocity, Health):\n        # Move entity\n        new_pos = Position(pos.x + vel.dx, pos.y + vel.dy)\n\n        # Damage if out of bounds\n        if new_pos.x &lt; 0 or new_pos.x &gt; 100:\n            world[entity, Health] = Health(health.hp - 10, health.max_hp)\n\n        world[entity, Position] = new_pos\n</code></pre> <p>When to Use</p> <p>Use for logic that applies independently to each entity (movement, health decay, AI decisions).</p>"},{"location":"system/systems/#identify-and-operate-on-groups-of-entities","title":"Identify and operate on groups of entities","text":"<p>Collect entities, analyze as a group, then update:</p> <pre><code>@system(reads=(Position, AgentTag, Opinion), writes=(Opinion,))\ndef consensus_building(world: ScopedAccess) -&gt; None:\n    \"\"\"Agents in proximity influence each other's opinions.\"\"\"\n    agents = [(e, pos, opinion) for e, pos, opinion in world(Position, AgentTag, Opinion)]\n\n    for entity, pos, opinion in agents:\n        # Find nearby agents\n        nearby = [other_op for e, other_pos, other_op in agents\n                  if e != entity and distance(pos, other_pos) &lt; 10]\n\n        if nearby:\n            # Average with nearby opinions\n            avg_opinion = sum(op.value for op in nearby) / len(nearby)\n            blended = (opinion.value * 0.7 + avg_opinion * 0.3)\n            world[entity, Opinion] = Opinion(blended)\n</code></pre> <p>When to Use</p> <p>Use for logic requiring awareness of multiple entities (consensus, flocking, collision detection).</p>"},{"location":"system/systems/#global-coordination-and-world-state","title":"Global coordination and world state","text":"<p>Systems can access singleton components for global parameters:</p> <pre><code>@system.dev()  # Dev mode to access singleton\ndef temperature_adjustment(world: ScopedAccess) -&gt; None:\n    \"\"\"Adjust global temperature based on agent consensus.\"\"\"\n    from agentecs import SystemEntity\n\n    # Count agents with ConvergingTag\n    converging_count = sum(1 for _ in world(Position, ConvergingTag))\n    total_count = sum(1 for _ in world(Position, AgentTag))\n\n    if total_count &gt; 0:\n        ratio = converging_count / total_count\n\n        # If majority converging, reduce temperature (decrease exploration)\n        config = world[SystemEntity.WORLD, GlobalConfig]\n        if ratio &gt; 0.7:\n            world[SystemEntity.WORLD, GlobalConfig] = GlobalConfig(\n                temperature=max(0.1, config.temperature - 0.1)\n            )\n</code></pre> <p>When to Use</p> <p>Use for systems that modify global parameters based on aggregate state (temperature, difficulty, resource availability).</p>"},{"location":"system/systems/#shared-resources","title":"Shared resources","text":"<p>Model resources shared across entities:</p> <pre><code>@component\n@dataclass\nclass ResourceAccess:\n    requested: float\n\n@system.dev()\ndef resource_allocation(world: ScopedAccess) -&gt; None:\n    \"\"\"Allocate limited resources to competing agents.\"\"\"\n    from agentecs import SystemEntity\n\n    # Get shared pool\n    pool = world[SystemEntity.WORLD, ResourcePool]\n    available = pool.amount\n\n    # Collect requests\n    requests = [(e, req.requested) for e, req in world(ResourceAccess)]\n    total_requested = sum(amt for _, amt in requests)\n\n    # Proportional allocation\n    for entity, requested in requests:\n        if total_requested &gt; 0:\n            allocated = (requested / total_requested) * min(available, total_requested)\n            world[entity, Resources] = Resources(allocated)\n</code></pre> <p>When to Use</p> <p>Use for competitive resource allocation (context windows, compute, database connections).</p>"},{"location":"system/systems/#exchange-of-resources-between-entities","title":"Exchange of resources between entities","text":"<p>Model bilateral or market-based exchanges:</p> <pre><code>@system(reads=(Credits, TradeOffer), writes=(Credits,))\ndef execute_trades(world: ScopedAccess) -&gt; None:\n    \"\"\"Execute valid trade offers between entities.\"\"\"\n    offers = [(e, offer) for e, offer in world(TradeOffer)]\n\n    for entity, offer in offers:\n        if world.has(entity, Credits) and world.has(offer.target, Credits):\n            buyer_credits = world[entity, Credits]\n            seller_credits = world[offer.target, Credits]\n\n            if buyer_credits.amount &gt;= offer.price:\n                # Execute trade\n                world[entity, Credits] = Credits(buyer_credits.amount - offer.price)\n                world[offer.target, Credits] = Credits(seller_credits.amount + offer.price)\n</code></pre> <p>When to Use</p> <p>Use for agent-to-agent transactions (trading, task delegation, information exchange).</p>"},{"location":"system/systems/#async-systems","title":"Async Systems","text":"<p>Systems can be async for I/O-bound operations:</p> <pre><code>@system(reads=(Query,), writes=(Response,))\nasync def llm_inference(world: ScopedAccess) -&gt; None:\n    \"\"\"Call LLM API for entities with queries.\"\"\"\n    import asyncio\n\n    tasks = []\n    entities = []\n\n    for entity, query in world(Query):\n        task = call_llm_api(query.text)  # Async function\n        tasks.append(task)\n        entities.append(entity)\n\n    # Parallel API calls\n    responses = await asyncio.gather(*tasks)\n\n    for entity, response in zip(entities, responses):\n        world[entity, Response] = Response(response)\n</code></pre> <p>Async Detection</p> <p>AgentECS automatically detects async systems via <code>inspect.iscoroutinefunction()</code>. Mix sync and async systems freely\u2014the framework handles both.</p> <p>When to Use Async</p> <p>Use async systems for:</p> <ul> <li>LLM API calls</li> <li>Database queries</li> <li>Network I/O</li> <li>Any operation that would block</li> </ul> <p>The scheduler will <code>await</code> async systems and run them concurrently when possible.</p>"},{"location":"system/systems/#system-best-practices","title":"System Best Practices","text":"<p>Small, Focused Systems</p> <p>Prefer many small systems over few large ones. Small systems are easier to reason about and maintain.</p> <p>Start Without Declarations</p> <p>Start with <code>@system()</code> (no declarations) for quick prototyping. Add <code>reads</code>/<code>writes</code> when you want validation and documentation.</p> <p>Declare What You Use</p> <p>When declaring access, only list the component types you actually need. This provides runtime validation and documents intent.</p> <p>Avoid Hidden State</p> <p>Systems should not maintain state between ticks in global variables or class attributes. All state should live in components.</p> <p>Use EntityHandle for Multiple Accesses</p> <p>If accessing many components on the same entity, use <code>world.entity(entity_id)</code> to get a convenient handle.</p> <p>Dev Mode for Debugging</p> <p>Use <code>@system.dev()</code> when debugging. It runs in isolation (separate execution group), making it easier to reason about state changes without interference from other systems.</p>"},{"location":"system/systems/#see-also","title":"See Also","text":"<ul> <li>Components: Define the data systems operate on</li> <li>Queries: Advanced query patterns with filters</li> <li>World Management: How systems interact with the world</li> <li>Scheduling: How systems are executed and parallelized</li> </ul>"},{"location":"system/world_management/","title":"World Management","text":"<p>The World serves as the central hub for managing entities, components, and systems within AgentECS. It coordinates entity lifecycle, orchestrates system execution, and maintains consistency through tick-based updates.</p>"},{"location":"system/world_management/#overview","title":"Overview","text":"<p>The <code>World</code> is the main entry point for AgentECS. It owns the storage backend and execution strategy, providing a clean API for entity management while systems interact through <code>ScopedAccess</code> for controlled, safe access.</p> <p>Key Responsibilities:</p> <ul> <li>Entity Lifecycle: Create, destroy, merge, and split entities</li> <li>Component Management: Get/set components on entities</li> <li>System Orchestration: Register and execute systems via execution strategy</li> <li>Tick Coordination: Advance simulation time with atomic state updates</li> <li>Singleton Management: Global state via well-known entities</li> </ul> <pre><code>graph TD\n    A[World] --&gt;|owns| B[Storage Backend]\n    A --&gt;|owns| C[Execution Strategy]\n    A --&gt;|provides| D[External API]\n    A --&gt;|creates| E[ScopedAccess for Systems]\n\n    B --&gt;|stores| F[Entities &amp; Components]\n    C --&gt;|schedules| G[System Execution]\n    E --&gt;|accesses| B\n    E --&gt;|writes to| H[Buffer]\n    H --&gt;|applied by| A\n\n    style A fill:#4fc3f7\n    style B fill:#81c784\n    style C fill:#ffb74d\n    style E fill:#ba68c8</code></pre>"},{"location":"system/world_management/#world-structure","title":"World Structure","text":"<p>The World is initialized with optional storage and execution strategy:</p> <pre><code>from agentecs import World\nfrom agentecs.scheduling import SimpleScheduler\nfrom agentecs.storage import LocalStorage\n\n# Default: LocalStorage + SimpleScheduler\nworld = World()\n\n# Custom storage\nworld = World(storage=LocalStorage(shard=0))\n\n# Custom execution strategy\nworld = World(execution=SimpleScheduler())  # Parallel scheduler\n\n# Both custom\nworld = World(\n    storage=LocalStorage(),\n    execution=SimpleScheduler()\n)\n</code></pre> <p>World Internals:</p> <ul> <li><code>_storage</code>: Storage backend (implements <code>Storage</code> protocol)</li> <li><code>_execution</code>: Execution strategy (implements <code>ExecutionStrategy</code> protocol)</li> <li>Reserved entities: <code>SystemEntity.WORLD</code>, <code>SystemEntity.CLOCK</code> (created automatically)</li> </ul>"},{"location":"system/world_management/#tick-execution","title":"Tick Execution","text":"<p>Ticks are the fundamental unit of simulation time in AgentECS. Each tick executes execution groups sequentially, applying results at group boundaries:</p> <ol> <li>Build execution plan (group systems by execution strategy)</li> <li>For each execution group:</li> <li>Execute systems in parallel with snapshot isolation</li> <li>Merge results using configured strategy</li> <li>Apply changes atomically to storage</li> <li>Next group sees applied changes</li> </ol> <pre><code>sequenceDiagram\n    participant User\n    participant World\n    participant Scheduler\n    participant Storage\n\n    User-&gt;&gt;World: tick_async()\n    World-&gt;&gt;Scheduler: tick_async(world)\n\n    Note over Scheduler: Build execution plan\n\n    loop For each ExecutionGroup\n        Note over Scheduler: Execute systems in parallel\n        Scheduler-&gt;&gt;Scheduler: Merge results\n        Scheduler-&gt;&gt;World: apply_result_async(merged)\n        World-&gt;&gt;Storage: Apply updates\n        Note over Storage: Changes now visible\n    end\n\n    Scheduler--&gt;&gt;World: All groups complete\n    World--&gt;&gt;User: Tick complete</code></pre> <p>Basic Usage:</p> <pre><code>world = World()\n\n# Register systems\nworld.register_system(movement_system)\nworld.register_system(collision_system)\n\n# Advance simulation\nworld.tick()  # Sync wrapper\n# or\nawait world.tick_async()  # Async\n</code></pre> <p>Tick Methods:</p> Async (Recommended)Sync Wrapper <pre><code>async def main():\n    world = World()\n    world.register_system(my_system)\n\n    for _ in range(100):\n        await world.tick_async()\n</code></pre> <pre><code>def main():\n    world = World()\n    world.register_system(my_system)\n\n    for _ in range(100):\n        world.tick()  # Calls asyncio.run() internally\n</code></pre> <p>Use Async for I/O-Bound Workloads</p> <p>If your systems make API calls, database queries, or other I/O operations, use <code>tick_async()</code> directly for better concurrency.</p>"},{"location":"system/world_management/#snapshot-isolation-within-execution-groups","title":"Snapshot Isolation Within Execution Groups","text":"<p>Systems within the same execution group see the same initial snapshot:</p> <pre><code># Initial state: Entity has Position(0, 0)\n\n# Both in same execution group (normal systems)\n@system(reads=(Position,), writes=(Position,))\ndef system_a(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        world[entity, Position] = Position(10, 10)\n        # System A's buffer: Position(10, 10)\n\n@system(reads=(Position,), writes=(Velocity,))\ndef system_b(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        # System B sees Position(0, 0) from snapshot\n        # NOT System A's buffered Position(10, 10)\n        print(f\"Position: {pos.x}, {pos.y}\")  # Prints: 0, 0\n\n# After group: Results merged and Position(10, 10) applied to storage\n# Next group would see Position(10, 10)\n</code></pre> <p>Dev systems see previous group changes:</p> <pre><code>@system.dev()  # Runs in own group, BEFORE normal systems\ndef debug_system(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        world[entity, Position] = Position(5, 5)\n\n# debug_system runs \u2192 results applied \u2192 Position(5, 5) now in storage\n\n# Then normal systems run (same group)\n@system(reads=(Position,), writes=(Position,))\ndef normal_system(world: ScopedAccess) -&gt; None:\n    for entity, pos in world(Position):\n        # Sees Position(5, 5) from debug_system's group\n        print(f\"Position: {pos.x}, {pos.y}\")  # Prints: 5, 5\n</code></pre>"},{"location":"system/world_management/#entity-management","title":"Entity Management","text":""},{"location":"system/world_management/#creating-entities","title":"Creating Entities","text":"<p>spawn() - Create Entity with Components:</p> <pre><code>from agentecs import World\n\nworld = World()\n\n# Spawn entity with components\nagent = world.spawn(\n    Position(0, 0),\n    Velocity(1, 0),\n    Health(100, 100),\n    AgentTag(name=\"Alice\")\n)\n\n# Returns EntityId\nprint(agent)  # EntityId(shard=0, index=1, generation=0)\n\n# Spawn without components\nempty = world.spawn()\n</code></pre> <p>Batch Spawning:</p> <pre><code>agents = []\nfor i in range(100):\n    agent = world.spawn(\n        Position(i, 0),\n        Velocity(1, 0),\n        AIAgent(name=f\"Agent{i}\")\n    )\n    agents.append(agent)\n</code></pre> <p>spawn() is for External Use</p> <p>Use <code>world.spawn()</code> to create entities outside systems. Systems should use <code>ScopedAccess</code> methods or return spawn commands in <code>SystemResult</code>.</p>"},{"location":"system/world_management/#deleting-entities","title":"Deleting Entities","text":"<p>destroy() - Delete Entity:</p> <pre><code>world.destroy(entity_id)\n# Entity and all its components are removed\n</code></pre> <p>Destroying Non-Existent Entities</p> <p>Destroying an entity that doesn't exist or was already destroyed is a no-op in LocalStorage. Future storage backends may raise errors.</p> <p>Systems Can Destroy Entities:</p> <pre><code>@system.dev()\ndef cleanup_dead(world: ScopedAccess) -&gt; None:\n    \"\"\"Remove entities with health &lt;= 0.\"\"\"\n    to_remove = []\n    for entity, health in world(Health):\n        if health.hp &lt;= 0:\n            to_remove.append(entity)\n\n    for entity in to_remove:\n        world.destroy(entity)  # Mark for destruction\n</code></pre>"},{"location":"system/world_management/#splitting-and-merging-entities","title":"Splitting and Merging Entities","text":"<p>AgentECS supports dynamic entity composition through merge and split operations:</p>"},{"location":"system/world_management/#merge-entities","title":"Merge Entities","text":"<p>Combine two entities into one new entity:</p> <pre><code>from agentecs import NonMergeableHandling\n\n# Merge two agents\nmerged = world.merge_entities(\n    agent1,\n    agent2,\n    on_non_mergeable=NonMergeableHandling.FIRST\n)\n\n# agent1 and agent2 are destroyed\n# merged is a new entity with combined components\n</code></pre> <p>Merge Strategies:</p> <ul> <li> <p> FIRST</p> <p>Keep component from first entity</p> </li> <li> <p> SECOND</p> <p>Keep component from second entity</p> </li> <li> <p> SKIP</p> <p>Exclude component from merged entity</p> </li> <li> <p> ERROR</p> <p>Raise TypeError if component not Mergeable</p> </li> </ul> <p>Merge Behavior:</p> <pre><code>graph LR\n    A[\"Agent 1&lt;br/&gt;Position(0, 0)&lt;br/&gt;Credits: 100\"] --&gt;|merge| C[\"Merged Agent&lt;br/&gt;Position(5, 5)&lt;br/&gt;Credits: 150\"]\n    B[\"Agent 2&lt;br/&gt;Position(10, 10)&lt;br/&gt;Credits: 50\"] --&gt;|merge| C\n\n    style A fill:#ffcdd2\n    style B fill:#ffcdd2\n    style C fill:#c8e6c9</code></pre> <p>Components implementing <code>Mergeable</code> protocol are merged via <code>__merge__()</code>. Non-mergeable components use the specified strategy.</p> <p>Example:</p> <pre><code>@component\n@dataclass\nclass Credits:\n    amount: float\n\n    def __merge__(self, other: \"Credits\") -&gt; \"Credits\":\n        return Credits(self.amount + other.amount)\n\n@component\n@dataclass\nclass AgentTag:\n    name: str\n    # No __merge__ - not mergeable\n\n# Create agents\na1 = world.spawn(Credits(100), AgentTag(\"Alice\"))\na2 = world.spawn(Credits(50), AgentTag(\"Bob\"))\n\n# Merge - Credits sum, AgentTag uses FIRST strategy\nmerged = world.merge_entities(a1, a2, on_non_mergeable=NonMergeableHandling.FIRST)\n\ncredits = world.get(merged, Credits)\nprint(credits.amount)  # 150\n\ntag = world.get(merged, AgentTag)\nprint(tag.name)  # \"Alice\" (from first entity)\n</code></pre>"},{"location":"system/world_management/#split-entity","title":"Split Entity","text":"<p>Divide one entity into two new entities:</p> <pre><code>from agentecs import NonSplittableHandling\n\n# Split agent 70/30\nleft, right = world.split_entity(\n    agent,\n    ratio=0.7,\n    on_non_splittable=NonSplittableHandling.BOTH\n)\n\n# agent is destroyed\n# left gets 70%, right gets 30%\n</code></pre> <p>Split Strategies:</p> <ul> <li> <p> FIRST</p> <p>Give component to first entity only</p> </li> <li> <p> BOTH</p> <p>Deep copy component to both entities</p> </li> <li> <p> SKIP</p> <p>Exclude from both entities</p> </li> <li> <p> ERROR</p> <p>Raise TypeError if component not Splittable</p> </li> </ul> <p>Split Behavior:</p> <pre><code>graph LR\n    A[\"Agent&lt;br/&gt;Position(10, 10)&lt;br/&gt;Credits: 100\"] --&gt;|split 0.7| B[\"Left Agent&lt;br/&gt;Position(10, 10)&lt;br/&gt;Credits: 70\"]\n    A --&gt;|split 0.3| C[\"Right Agent&lt;br/&gt;Position(10, 10)&lt;br/&gt;Credits: 30\"]\n\n    style A fill:#ffcdd2\n    style B fill:#c8e6c9\n    style C fill:#c8e6c9</code></pre> <p>Example:</p> <pre><code>@component\n@dataclass\nclass Credits:\n    amount: float\n\n    def __split__(self, ratio: float = 0.5) -&gt; tuple[\"Credits\", \"Credits\"]:\n        left = Credits(self.amount * ratio)\n        right = Credits(self.amount * (1 - ratio))\n        return left, right\n\n@component\n@dataclass\nclass Position:\n    x: float\n    y: float\n    # No __split__ - not splittable\n\n# Create agent\nagent = world.spawn(Credits(100), Position(10, 10))\n\n# Split 60/40 - Credits split, Position cloned to both\nleft, right = world.split_entity(\n    agent,\n    ratio=0.6,\n    on_non_splittable=NonSplittableHandling.BOTH\n)\n\nleft_credits = world.get(left, Credits)\nprint(left_credits.amount)  # 60\n\nright_credits = world.get(right, Credits)\nprint(right_credits.amount)  # 40\n\n# Both have Position (cloned)\nassert world.get(left, Position).x == 10\nassert world.get(right, Position).x == 10\n</code></pre> <p>Use Cases for Merge/Split</p> <ul> <li>Agent Merging: Combine specialized agents into generalist</li> <li>Agent Splitting: Divide work across multiple agents</li> <li>Resource Distribution: Split resources between entities</li> <li>Consensus Building: Merge agents that converge on a solution</li> </ul>"},{"location":"system/world_management/#registering-systems","title":"Registering Systems","text":"<p>Systems are registered via <code>register_system()</code>, which delegates to the execution strategy:</p> <pre><code>world = World()\n\n# Register systems\nworld.register_system(movement_system)\nworld.register_system(collision_system)\nworld.register_system(render_system)\n\n# Order matters for sequential scheduler\n# Parallel scheduler groups non-conflicting systems\n</code></pre> <p>Registration is Declarative:</p> <pre><code>@system(reads=(A,), writes=(B,))\ndef my_system(world: ScopedAccess) -&gt; None:\n    pass\n\n# System metadata captured in SystemDescriptor\ndescriptor = my_system  # my_system IS a SystemDescriptor\nworld.register_system(descriptor)\n</code></pre> <p>Execution Strategy Decides Order</p> <ul> <li>SequentialScheduler: Runs systems one at a time (max_concurrent=1)</li> <li>SimpleScheduler: Runs all systems in parallel, merges results</li> <li>Future schedulers may reorder based on dependencies, frequency, or learned patterns</li> </ul>"},{"location":"system/world_management/#accessing-the-world-in-systems","title":"Accessing the World in Systems","text":"<p>Systems receive <code>ScopedAccess</code>, not <code>World</code> directly. This enforces access control and enables safe parallelization.</p>"},{"location":"system/world_management/#worldaccess-and-modes-of-access","title":"WorldAccess and Modes of Access","text":"<p>Three Access Interfaces:</p> <ol> <li>ScopedAccess - Standard access with read/write control</li> <li>ReadOnlyAccess - Read-only for observers and pure systems</li> <li>Dev Mode (ScopedAccess with AllAccess) - Unrestricted for debugging</li> </ol> <pre><code>from agentecs import ScopedAccess, ReadOnlyAccess, SystemMode\n\n# Standard system\n@system(reads=(Position,), writes=(Velocity,))\ndef standard(world: ScopedAccess) -&gt; None:\n    pass\n\n# Read-only system\n@system.readonly(reads=(Metrics,))\ndef observer(world: ReadOnlyAccess) -&gt; None:\n    pass\n\n# Pure system\n@system(reads=(Input,), writes=(Output,), mode=SystemMode.PURE)\ndef pure_transform(world: ReadOnlyAccess) -&gt; dict:\n    return {entity: {Output: Output(inp.value * 2)}\n            for entity, inp in world.query(Input)}\n\n# Dev mode\n@system.dev()\ndef debug(world: ScopedAccess) -&gt; None:\n    pass\n</code></pre>"},{"location":"system/world_management/#querying-entities-and-components","title":"Querying Entities and Components","text":"<p>See Queries for detailed query documentation.</p> <p>Quick Reference:</p> <pre><code>@system(reads=(Position, Velocity), writes=(Position,))\ndef movement(world: ScopedAccess) -&gt; None:\n    # Multi-component query\n    for entity, pos, vel in world(Position, Velocity):\n        world[entity, Position] = Position(pos.x + vel.dx, pos.y + vel.dy)\n\n    # Single component\n    for entity, pos in world(Position):\n        process(pos)\n\n    # With Query objects\n    from agentecs import Query\n    for entity, pos in world.query(Query(Position).excluding(FrozenTag)):\n        process(pos)\n</code></pre>"},{"location":"system/world_management/#direct-access-to-the-world","title":"Direct Access to the World","text":"<p><code>ScopedAccess</code> provides magic methods for direct component access:</p> <p>Reads Return Copies</p> <p><code>world[entity, Type]</code> and <code>world.get()</code> return deep copies. You must write back any changes via <code>world[entity, Type] = value</code>.</p> <p>Magic Method Reference:</p> <pre><code>@system.dev()\ndef direct_access_demo(world: ScopedAccess) -&gt; None:\n    entity = some_entity_id\n\n    # Get component (returns copy)\n    pos = world[entity, Position]\n\n    # Set component (buffered)\n    world[entity, Position] = Position(10, 20)\n\n    # Delete component (buffered)\n    del world[entity, Velocity]\n\n    # Check membership\n    if (entity, Health) in world:\n        print(\"Has health\")\n\n    # Has component (alternative)\n    if world.has(entity, Position):\n        print(\"Has position\")\n\n    # Get EntityHandle for repeated access\n    e = world.entity(entity)\n    e[Position] = Position(5, 5)\n    if Velocity in e:\n        vel = e[Velocity]\n</code></pre> <p>Buffer Awareness:</p> <pre><code>@system(reads=(Position,), writes=(Position,))\ndef buffering_demo(world: ScopedAccess) -&gt; None:\n    entity = some_entity\n\n    # Initial read from storage\n    pos1 = world[entity, Position]\n    print(pos1.x)  # e.g., 0\n\n    # Write to buffer\n    world[entity, Position] = Position(10, 10)\n\n    # Subsequent read sees buffer\n    pos2 = world[entity, Position]\n    print(pos2.x)  # 10 (from buffer)\n\n    # Storage still has old value until group boundary\n</code></pre>"},{"location":"system/world_management/#updating-the-world","title":"Updating the World","text":""},{"location":"system/world_management/#methods-for-updating-the-world-state","title":"Methods for Updating the World State","text":"<p>External API (Outside Systems):</p> <pre><code>world = World()\n\n# Spawn entities\nentity = world.spawn(Position(0, 0), Velocity(1, 0))\n\n# Get component (returns copy)\npos = world.get(entity, Position)\n\n# Set component\nworld.set(entity, Position(10, 10))\n\n# Destroy entity\nworld.destroy(entity)\n\n# Singletons\nworld.set_singleton(GlobalConfig(temperature=0.7))\nconfig = world.singleton(GlobalConfig)\n</code></pre> <p>System API (Inside Systems):</p> <pre><code>@system(reads=(Position,), writes=(Position, Velocity))\ndef system_updates(world: ScopedAccess) -&gt; None:\n    # Query and update\n    for entity, pos in world(Position):\n        world[entity, Position] = Position(pos.x + 1, pos.y)\n\n    # Spawn from system\n    new_entity = world.spawn(Position(0, 0), Velocity(1, 1))\n\n    # Destroy from system\n    world.destroy(old_entity)\n\n    # Direct component operations\n    world[entity, Velocity] = Velocity(2, 2)\n    del world[entity, SomeComponent]\n</code></pre>"},{"location":"system/world_management/#result-application-workflow","title":"Result Application Workflow","text":"<p>After each execution group completes, results are merged and applied:</p> <pre><code>sequenceDiagram\n    participant Sys as Systems (parallel)\n    participant SA as ScopedAccess\n    participant Sched as Scheduler\n    participant W as World\n    participant S as Storage\n\n    Note over Sys,SA: All systems in group execute\n    Sys-&gt;&gt;SA: world[e, T] = value\n    SA-&gt;&gt;SA: Write to buffer\n    Sys--&gt;&gt;Sched: Return SystemResults\n\n    Note over Sched: Merge results (strategy)\n    Sched-&gt;&gt;W: apply_result_async(merged)\n    W-&gt;&gt;S: Apply updates\n    S-&gt;&gt;S: Update storage\n    Note over S: Changes now visible</code></pre> <p>Application Order:</p> <ol> <li>Updates: Modify existing components</li> <li>Inserts: Add new components</li> <li>Removes: Delete components</li> <li>Spawns: Create entities</li> <li>Destroys: Delete entities</li> </ol> <p>Atomic Application at Group Boundaries</p> <p>All changes from an execution group are merged, then applied atomically to storage. Subsequent groups see these applied changes.</p>"},{"location":"system/world_management/#snapshots-and-restore","title":"Snapshots and Restore","text":"<p>World supports serialization for save/load functionality:</p> <pre><code># Save world state\nsnapshot_bytes = world.snapshot()\n\n# Store to disk\nwith open(\"save.bin\", \"wb\") as f:\n    f.write(snapshot_bytes)\n\n# Restore world state\nwith open(\"save.bin\", \"rb\") as f:\n    data = f.read()\n\nworld.restore(data)\n</code></pre> <p>Snapshot Limitations</p> <ul> <li>Only component data is serialized, not systems or execution state</li> <li>Uses <code>pickle</code> in LocalStorage (not secure for untrusted data)</li> <li>Custom serialization may be needed for distributed storage backends</li> </ul>"},{"location":"system/world_management/#world-best-practices","title":"World Best Practices","text":"<p>Prefer ScopedAccess in Systems</p> <p>Never pass <code>World</code> directly to systems. Always use <code>ScopedAccess</code> to enforce access control and enable parallelization.</p> <p>Batch Entity Operations</p> <p>Creating/destroying many entities? Do it outside systems when possible, or return batch operations in <code>SystemResult</code>.</p> <p>Don't Hold EntityId Across Ticks</p> <p>EntityIds use generational indices. An ID may be recycled for a different entity after destruction. Always check <code>world.has()</code> before use.</p> <p>Use Merge/Split Strategically</p> <p>Merge/split operations destroy original entities. Design your components and strategies carefully to preserve important data.</p> <p>Singletons for Global State</p> <p>Use <code>world.set_singleton()</code> for configuration, shared resources, or environment parameters. Access via <code>SystemEntity.WORLD</code> in systems.</p>"},{"location":"system/world_management/#see-also","title":"See Also","text":"<ul> <li>Components: Define data that entities hold</li> <li>Systems: Define logic that operates on entities</li> <li>Queries: Find entities by component combinations</li> <li>Scheduling: How the world orchestrates system execution</li> <li>Storage: How entities and components are stored</li> </ul>"},{"location":"viz/","title":"Visualization","text":"<p>Real-time visualization for AgentECS worlds. Watch entities spawn, evolve, and interact through an interactive canvas with semantic zoom levels.</p> <p>Separate Package</p> <p>The visualization tool is in a separate repository: agentecs-viz. This documentation covers usage; for development, see that repository.</p>"},{"location":"viz/#installation","title":"Installation","text":"<pre><code>pip install agentecs-viz\n</code></pre> <p>This installs <code>agentecs</code> as a dependency automatically.</p>"},{"location":"viz/#quick-start","title":"Quick Start","text":""},{"location":"viz/#demo-mode","title":"Demo Mode","text":"<p>Run with mock data to explore the interface:</p> <pre><code>agentecs-viz serve --mock\n</code></pre> <p>Open http://localhost:8000 in your browser.</p>"},{"location":"viz/#run-example-with-visualization","title":"Run Example with Visualization","text":"<pre><code># Install viz if not already installed\npip install agentecs-viz\n\n# Run the task dispatch example with visualization\npython examples/task_dispatch_app/main.py --viz\n</code></pre>"},{"location":"viz/#visualize-your-world","title":"Visualize Your World","text":"<p>Connect to an existing AgentECS world:</p> <pre><code># myapp/world.py\nfrom agentecs import World\nfrom agentecs_viz.sources import LocalWorldSource\n\nworld = World()\n# ... set up your world ...\n\n# Export for the visualizer\ndef get_world_source():\n    return LocalWorldSource(world, tick_interval=0.5)\n</code></pre> <p>Then run:</p> <pre><code>agentecs-viz serve -m myapp.world\n</code></pre> <p>Automatic Ticking</p> <p><code>LocalWorldSource</code> controls the World automatically\u2014it calls <code>tick_async()</code> at the configured interval. No manual tick notification needed.</p>"},{"location":"viz/#features","title":"Features","text":""},{"location":"viz/#semantic-zoom-levels","title":"Semantic Zoom Levels","text":"<p>The Petri Dish canvas automatically adapts based on zoom level:</p> Level Scale View MICRO &gt; 2.5\u00d7 Focal entity with full component details DETAIL 0.8\u20132.5\u00d7 Individual entities as colored circles MESO 0.3\u20130.8\u00d7 Clustered dots with count labels MACRO &lt; 0.3\u00d7 Density heat map"},{"location":"viz/#timeline-replay","title":"Timeline &amp; Replay","text":"<p>Record sessions and replay them later:</p> <pre><code># Record while serving\nagentecs-viz serve -m myapp.world --record-to trace.jsonl\n\n# Replay a recording\nagentecs-viz replay trace.jsonl\n</code></pre> <p>The timeline bar at the bottom allows scrubbing through history.</p>"},{"location":"viz/#tabs","title":"Tabs","text":"<ul> <li>Petri Dish \u2013 Interactive canvas with pan/zoom</li> <li>List \u2013 Sortable entity table with expandable details</li> <li>Data \u2013 Statistics, archetype distribution, CSV/JSON export</li> <li>Timeline \u2013 Entity lifecycle swimlanes</li> <li>Archetypes \u2013 Component pattern groupings</li> <li>Chat \u2013 Task/agent interaction panel</li> </ul>"},{"location":"viz/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>1</code>\u2013<code>6</code> Switch tabs <code>Space</code> Play/pause <code>\u2192</code> Step forward (when paused) <code>+</code> / <code>-</code> Zoom in/out"},{"location":"viz/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture \u2013 System design and protocols</li> <li>CLI Reference \u2013 Command options</li> <li>Extending \u2013 Custom sources and theming</li> </ul>"},{"location":"viz/architecture/","title":"Architecture","text":""},{"location":"viz/architecture/#system-overview","title":"System Overview","text":"<pre><code>graph LR\n    W[World] --&gt; LS[LocalWorldSource]\n    LS --&gt; S[FastAPI Server]\n    S --&gt;|WebSocket| F[Svelte Frontend]\n    F --&gt; P[PixiJS Canvas]\n\n    subgraph Backend\n        LS\n        S\n    end\n\n    subgraph Frontend\n        F\n        P\n    end</code></pre> <p>The visualizer has three layers:</p> <ol> <li>Source \u2013 Wraps a World and emits snapshots</li> <li>Server \u2013 FastAPI with WebSocket streaming</li> <li>Frontend \u2013 Svelte 5 + PixiJS 8 canvas</li> </ol>"},{"location":"viz/architecture/#worldstatesource-protocol","title":"WorldStateSource Protocol","text":"<p>All sources implement this async protocol:</p> <pre><code>class WorldStateSource(Protocol):\n    async def connect(self) -&gt; None: ...\n    async def disconnect(self) -&gt; None: ...\n    async def get_snapshot(self) -&gt; WorldSnapshot: ...\n    def subscribe_events(self) -&gt; AsyncIterator[WorldEvent]: ...\n    async def send_command(self, command: str, **kwargs) -&gt; None: ...\n\n    @property\n    def is_connected(self) -&gt; bool: ...\n</code></pre>"},{"location":"viz/architecture/#commands","title":"Commands","text":"Command Args Description <code>pause</code> \u2013 Pause world execution <code>resume</code> \u2013 Resume execution <code>step</code> \u2013 Execute single tick (when paused) <code>set_tick_rate</code> <code>ticks_per_second</code> Change tick rate <code>seek</code> <code>tick</code> Jump to tick (replay only) <code>set_speed</code> <code>speed</code> Playback multiplier (replay only)"},{"location":"viz/architecture/#data-models","title":"Data Models","text":""},{"location":"viz/architecture/#worldsnapshot","title":"WorldSnapshot","text":"<pre><code>class WorldSnapshot(BaseModel):\n    tick: int = 0\n    entity_count: int = 0\n    entities: list[EntitySnapshot] = []\n    metadata: dict[str, Any] = {}\n\n    @computed_field\n    def archetypes(self) -&gt; list[tuple[str, ...]]: ...\n</code></pre>"},{"location":"viz/architecture/#entitysnapshot","title":"EntitySnapshot","text":"<pre><code>class EntitySnapshot(BaseModel):\n    id: int\n    components: list[ComponentSnapshot]\n\n    @computed_field\n    def archetype(self) -&gt; tuple[str, ...]: ...\n</code></pre>"},{"location":"viz/architecture/#componentsnapshot","title":"ComponentSnapshot","text":"<pre><code>class ComponentSnapshot(BaseModel):\n    type_name: str   # \"myapp.components.Position\"\n    type_short: str  # \"Position\"\n    data: dict[str, Any]\n</code></pre>"},{"location":"viz/architecture/#source-types","title":"Source Types","text":"Source Use Case History <code>LocalWorldSource</code> In-process World No <code>MockWorldSource</code> Testing/demos No <code>ReplayWorldSource</code> Playback recordings Yes <code>HistoryCapturingSource</code> Wrap any source + record Yes"},{"location":"viz/architecture/#localworldsource","title":"LocalWorldSource","text":"<p>Wraps an AgentECS World instance and controls tick execution:</p> <pre><code>from agentecs import World\nfrom agentecs_viz.sources import LocalWorldSource\n\nworld = World()\nsource = LocalWorldSource(world, tick_interval=0.5)\n\nawait source.connect()\n# Ticks happen automatically at tick_interval\n# Use send_command(\"pause\"/\"resume\"/\"step\") to control\n</code></pre>"},{"location":"viz/architecture/#mockworldsource","title":"MockWorldSource","text":"<p>Generates fake entities for development:</p> <pre><code>from agentecs_viz.sources import MockWorldSource\n\nsource = MockWorldSource(\n    entity_count=50,\n    tick_interval=1.0,\n    archetypes=[\n        (\"Position\", \"Velocity\"),\n        (\"Task\", \"Priority\"),\n        (\"Agent\", \"Memory\"),\n    ]\n)\n</code></pre>"},{"location":"viz/architecture/#replayworldsource","title":"ReplayWorldSource","text":"<p>Plays back from a HistoryStore:</p> <pre><code>from agentecs_viz.sources import ReplayWorldSource\nfrom agentecs_viz.history import FileHistoryStore\n\nstore = FileHistoryStore(Path(\"trace.jsonl\"), mode=\"r\")\nsource = ReplayWorldSource(store, autoplay=False)\n</code></pre>"},{"location":"viz/architecture/#event-types","title":"Event Types","text":"<pre><code>class TickEvent(WorldEvent):\n    snapshot: WorldSnapshot\n\nclass HistoryInfoEvent(WorldEvent):\n    supports_replay: bool\n    tick_range: tuple[int, int] | None\n    is_paused: bool\n\nclass SeekCompleteEvent(WorldEvent):\n    tick: int\n    snapshot: WorldSnapshot\n</code></pre>"},{"location":"viz/architecture/#frontend-stack","title":"Frontend Stack","text":"Layer Technology Framework Svelte 5 (runes) Canvas PixiJS 8 Pan/Zoom pixi-viewport Styling Tailwind CSS v4 State Svelte stores Build Vite"},{"location":"viz/architecture/#semantic-zoom","title":"Semantic Zoom","text":"<p>The canvas renders differently based on viewport scale:</p> <pre><code>MICRO (&gt;2.5\u00d7)     DETAIL (0.8-2.5\u00d7)    MESO (0.3-0.8\u00d7)    MACRO (&lt;0.3\u00d7)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u250c\u2500\u2500\u2500\u2510   \u2502      \u2502  \u25cb \u25cb     \u2502         \u2502  \u00b7  \u00b7    \u2502       \u2502\u2593\u2593\u2593\u2591\u2591\u2591\u2591\u2591\u2591\u2502\n\u2502  \u2502 A \u2502   \u2502      \u2502    \u25cb \u25cb   \u2502         \u2502   (12)   \u2502       \u2502\u2593\u2593\u2593\u2593\u2591\u2591\u2591\u2591\u2591\u2502\n\u2502  \u2502pos\u2502   \u2502      \u2502  \u25cb    \u25cb  \u2502         \u2502  \u00b7  \u00b7 \u00b7  \u2502       \u2502\u2591\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2518   \u2502      \u2502     \u25cb    \u2502         \u2502    (8)   \u2502       \u2502\u2591\u2591\u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n Focal entity     Colored circles      Clusters+labels    Density heatmap\n</code></pre>"},{"location":"viz/architecture/#websocket-protocol","title":"WebSocket Protocol","text":"<p>The server streams JSON messages over <code>/ws</code>:</p> <p>Server \u2192 Client: <pre><code>{\"type\": \"tick\", \"snapshot\": {...}}\n{\"type\": \"history_info\", \"supports_replay\": true, \"tick_range\": [0, 100], \"is_paused\": false}\n{\"type\": \"seek_complete\", \"tick\": 50, \"snapshot\": {...}}\n</code></pre></p> <p>Client \u2192 Server: <pre><code>{\"command\": \"pause\"}\n{\"command\": \"resume\"}\n{\"command\": \"step\"}\n{\"command\": \"seek\", \"tick\": 42}\n{\"command\": \"set_tick_rate\", \"ticks_per_second\": 2}\n</code></pre></p>"},{"location":"viz/cli/","title":"CLI Reference","text":""},{"location":"viz/cli/#agentecs-viz-serve","title":"agentecs-viz serve","text":"<p>Start the visualization server.</p> <pre><code>agentecs-viz serve [OPTIONS]\n</code></pre>"},{"location":"viz/cli/#options","title":"Options","text":"Option Default Description <code>-m, --world-module</code> \u2013 Python module path (e.g., <code>myapp.world</code>) <code>--mock</code> \u2013 Use MockWorldSource for demo <code>-p, --port</code> 8000 Server port <code>--host</code> 127.0.0.1 Server host <code>--no-frontend</code> \u2013 API only, don't serve static files <code>--record-to</code> \u2013 Record trace to file while serving <code>-v, --verbose</code> \u2013 Enable debug logging"},{"location":"viz/cli/#examples","title":"Examples","text":"<pre><code># Demo with mock data\nagentecs-viz serve --mock\n\n# Load from Python module\nagentecs-viz serve -m myapp.world\n\n# Custom port\nagentecs-viz serve --port 3000\n\n# Record while serving\nagentecs-viz serve -m myapp.world --record-to trace.jsonl\n</code></pre>"},{"location":"viz/cli/#module-loading","title":"Module Loading","text":"<p>When using <code>-m</code>, the CLI looks for (in order):</p> <ol> <li><code>get_world_source()</code> function \u2192 returns WorldStateSource</li> <li><code>world_source</code> attribute \u2192 WorldStateSource instance</li> <li><code>world</code> attribute \u2192 wrapped with LocalWorldSource</li> </ol> <pre><code># myapp/world.py\n\n# Option 1: Factory function (recommended)\ndef get_world_source():\n    world = create_my_world()\n    return LocalWorldSource(world)\n\n# Option 2: Direct attribute\nworld_source = LocalWorldSource(my_world)\n\n# Option 3: Just the world\nworld = World()  # CLI wraps it automatically\n</code></pre>"},{"location":"viz/cli/#agentecs-viz-record","title":"agentecs-viz record","text":"<p>Record a trace file without serving the UI.</p> <pre><code>agentecs-viz record -o FILE [OPTIONS]\n</code></pre>"},{"location":"viz/cli/#options_1","title":"Options","text":"Option Default Description <code>-o, --output</code> required Output file path (.jsonl) <code>-m, --world-module</code> \u2013 Python module path <code>--mock</code> \u2013 Use MockWorldSource <code>--ticks</code> \u2013 Number of ticks to record <code>--duration</code> \u2013 Max duration in seconds <code>--tick-interval</code> 0.5 Seconds between ticks <code>-v, --verbose</code> \u2013 Enable debug logging"},{"location":"viz/cli/#examples_1","title":"Examples","text":"<pre><code># Record mock until Ctrl+C\nagentecs-viz record -o trace.jsonl --mock\n\n# Record from module\nagentecs-viz record -m myapp.world -o trace.jsonl\n\n# Record exactly 100 ticks\nagentecs-viz record --mock -o trace.jsonl --ticks 100\n\n# Record for 30 seconds\nagentecs-viz record --mock -o trace.jsonl --duration 30\n</code></pre> <p>Press <code>Ctrl+C</code> to stop recording.</p>"},{"location":"viz/cli/#agentecs-viz-replay","title":"agentecs-viz replay","text":"<p>Replay a recorded trace file.</p> <pre><code>agentecs-viz replay FILE [OPTIONS]\n</code></pre>"},{"location":"viz/cli/#options_2","title":"Options","text":"Option Default Description <code>FILE</code> required Trace file to replay (.jsonl) <code>-p, --port</code> 8000 Server port <code>--host</code> 127.0.0.1 Server host <code>--speed</code> 1.0 Playback speed multiplier <code>--no-frontend</code> \u2013 API only <code>-v, --verbose</code> \u2013 Enable debug logging"},{"location":"viz/cli/#examples_2","title":"Examples","text":"<pre><code># Normal replay\nagentecs-viz replay trace.jsonl\n\n# 2x speed\nagentecs-viz replay trace.jsonl --speed 2.0\n\n# Custom port\nagentecs-viz replay trace.jsonl --port 3001\n</code></pre>"},{"location":"viz/cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>VITE_WS_PORT</code> Override WebSocket port in frontend build"},{"location":"viz/cli/#trace-file-format","title":"Trace File Format","text":"<p>Traces use JSON Lines format (<code>.jsonl</code>):</p> <pre><code>{\"tick\": 0, \"timestamp\": 1704067200.0, \"snapshot\": {...}, \"events\": []}\n{\"tick\": 1, \"timestamp\": 1704067200.5, \"snapshot\": {...}, \"events\": []}\n</code></pre> <p>Each line is a <code>TickRecord</code> with:</p> <ul> <li><code>tick</code> \u2013 Tick number</li> <li><code>timestamp</code> \u2013 Unix timestamp</li> <li><code>snapshot</code> \u2013 Full WorldSnapshot</li> <li><code>events</code> \u2013 List of events (currently unused)</li> </ul>"},{"location":"viz/extending/","title":"Extending","text":""},{"location":"viz/extending/#custom-worldstatesource","title":"Custom WorldStateSource","text":"<p>Implement the protocol to visualize any data source:</p> <pre><code>from collections.abc import AsyncIterator\nfrom agentecs_viz.protocol import WorldStateSource, WorldEvent, TickEvent\nfrom agentecs_viz.snapshot import WorldSnapshot, EntitySnapshot, ComponentSnapshot\n\nclass MyCustomSource:\n    def __init__(self):\n        self._connected = False\n\n    @property\n    def is_connected(self) -&gt; bool:\n        return self._connected\n\n    async def connect(self) -&gt; None:\n        self._connected = True\n        # Initialize your data source\n\n    async def disconnect(self) -&gt; None:\n        self._connected = False\n        # Clean up resources\n\n    async def get_snapshot(self) -&gt; WorldSnapshot:\n        # Build snapshot from your data\n        entities = [\n            EntitySnapshot(\n                id=1,\n                components=[\n                    ComponentSnapshot(\n                        type_name=\"myapp.Position\",\n                        type_short=\"Position\",\n                        data={\"x\": 10.0, \"y\": 20.0}\n                    )\n                ]\n            )\n        ]\n        return WorldSnapshot(tick=0, entity_count=len(entities), entities=entities)\n\n    async def subscribe_events(self) -&gt; AsyncIterator[WorldEvent]:\n        # Yield events as they occur\n        while self._connected:\n            snapshot = await self.get_snapshot()\n            yield TickEvent(snapshot)\n            await asyncio.sleep(1.0)\n\n    async def send_command(self, command: str, **kwargs) -&gt; None:\n        if command == \"pause\":\n            # Handle pause\n            pass\n</code></pre>"},{"location":"viz/extending/#history-stores","title":"History Stores","text":""},{"location":"viz/extending/#inmemoryhistorystore","title":"InMemoryHistoryStore","text":"<p>Bounded buffer for development:</p> <pre><code>from agentecs_viz.history import InMemoryHistoryStore\n\nstore = InMemoryHistoryStore(max_ticks=1000)\n</code></pre>"},{"location":"viz/extending/#filehistorystore","title":"FileHistoryStore","text":"<p>Persistent JSON Lines storage:</p> <pre><code>from pathlib import Path\nfrom agentecs_viz.history import FileHistoryStore\n\n# Write mode\nwith FileHistoryStore(Path(\"trace.jsonl\"), mode=\"w\") as store:\n    store.record_tick(tick_record)\n\n# Read mode\nstore = FileHistoryStore(Path(\"trace.jsonl\"), mode=\"r\")\nsnapshot = store.get_snapshot(tick=42)\n</code></pre>"},{"location":"viz/extending/#historycapturingsource","title":"HistoryCapturingSource","text":"<p>Wrap any source to add recording and replay:</p> <pre><code>from agentecs_viz.history import HistoryCapturingSource, InMemoryHistoryStore\nfrom agentecs_viz.sources import LocalWorldSource\n\nsource = LocalWorldSource(world, tick_interval=0.5)\nstore = InMemoryHistoryStore(max_ticks=500)\ncapturing = HistoryCapturingSource(source, store)\n\n# Now capturing.supports_replay == True\n# Use with create_app() for visualization with history\n</code></pre>"},{"location":"viz/extending/#theming","title":"Theming","text":"<p>The frontend uses CSS custom properties. Override in your own stylesheet:</p> <pre><code>:root {\n  /* Background colors */\n  --color-bg-primary: #0f0f1a;\n  --color-bg-secondary: #1a1a2e;\n  --color-bg-tertiary: #2a2a3e;\n\n  /* Text colors */\n  --color-text-primary: #f0f0f0;\n  --color-text-secondary: #a0a0b0;\n  --color-text-muted: #606070;\n\n  /* Accent */\n  --color-accent: #6366f1;\n\n  /* Status colors */\n  --color-success: #22c55e;\n  --color-warning: #f59e0b;\n  --color-error: #ef4444;\n}\n</code></pre>"},{"location":"viz/extending/#adding-tabs","title":"Adding Tabs","text":"<p>Tabs are Svelte components in <code>frontend/src/lib/</code> (in the agentecs-viz repository). Pattern:</p> <pre><code>&lt;!-- MyTab.svelte --&gt;\n&lt;script lang=\"ts\"&gt;\n  import { world } from \"./world.svelte\";\n\n  // Access world state via the store\n  const entities = $derived(world.entities);\n&lt;/script&gt;\n\n&lt;div class=\"p-4\"&gt;\n  &lt;h2&gt;My Custom Tab&lt;/h2&gt;\n  {#each entities as entity}\n    &lt;div&gt;{entity.id}: {entity.archetype.join(\", \")}&lt;/div&gt;\n  {/each}\n&lt;/div&gt;\n</code></pre> <p>Register in <code>App.svelte</code>:</p> <pre><code>&lt;TabBar tabs={[\n  { id: \"petri\", label: \"Petri Dish\" },\n  { id: \"mytab\", label: \"My Tab\" },  // Add here\n  // ...\n]} /&gt;\n\n{#if activeTab === \"mytab\"}\n  &lt;MyTab /&gt;\n{/if}\n</code></pre>"},{"location":"viz/extending/#websocket-api","title":"WebSocket API","text":"<p>Connect directly for custom integrations:</p> <pre><code>const ws = new WebSocket(\"ws://localhost:8000/ws\");\n\nws.onmessage = (event) =&gt; {\n  const msg = JSON.parse(event.data);\n  if (msg.type === \"tick\") {\n    console.log(\"Tick:\", msg.snapshot.tick);\n  }\n};\n\n// Send commands\nws.send(JSON.stringify({ command: \"pause\" }));\nws.send(JSON.stringify({ command: \"seek\", tick: 100 }));\n</code></pre>"}]}